,warning id,project,bug_pattern,commit,last_commit_checked,?,bug pattern category,package,class,field,method,type,expr,idents,start_line,end_line,label (automatically determined),commit url,"commit url (of the version compared to, if closed)",code (if open),label,method_content
0,363,derby,SBSC_USE_STRINGBUFFER_CONCATENATION,B,last,,PERFORMANCE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.FromList,,reOrder,,arrayVals,"arrayVals,arrayVals,i,joinOrder",995,995,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/compile/FromList.java#L995,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/compile/FromList.java,,close,"public void reOrder(int[] joinOrder)
	{
		int	posn;

		if (SanityManager.DEBUG)
		{
			if (joinOrder.length != size())
			{
				SanityManager.THROWASSERT(""In reOrder(), size of FromList is "" + size() + "" while size of joinOrder array is "" + joinOrder.length);
			}

			/*
			** Determine that the values in the list are unique and in range.
			** The easiest way to determine that they are unique is to add
			** them all up and see whether the result is what's expected
			** for that array size.
			*/
			int sum = 0;
			for (int i = 0; i < joinOrder.length; i++)
			{
				if (joinOrder[i] < 0 || joinOrder[i] > (joinOrder.length - 1))
				{
					SanityManager.THROWASSERT(""joinOrder["" + i + ""] == "" +
											joinOrder[i] +
											"" is out of range - must be between 0 and "" + 
											(joinOrder.length - 1) +
											"" inclusive."");
				}

				sum += joinOrder[i];
			}

			/*
			** The sum of all integers from 0 through n is (n * (n - 1)) / 2.
			*/
			if (sum != ( ( joinOrder.length * (joinOrder.length - 1) ) / 2) )
			{
				String arrayVals = """";
				for (int i = 0; i < joinOrder.length; i++)
					arrayVals = arrayVals + joinOrder[i] + "" "";
				SanityManager.THROWASSERT(""joinOrder array has some duplicate value: "" + arrayVals);
			}
		}

		/* Form a list that's in the order we want */
		QueryTreeNode[] orderedFL = new FromTable[joinOrder.length];
		for (posn = 0; posn < joinOrder.length; posn++)
		{
			/*
			** Get the element at the i'th join order position from the
			** current list and make it the next element of orderedList.
			*/
			orderedFL[posn] = elementAt(joinOrder[posn]);
		}

		/* Now orderedList has been built, so set this list to the same order */
		for (posn = 0; posn < joinOrder.length; posn++)
		{
			setElementAt(orderedFL[posn], posn);
		}
	}"
1,2561,lucene-solr,SBSC_USE_STRINGBUFFER_CONCATENATION,A,last,,PERFORMANCE,org.apache.lucene.index,org.apache.lucene.index.TestBackwardsCompatibility,,asString,,i,"i,l,s",528,528,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java#L528,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java,,unknown,"private String asString(String[] l) {
    String s = """";
    for(int i=0;i<l.length;i++) {
      if (i > 0) {
        s += ""\n    "";
      }
      s += l[i];
    }
    return s;
  }"
2,9869,ant,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Manifest$Attribute,,getValue,,fullValue,"fullValue,value",280,280,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Manifest.java#L280,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Manifest.java,,close,"public String getValue() {
            if (values.size() == 0) {
                return null;
            }

            String fullValue = """";
            for (Enumeration<String> e = getValues(); e.hasMoreElements();) {
                String value = e.nextElement();
                fullValue += value + "" "";
            }
            return fullValue.trim();
        }"
3,1056,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.JDTCompiler$1,,findType,,result += new String(compoundTypeName[i]);,,183,183,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/JDTCompiler.java#L183,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/JDTCompiler.java,,close,"@Override
                public NameEnvironmentAnswer
                    findType(char[][] compoundTypeName) {
                    String result = """";
                    String sep = """";
                    for (int i = 0; i < compoundTypeName.length; i++) {
                        result += sep;
                        result += new String(compoundTypeName[i]);
                        sep = ""."";
                    }
                    return findType(result);
                }"
4,1241,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.JDTCompiler$2,,acceptResult,,className += new String(compoundName[j]);,,424,424,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/JDTCompiler.java#L424,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/JDTCompiler.java,,close,"@Override
                public void acceptResult(CompilationResult result) {
                    try {
                        if (result.hasProblems()) {
                            IProblem[] problems = result.getProblems();
                            for (int i = 0; i < problems.length; i++) {
                                IProblem problem = problems[i];
                                if (problem.isError()) {
                                    String name =
                                        new String(problems[i].getOriginatingFileName());
                                    try {
                                        problemList.add(ErrorDispatcher.createJavacError
                                                (name, pageNodes, new StringBuilder(problem.getMessage()),
                                                        problem.getSourceLineNumber(), ctxt));
                                    } catch (JasperException e) {
                                        log.error(""Error visiting node"", e);
                                    }
                                }
                            }
                        }
                        if (problemList.isEmpty()) {
                            ClassFile[] classFiles = result.getClassFiles();
                            for (int i = 0; i < classFiles.length; i++) {
                                ClassFile classFile = classFiles[i];
                                char[][] compoundName =
                                    classFile.getCompoundName();
                                String className = """";
                                String sep = """";
                                for (int j = 0;
                                     j < compoundName.length; j++) {
                                    className += sep;
                                    className += new String(compoundName[j]);
                                    sep = ""."";
                                }
                                byte[] bytes = classFile.getBytes();
                                String outFile = outputDir + ""/"" +
                                    className.replace('.', '/') + "".class"";
                                FileOutputStream fout =
                                    new FileOutputStream(outFile);
                                BufferedOutputStream bos =
                                    new BufferedOutputStream(fout);
                                bos.write(bytes);
                                bos.close();
                            }
                        }
                    } catch (IOException exc) {
                        log.error(""Compilation error"", exc);
                    }
                }"
5,1297,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.catalina.startup,org.apache.catalina.startup.RealmRuleSet,,addRuleInstances,,pattern,pattern,97,97,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/startup/RealmRuleSet.java#L97,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/startup/RealmRuleSet.java,,close,"@Override
    public void addRuleInstances(Digester digester) {

        String pattern = prefix;

        for (int i = 0; i < MAX_NESTED_REALM_LEVELS; i++) {

            if (i > 0) {
                pattern += ""/"";
            }
            pattern += ""Realm"";

            digester.addObjectCreate(pattern,
                                     null, // MUST be specified in the element,
                                     ""className"");
            digester.addSetProperties(pattern);
            if (i == 0) {
                digester.addSetNext(pattern,
                                    ""setRealm"",
                                    ""org.apache.catalina.Realm"");
            } else {
                digester.addSetNext(pattern,
                                    ""addRealm"",
                                    ""org.apache.catalina.Realm"");
            }
        }
    }"
6,1341,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.catalina.servlets,org.apache.catalina.servlets.CGIServlet$CGIEnvironment,,findCGI,,"cginame = cginame + ""/"" + nextElement;",,891,891,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/servlets/CGIServlet.java#L891,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/servlets/CGIServlet.java,,close,"protected String[] findCGI(String pathInfo, String webAppRootDir,
                                   String contextPath, String servletPath,
                                   String cgiPathPrefix) {
            String path = null;
            String name = null;
            String scriptname = null;
            String cginame = """";

            if ((webAppRootDir != null)
                && (webAppRootDir.lastIndexOf(File.separator) ==
                    (webAppRootDir.length() - 1))) {
                    //strip the trailing ""/"" from the webAppRootDir
                    webAppRootDir =
                    webAppRootDir.substring(0, (webAppRootDir.length() - 1));
            }

            if (cgiPathPrefix != null) {
                webAppRootDir = webAppRootDir + File.separator
                    + cgiPathPrefix;
            }

            if (debug >= 2) {
                log(""findCGI: path="" + pathInfo + "", "" + webAppRootDir);
            }

            File currentLocation = new File(webAppRootDir);
            StringTokenizer dirWalker =
            new StringTokenizer(pathInfo, ""/"");
            if (debug >= 3) {
                log(""findCGI: currentLoc="" + currentLocation);
            }
            while (!currentLocation.isFile() && dirWalker.hasMoreElements()) {
                if (debug >= 3) {
                    log(""findCGI: currentLoc="" + currentLocation);
                }
                String nextElement = (String) dirWalker.nextElement();
                currentLocation = new File(currentLocation, nextElement);
                cginame = cginame + ""/"" + nextElement;
            }
            if (!currentLocation.isFile()) {
                return new String[] { null, null, null, null };
            }

            if (debug >= 2) {
                log(""findCGI: FOUND cgi at "" + currentLocation);
            }
            path = currentLocation.getAbsolutePath();
            name = currentLocation.getName();

            if (""."".equals(contextPath)) {
                scriptname = servletPath;
            } else {
                scriptname = contextPath + servletPath;
            }
            if (!servletPath.equals(cginame)) {
                scriptname = scriptname + cginame;
            }

            if (debug >= 1) {
                log(""findCGI calc: name="" + name + "", path="" + path
                    + "", scriptname="" + scriptname + "", cginame="" + cginame);
            }
            return new String[] { path, scriptname, cginame, name };
        }"
7,1508,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.JDTCompiler$1,,isPackage,,result += str;,,271,271,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/JDTCompiler.java#L271,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/JDTCompiler.java,,close,"private boolean isPackage(String result) {
                    if (result.equals(targetClassName)) {
                        return false;
                    }
                    String resourceName = result.replace('.', '/') + "".class"";
                    InputStream is =
                        classLoader.getResourceAsStream(resourceName);
                    return is == null;
                }"
8,1537,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,C,last,,PERFORMANCE,org.apache.jasper.runtime,org.apache.jasper.runtime.JspRuntimeLibrary,,escapeQueryString,,escString,"escString,nextChar",559,559,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/runtime/JspRuntimeLibrary.java#L559,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/runtime/JspRuntimeLibrary.java,,close,"public static String escapeQueryString(String unescString) {
    if ( unescString == null )
        return null;

    String escString    = """";
    String shellSpChars = ""&;`'\""|*?~<>^()[]{}$\\\n"";

    for(int index=0; index<unescString.length(); index++) {
        char nextChar = unescString.charAt(index);

        if( shellSpChars.indexOf(nextChar) != -1 )
        escString += ""\\"";

        escString += nextChar;
    }
    return escString;
    }"
9,1326,tomcat,SBSC_USE_STRINGBUFFER_CONCATENATION,B,last,,PERFORMANCE,org.apache.tomcat.util.http.fileupload,org.apache.tomcat.util.http.fileupload.FileUploadBase,,getParsedHeaders,,end,"end,header,headerPart,nonWs,substring",498,498,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java#L498,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/http/fileupload/FileUploadBase.java,,close,"protected FileItemHeaders getParsedHeaders(String headerPart) {
        final int len = headerPart.length();
        FileItemHeadersImpl headers = newFileItemHeaders();
        int start = 0;
        for (;;) {
            int end = parseEndOfLine(headerPart, start);
            if (start == end) {
                break;
            }
            String header = headerPart.substring(start, end);
            start = end + 2;
            while (start < len) {
                int nonWs = start;
                while (nonWs < len) {
                    char c = headerPart.charAt(nonWs);
                    if (c != ' '  &&  c != '\t') {
                        break;
                    }
                    ++nonWs;
                }
                if (nonWs == start) {
                    break;
                }
                // Continuation line found
                end = parseEndOfLine(headerPart, nonWs);
                header += "" "" + headerPart.substring(nonWs, end);
                start = end + 2;
            }
            parseHeaderLine(headers, header);
        }
        return headers;
    }"
10,2956,lucene-solr,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.lucene.util,org.apache.lucene.util.LuceneTestCase,stores,checkResourcesAfterClass,,StackTraceElement elements[] = stores.get(d);,,433,433,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test-framework/java/org/apache/lucene/util/LuceneTestCase.java#L433,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test-framework/java/org/apache/lucene/util/LuceneTestCase.java,,unknown,"private static void checkResourcesAfterClass() {
    for (MockDirectoryWrapper d : stores.keySet()) {
      if (d.isOpen()) {
        StackTraceElement elements[] = stores.get(d);
        // Look for the first class that is not LuceneTestCase that requested
        // a Directory. The first two items are of Thread's, so skipping over
        // them.
        StackTraceElement element = null;
        for (int i = 2; i < elements.length; i++) {
          StackTraceElement ste = elements[i];
          if (ste.getClassName().indexOf(""LuceneTestCase"") == -1) {
            element = ste;
            break;
          }
        }
        fail(""directory of test was not closed, opened from: "" + element);
      }
    }
  }"
11,2984,lucene-solr,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.lucene.benchmark.byTask.utils,org.apache.lucene.benchmark.byTask.utils.Config,colForValByRound,getColsValuesForValsByRound,,colForValByRound,"colForValByRound,name,get",408,408,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java#L408,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java,,unknown,"public String getColsValuesForValsByRound(int roundNum) {
    if (colForValByRound.size() == 0) {
      return """";
    }
    StringBuilder sb = new StringBuilder();
    for (final String name : colForValByRound.keySet()) {
      String colName = colForValByRound.get(name);
      String template = "" "" + colName;
      if (roundNum < 0) {
        // just append blanks
        sb.append(Format.formatPaddLeft(""-"", template));
      } else {
        // append actual values, for that round
        Object a = valByRound.get(name);
        if (a instanceof int[]) {
          int ai[] = (int[]) a;
          int n = roundNum % ai.length;
          sb.append(Format.format(ai[n], template));
        } else if (a instanceof double[]) {
          double ad[] = (double[]) a;
          int n = roundNum % ad.length;
          sb.append(Format.format(2, ad[n], template));
        } else if (a instanceof String[]) {
          String ad[] = (String[]) a;
          int n = roundNum % ad.length;
          sb.append(ad[n]);
        } else {
          boolean ab[] = (boolean[]) a;
          int n = roundNum % ab.length;
          sb.append(Format.formatPaddLeft("""" + ab[n], template));
        }
      }
    }
    return sb.toString();
  }"
12,2654,lucene-solr,WMI_WRONG_MAP_ITERATOR,B,last,,PERFORMANCE,org.apache.solr.update,org.apache.solr.update.SolrCmdDistributor,deletes,flushDeletes,,deletes,"deletes,node,get",246,246,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.java#L246,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.java,,unknown,"boolean flushDeletes(int limit) {
    // check for pending deletes
 
    Set<Node> removeNodes = new HashSet<Node>();
    Set<Node> nodes = deletes.keySet();
    for (Node node : nodes) {
      List<DeleteRequest> dlist = deletes.get(node);
      if (dlist == null || dlist.size() < limit) continue;
      UpdateRequestExt ureq = new UpdateRequestExt();
      
      ModifiableSolrParams combinedParams = new ModifiableSolrParams();
      
      for (DeleteRequest dReq : dlist) {
        DeleteUpdateCommand cmd = dReq.cmd;
        combinedParams.add(dReq.params);
        if (cmd.isDeleteById()) {
          ureq.deleteById(cmd.getId(), cmd.getVersion());
        } else {
          ureq.deleteByQuery(cmd.query);
        }
        
        if (ureq.getParams() == null) ureq
            .setParams(new ModifiableSolrParams());
        ureq.getParams().add(combinedParams);
      }
      
      removeNodes.add(node);
      submit(ureq, node);
    }
    
    for (Node node : removeNodes) {
      deletes.remove(node);
    }
    
    return true;
  }"
13,10360,commons-lang,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.commons.lang3,org.apache.commons.lang3.ClassUtils,primitiveWrapperMap,<clinit>,,final Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);,,98,98,close,https://github.com/apache/commons-lang/tree/c4ecd75ecd8b78c66cc51b49dd32989a3f1cde2e//src/main/java/org/apache/commons/lang3/ClassUtils.java#L98,https://github.com/apache/commons-lang/tree/551101299da7f75ea5478db1a6bc194963e0ac34//src/main/java/org/apache/commons/lang3/ClassUtils.java,,close,
14,9701,ant,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.unix,org.apache.tools.ant.taskdefs.optional.unix.Symlink,,record,,byDir,"byDir,dir,get",269,269,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java#L269,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/unix/Symlink.java,,close,"public void record() throws BuildException {
        try {
            if (fileSets.isEmpty()) {
                handleError(""Fileset identifying links to record required"");
                return;
            }
            if (linkFileName == null) {
                handleError(""Name of file to record links in required"");
                return;
            }
            // create a hashtable to group them by parent directory:
            Hashtable byDir = new Hashtable();

            // get an Iterator of file objects representing links (canonical):
            for (Iterator litr = findLinks(fileSets).iterator();
                litr.hasNext();) {
                File thisLink = (File) litr.next();
                File parent = thisLink.getParentFile();
                Vector v = (Vector) byDir.get(parent);
                if (v == null) {
                    v = new Vector();
                    byDir.put(parent, v);
                }
                v.addElement(thisLink);
            }
            // write a Properties file in each directory:
            for (Iterator dirs = byDir.keySet().iterator(); dirs.hasNext();) {
                File dir = (File) dirs.next();
                Vector linksInDir = (Vector) byDir.get(dir);
                Properties linksToStore = new Properties();

                // fill up a Properties object with link and resource names:
                for (Iterator dlnk = linksInDir.iterator(); dlnk.hasNext();) {
                    File lnk = (File) dlnk.next();
                    try {
                        linksToStore.put(lnk.getName(), lnk.getCanonicalPath());
                    } catch (IOException ioe) {
                        handleError(""Couldn't get canonical name of parent link"");
                    }
                }
                writePropertyFile(linksToStore, dir);
            }
        } finally {
            setDefaults();
        }
    }"
15,9762,ant,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.extension,org.apache.tools.ant.taskdefs.optional.extension.Extension,,getListed,,entries,"entries,key,get",581,581,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java#L581,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java,,close,"private static Extension[] getListed(final Manifest manifest,
                                          final Attributes.Name listKey) {
        final ArrayList results = new ArrayList();
        final Attributes mainAttributes = manifest.getMainAttributes();

        if (null != mainAttributes) {
            getExtension(mainAttributes, results, listKey);
        }

        final Map entries = manifest.getEntries();
        final Iterator keys = entries.keySet().iterator();
        while (keys.hasNext()) {
            final String key = (String) keys.next();
            final Attributes attributes = (Attributes) entries.get(key);
            getExtension(attributes, results, listKey);
        }

        return (Extension[]) results.toArray(new Extension[results.size()]);
    }"
16,9788,ant,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.extension,org.apache.tools.ant.taskdefs.optional.extension.Extension,,getAvailable,,entries,"entries,key,get",207,207,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java#L207,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/extension/Extension.java,,close,"public static Extension[] getAvailable(final Manifest manifest) {
        if (null == manifest) {
            return new Extension[ 0 ];
        }

        final ArrayList results = new ArrayList();

        final Attributes mainAttributes = manifest.getMainAttributes();
        if (null != mainAttributes) {
            final Extension extension = getExtension("""", mainAttributes);
            if (null != extension) {
                results.add(extension);
            }
        }

        final Map entries = manifest.getEntries();
        final Iterator keys = entries.keySet().iterator();
        while (keys.hasNext()) {
            final String key = (String) keys.next();
            final Attributes attributes = (Attributes) entries.get(key);
            final Extension extension = getExtension("""", attributes);
            if (null != extension) {
                results.add(extension);
            }
        }

        return (Extension[]) results.toArray(new Extension[results.size()]);
    }"
17,9873,ant,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.tools.ant.util,org.apache.tools.ant.util.ScriptRunnerBase,,addBeans,,dictionary,"dictionary,key,get",74,74,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/util/ScriptRunnerBase.java#L74,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/util/ScriptRunnerBase.java,,close,"public void addBeans(Map dictionary) {
        for (Iterator i = dictionary.keySet().iterator(); i.hasNext();) {
            String key = (String) i.next();
            try {
                Object val = dictionary.get(key);
                addBean(key, val);
            } catch (BuildException ex) {
                // The key is in the dictionary but cannot be retrieved
                // This is usually due references that refer to tasks
                // that have not been taskdefed in the current run.
                // Ignore
            }
        }
    }"
18,9920,ant,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Property,,addProperties,,addProperty,"addProperty,k,m,propertyName,get",678,678,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Property.java#L678,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Property.java,,close,"protected void addProperties(Properties props) {
        HashMap m = new HashMap(props);
        resolveAllProperties(m);
        for (Iterator it = m.keySet().iterator(); it.hasNext();) {
            Object k = it.next();
            if (k instanceof String) {
                String propertyName = (String) k;
                if (prefix != null) {
                    propertyName = prefix + propertyName;
                }
                addProperty(propertyName, m.get(k));
            }
        }
    }"
19,9926,ant,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.extension,org.apache.tools.ant.taskdefs.optional.extension.Specification,,getSpecifications,,entries,"entries,key,get",179,179,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/extension/Specification.java#L179,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/extension/Specification.java,,close,"public static Specification[] getSpecifications(final Manifest manifest)
        throws ParseException {
        if (null == manifest) {
            return new Specification[ 0 ];
        }

        final ArrayList results = new ArrayList();

        final Map entries = manifest.getEntries();
        final Iterator keys = entries.keySet().iterator();
        while (keys.hasNext()) {
            final String key = (String) keys.next();
            final Attributes attributes = (Attributes) entries.get(key);
            final Specification specification
                = getSpecification(key, attributes);
            if (null != specification) {
                results.add(specification);
            }
        }

        final ArrayList trimmedResults = removeDuplicates(results);
        return (Specification[]) trimmedResults.toArray(new Specification[trimmedResults.size()]);
    }"
20,9770,ant,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Copy,,doResourceOperations,,fromResource,"fromResource,map,get",965,965,close,https://github.com/apache/ant/tree/02d9f46c2941a8ae665322e49d4d12ae7343ab3b//src/main/org/apache/tools/ant/taskdefs/Copy.java#L965,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Copy.java,,close,"protected void doResourceOperations(Map map) {
        if (map.size() > 0) {
            log(""Copying "" + map.size()
                + "" resource"" + (map.size() == 1 ? """" : ""s"")
                + "" to "" + destDir.getAbsolutePath());

            Iterator iter = map.keySet().iterator();
            while (iter.hasNext()) {
                Resource fromResource = (Resource) iter.next();
                String[] toFiles = (String[]) map.get(fromResource);

                for (int i = 0; i < toFiles.length; i++) {
                    String toFile = toFiles[i];

                    try {
                        log(""Copying "" + fromResource + "" to "" + toFile,
                            verbosity);

                        FilterSetCollection executionFilters =
                            new FilterSetCollection();
                        if (filtering) {
                            executionFilters
                                .addFilterSet(getProject().getGlobalFilterSet());
                        }
                        for (Enumeration filterEnum = filterSets.elements();
                            filterEnum.hasMoreElements();) {
                            executionFilters
                                .addFilterSet((FilterSet) filterEnum.nextElement());
                        }
                        ResourceUtils.copyResource(fromResource,
                                                   new FileResource(destDir,
                                                                    toFile),
                                                   executionFilters,
                                                   filterChains,
                                                   forceOverwrite,
                                                   preserveLastModified,
                                                   /* append: */ false,
                                                   inputEncoding,
                                                   outputEncoding,
                                                   getProject(),
                                                   getForce());
                    } catch (IOException ioe) {
                        String msg = ""Failed to copy "" + fromResource
                            + "" to "" + toFile
                            + "" due to "" + getDueTo(ioe);
                        File targetFile = new File(toFile);
                        if (targetFile.exists() && !targetFile.delete()) {
                            msg += "" and I couldn't delete the corrupt "" + toFile;
                        }
                        if (failonerror) {
                            throw new BuildException(msg, ioe, getLocation());
                        }
                        log(msg, Project.MSG_ERR);
                    }
                }
            }
        }
    }"
21,9988,maven,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.maven.toolchain,org.apache.maven.toolchain.DefaultToolchain,,matchesRequirements,,key,"key,matcher,requirements,get,matches",91,91,close,https://github.com/apache/maven/tree/879d07b1d747653bc3c0e381ae763a49e6d885d0//maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchain.java#L91,https://github.com/apache/maven/tree/a7dddcb87626fec256f1b8ccbe957f94cdf401e4//maven-core/src/main/java/org/apache/maven/toolchain/DefaultToolchain.java,,close,"public boolean matchesRequirements( Map requirements )
    {
        Iterator it = requirements.keySet().iterator();
        while ( it.hasNext() )
        {
            String key = (String) it.next();

            RequirementMatcher matcher = provides.get( key );

            if ( matcher == null )
            {
                getLog().debug( ""Toolchain "" + this + "" is missing required property: "" + key );
                return false;
            }
            if ( !matcher.matches( (String) requirements.get( key ) ) )
            {
                getLog().debug( ""Toolchain "" + this + "" doesn't match required property: "" + key );
                return false;
            }
        }
        return true;
    }"
22,1390,tomcat,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.TagFileProcessor$TagFileDirectiveVisitor,nameFromTable,postCheck,,NameEntry nameFromEntry = nameFromTable.get(nameFrom);,,449,449,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/TagFileProcessor.java#L449,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/TagFileProcessor.java,,close,"void postCheck() throws JasperException {
            // Check that var.name-from-attributes has valid values.
            Iterator<String> iter = nameFromTable.keySet().iterator();
            while (iter.hasNext()) {
                String nameFrom = iter.next();
                NameEntry nameEntry = nameTable.get(nameFrom);
                NameEntry nameFromEntry = nameFromTable.get(nameFrom);
                Node nameFromNode = nameFromEntry.getNode();
                if (nameEntry == null) {
                    err.jspError(nameFromNode,
                            ""jsp.error.tagfile.nameFrom.noAttribute"", nameFrom);
                } else {
                    Node node = nameEntry.getNode();
                    TagAttributeInfo tagAttr = nameEntry.getTagAttributeInfo();
                    if (!""java.lang.String"".equals(tagAttr.getTypeName())
                            || !tagAttr.isRequired()
                            || tagAttr.canBeRequestTime()) {
                        err.jspError(nameFromNode,
                                ""jsp.error.tagfile.nameFrom.badAttribute"",
                                nameFrom, Integer.toString(node.getStart()
                                        .getLineNumber()));
                    }
                }
            }
        }"
23,1518,tomcat,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.catalina.realm,org.apache.catalina.realm.JNDIRealm,,getRoles,,containerLog,"containerLog,groupMap,key,key,get,trace",1753,1753,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/realm/JNDIRealm.java#L1753,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/realm/JNDIRealm.java,,close,"protected List<String> getRoles(DirContext context, User user)
        throws NamingException {

        if (user == null)
            return (null);

        String dn = user.getDN();
        String username = user.getUserName();
        String userRoleId = user.getUserRoleId();

        if (dn == null || username == null)
            return (null);

        if (containerLog.isTraceEnabled())
            containerLog.trace(""  getRoles("" + dn + "")"");

        // Start with roles retrieved from the user entry
        List<String> list = new ArrayList<>();
        List<String> userRoles = user.getRoles();
        if (userRoles != null) {
            list.addAll(userRoles);
        }
        if (commonRole != null)
            list.add(commonRole);

        if (containerLog.isTraceEnabled()) {
            containerLog.trace(""  Found "" + list.size() + "" user internal roles"");
            for (int i=0; i<list.size(); i++)
                containerLog.trace(  ""  Found user internal role "" + list.get(i));
        }

        // Are we configured to do role searches?
        if ((roleFormat == null) || (roleName == null))
            return (list);

        // Set up parameters for an appropriate search
        String filter = roleFormat.format(new String[] { doRFC2254Encoding(dn), username, userRoleId });
        SearchControls controls = new SearchControls();
        if (roleSubtree)
            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
        else
            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);
        controls.setReturningAttributes(new String[] {roleName});

        String base = null;
        if (roleBaseFormat != null) {
            NameParser np = context.getNameParser("""");
            Name name = np.parse(dn);
            String nameParts[] = new String[name.size()];
            for (int i = 0; i < name.size(); i++) {
                nameParts[i] = name.get(i);
            }
            base = roleBaseFormat.format(nameParts);
        }

        // Perform the configured search and process the results
        NamingEnumeration<SearchResult> results = null;
        try {
            if (roleSearchAsUser) {
                userCredentialsAdd(context, dn, user.getPassword());
            }
            results = context.search(base, filter, controls);
        } finally {
            if (roleSearchAsUser) {
                userCredentialsRemove(context);
            }
        }

        if (results == null)
            return (list);  // Should never happen, but just in case ...

        HashMap<String, String> groupMap = new HashMap<>();
        try {
            while (results.hasMore()) {
                SearchResult result = results.next();
                Attributes attrs = result.getAttributes();
                if (attrs == null)
                    continue;
                String dname = getDistinguishedName(context, roleBase, result);
                String name = getAttributeValue(roleName, attrs);
                if (name != null && dname != null) {
                    groupMap.put(dname, name);
                }
            }
        } catch (PartialResultException ex) {
            if (!adCompat)
                throw ex;
        }

        Set<String> keys = groupMap.keySet();
        if (containerLog.isTraceEnabled()) {
            containerLog.trace(""  Found "" + keys.size() + "" direct roles"");
            for (String key: keys) {
                containerLog.trace(  ""  Found direct role "" + key + "" -> "" + groupMap.get(key));
            }
        }

        // if nested group search is enabled, perform searches for nested groups until no new group is found
        if (getRoleNested()) {

            // The following efficient algorithm is known as memberOf Algorithm, as described in ""Practices in
            // Directory Groups"". It avoids group slurping and handles cyclic group memberships as well.
            // See http://middleware.internet2.edu/dir/ for details

            Map<String, String> newGroups = new HashMap<>(groupMap);
            while (!newGroups.isEmpty()) {
                Map<String, String> newThisRound = new HashMap<>(); // Stores the groups we find in this iteration

                for (Entry<String, String> group : newGroups.entrySet()) {
                    filter = roleFormat.format(new String[] { group.getKey(), group.getValue(), group.getValue() });

                    if (containerLog.isTraceEnabled()) {
                        containerLog.trace(""Perform a nested group search with base ""+ roleBase + "" and filter "" + filter);
                    }

                    results = context.search(roleBase, filter, controls);

                    try {
                        while (results.hasMore()) {
                            SearchResult result = results.next();
                            Attributes attrs = result.getAttributes();
                            if (attrs == null)
                                continue;
                            String dname = getDistinguishedName(context, roleBase, result);
                            String name = getAttributeValue(roleName, attrs);
                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {
                                groupMap.put(dname, name);
                                newThisRound.put(dname, name);

                                if (containerLog.isTraceEnabled()) {
                                    containerLog.trace(""  Found nested role "" + dname + "" -> "" + name);
                                }

                            }
                         }
                    } catch (PartialResultException ex) {
                        if (!adCompat)
                            throw ex;
                    }
                }

                newGroups = newThisRound;
            }
        }

        list.addAll(groupMap.values());
        return list;
    }"
24,1632,tomcat,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.catalina.core,org.apache.catalina.core.ApplicationHttpRequest,parameters,mergeParameters,,key,"key,key,parameters,queryParameters,get,put",885,885,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/core/ApplicationHttpRequest.java#L885,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/core/ApplicationHttpRequest.java,,close,"private void mergeParameters() {

        if ((queryParamString == null) || (queryParamString.length() < 1))
            return;

        HashMap<String, String[]> queryParameters = new HashMap<>();
        String encoding = getCharacterEncoding();
        if (encoding == null)
            encoding = ""ISO-8859-1"";
        RequestUtil.parseParameters(queryParameters, queryParamString,
                encoding);
        Iterator<String> keys = parameters.keySet().iterator();
        while (keys.hasNext()) {
            String key = keys.next();
            Object value = queryParameters.get(key);
            if (value == null) {
                queryParameters.put(key, parameters.get(key));
                continue;
            }
            queryParameters.put
                (key, mergeValues(value, parameters.get(key)));
        }
        parameters = queryParameters;

    }"
25,1656,tomcat,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.catalina.core,org.apache.catalina.core.StandardContext,filterConfigs,filterStop,,ApplicationFilterConfig filterConfig = filterConfigs.get(name);,,4571,4571,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/core/StandardContext.java#L4571,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/core/StandardContext.java,,close,"public boolean filterStop() {

        if (getLogger().isDebugEnabled())
            getLogger().debug(""Stopping filters"");

        // Release all Filter and FilterConfig instances
        synchronized (filterConfigs) {
            Iterator<String> names = filterConfigs.keySet().iterator();
            while (names.hasNext()) {
                String name = names.next();
                if (getLogger().isDebugEnabled())
                    getLogger().debug("" Stopping filter '"" + name + ""'"");
                ApplicationFilterConfig filterConfig = filterConfigs.get(name);
                filterConfig.release();
            }
            filterConfigs.clear();
        }
        return (true);

    }"
26,1641,tomcat,WMI_WRONG_MAP_ITERATOR,B,last,,PERFORMANCE,org.apache.catalina.core,org.apache.catalina.core.StandardContext,filterDefs,filterStart,,filterConfig =,,4532,4532,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/catalina/core/StandardContext.java#L4532,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/core/StandardContext.java,,close,"public boolean filterStart() {

        if (getLogger().isDebugEnabled())
            getLogger().debug(""Starting filters"");
        // Instantiate and record a FilterConfig for each defined filter
        boolean ok = true;
        synchronized (filterConfigs) {
            filterConfigs.clear();
            Iterator<String> names = filterDefs.keySet().iterator();
            while (names.hasNext()) {
                String name = names.next();
                if (getLogger().isDebugEnabled())
                    getLogger().debug("" Starting filter '"" + name + ""'"");
                ApplicationFilterConfig filterConfig = null;
                try {
                    filterConfig =
                        new ApplicationFilterConfig(this, filterDefs.get(name));
                    filterConfigs.put(name, filterConfig);
                } catch (Throwable t) {
                    t = ExceptionUtils.unwrapInvocationTargetException(t);
                    ExceptionUtils.handleThrowable(t);
                    getLogger().error
                        (sm.getString(""standardContext.filterStart"", name), t);
                    ok = false;
                }
            }
        }

        return (ok);

    }"
27,9602,jmeter,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.jmeter.protocol.smtp.sampler.gui,org.apache.jmeter.protocol.smtp.sampler.gui.SmtpPanel,headerFields,getHeaderFields,,headerFields,"headerFields,headerName,get,getText",459,459,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/protocol/mail/org/apache/jmeter/protocol/smtp/sampler/gui/SmtpPanel.java#L459,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/protocol/mail/org/apache/jmeter/protocol/smtp/sampler/gui/SmtpPanel.java,,open,"public CollectionProperty getHeaderFields() {
        CollectionProperty result = new CollectionProperty();
        result.setName(SmtpSampler.HEADER_FIELDS);
        for (Iterator<JTextField> iterator = headerFields.keySet().iterator(); iterator.hasNext();) {
            JTextField headerName = iterator.next();
            String name = headerName.getText();
            String value = headerFields.get(headerName).getText();
            Argument argument = new Argument(name, value);
            result.addItem(argument);
        }
        return result;
    }"
28,9657,jmeter,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.jmeter.protocol.smtp.sampler.gui,org.apache.jmeter.protocol.smtp.sampler.gui.SmtpPanel,removeButtons,clearHeaderFields,,removeButton,"removeButton,removeButtons,get",1020,1020,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/protocol/mail/org/apache/jmeter/protocol/smtp/sampler/gui/SmtpPanel.java#L1020,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/protocol/mail/org/apache/jmeter/protocol/smtp/sampler/gui/SmtpPanel.java,,open,"private void clearHeaderFields() {
        headerFieldName.setVisible(false);
           headerFieldValue.setVisible(false);

        for (Iterator<JButton> iterator = removeButtons.keySet().iterator(); iterator.hasNext();) {
            JButton removeButton = iterator.next();
               JTextField headerName = removeButtons.get(removeButton);
            JTextField headerValue = headerFields.get(headerName);

            headerFieldsPanel.remove(headerName);
            if (headerValue != null){ // Can be null (not sure why)
                headerFieldsPanel.remove(headerValue);
            }
            headerFieldsPanel.remove(removeButton);
            headerFields.remove(headerName);
            iterator.remove();
        }
    }"
29,9663,jmeter,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.jmeter.protocol.http.proxy,org.apache.jmeter.protocol.http.proxy.HttpRequestHdr,headers,createHeaderManager,,headers,"headers,key,manager,add,get",237,237,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/protocol/http/org/apache/jmeter/protocol/http/proxy/HttpRequestHdr.java#L237,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/protocol/http/org/apache/jmeter/protocol/http/proxy/HttpRequestHdr.java,,close,"private HeaderManager createHeaderManager() {
        HeaderManager manager = new HeaderManager();
        for (String key : headers.keySet()) {
            if (!key.equals(PROXY_CONNECTION)
             && !key.equals(CONTENT_LENGTH)
             && !key.equalsIgnoreCase(HTTPConstants.HEADER_CONNECTION)) {
                manager.add(headers.get(key));
            }
        }
        manager.setName(JMeterUtils.getResString(""header_manager_title"")); // $NON-NLS-1$
        manager.setProperty(TestElement.TEST_CLASS, HeaderManager.class.getName());
        manager.setProperty(TestElement.GUI_CLASS, HeaderPanel.class.getName());
        return manager;
    }"
30,9583,jmeter,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.jorphan.math,org.apache.jorphan.math.StatCalculator,valuesMap,getDistribution,,dis,"dis,nx,valuesMap,get",168,168,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/jorphan/org/apache/jorphan/math/StatCalculator.java#L168,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/jorphan/org/apache/jorphan/math/StatCalculator.java,,close,"public synchronized Map<Number, Number[]> getDistribution() {
        HashMap<Number, Number[]> items = new HashMap <Number, Number[]> ();
        Number[] dis;

        for (T nx : valuesMap.keySet()) {
            dis = new Number[2];
            dis[0] = nx;
            dis[1] = valuesMap.get(nx);
            items.put(nx, dis);
        }
        return items;
    }"
31,8519,cassandra,WMI_WRONG_MAP_ITERATOR,C,last,,PERFORMANCE,org.apache.cassandra.service,org.apache.cassandra.service.CassandraDaemon,,setup,,ColumnFamilyStore,"ColumnFamilyStore,kscf,kscf,kscf,unfinishedCompactions,get,left,removeUnfinishedCompactionLeftovers,right",253,253,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/java/org/apache/cassandra/service/CassandraDaemon.java#L253,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/service/CassandraDaemon.java,,unknown,"protected void setup()
    {
        // log warnings for different kinds of sub-optimal JVMs.  tldr use 64-bit Oracle >= 1.6u32
        if (!System.getProperty(""os.arch"").contains(""64""))
            logger.info(""32bit JVM detected.  It is recommended to run Cassandra on a 64bit JVM for better performance."");
        String javaVersion = System.getProperty(""java.version"");
        String javaVmName = System.getProperty(""java.vm.name"");
        logger.info(""JVM vendor/version: {}/{}"", javaVmName, javaVersion);
        if (javaVmName.contains(""OpenJDK""))
        {
            // There is essentially no QA done on OpenJDK builds, and
            // clusters running OpenJDK have seen many heap and load issues.
            logger.warn(""OpenJDK is not recommended. Please upgrade to the newest Oracle Java release"");
        }
        else if (!javaVmName.contains(""HotSpot""))
        {
            logger.warn(""Non-Oracle JVM detected.  Some features, such as immediate unmap of compacted SSTables, may not work as intended"");
        }
     /*   else
        {
            String[] java_version = javaVersion.split(""_"");
            String java_major = java_version[0];
            int java_minor;
            try
            {
                java_minor = (java_version.length > 1) ? Integer.parseInt(java_version[1]) : 0;
            }
            catch (NumberFormatException e)
            {
                // have only seen this with java7 so far but no doubt there are other ways to break this
                logger.info(""Unable to parse java version {}"", Arrays.toString(java_version));
                java_minor = 32;
            }
        }
     */
        logger.info(""Heap size: {}/{}"", Runtime.getRuntime().totalMemory(), Runtime.getRuntime().maxMemory());
        logger.info(""Classpath: {}"", System.getProperty(""java.class.path""));
        CLibrary.tryMlockall();

        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler()
        {
            public void uncaughtException(Thread t, Throwable e)
            {
                StorageMetrics.exceptions.inc();
                logger.error(""Exception in thread "" + t, e);
                Tracing.trace(""Exception in thread "" + t, e);
                for (Throwable e2 = e; e2 != null; e2 = e2.getCause())
                {
                    // some code, like FileChannel.map, will wrap an OutOfMemoryError in another exception
                    if (e2 instanceof OutOfMemoryError)
                        exitThread.start();

                    if (e2 instanceof FSError)
                    {
                        if (e2 != e) // make sure FSError gets logged exactly once.
                            logger.error(""Exception in thread "" + t, e2);
                        FileUtils.handleFSError((FSError) e2);
                    }
                }
            }
        });

        // check all directories(data, commitlog, saved cache) for existence and permission
        Iterable<String> dirs = Iterables.concat(Arrays.asList(DatabaseDescriptor.getAllDataFileLocations()),
                                                 Arrays.asList(DatabaseDescriptor.getCommitLogLocation(),
                                                               DatabaseDescriptor.getSavedCachesLocation()));
        for (String dataDir : dirs)
        {
            logger.debug(""Checking directory {}"", dataDir);
            File dir = new File(dataDir);
            if (dir.exists())
                assert dir.isDirectory() && dir.canRead() && dir.canWrite() && dir.canExecute()
                    : String.format(""Directory %s is not accessible."", dataDir);
        }

        if (CacheService.instance == null) // should never happen
            throw new RuntimeException(""Failed to initialize Cache Service."");

        // check the system keyspace to keep user from shooting self in foot by changing partitioner, cluster name, etc.
        // we do a one-off scrub of the system keyspace first; we can't load the list of the rest of the keyspaces,
        // until system keyspace is opened.
        for (CFMetaData cfm : Schema.instance.getKeyspaceMetaData(Keyspace.SYSTEM_KS).values())
            ColumnFamilyStore.scrubDataDirectories(Keyspace.SYSTEM_KS, cfm.cfName);
        try
        {
            SystemKeyspace.checkHealth();
        }
        catch (ConfigurationException e)
        {
            logger.error(""Fatal exception during initialization"", e);
            System.exit(100);
        }

        // load keyspace descriptions.
        DatabaseDescriptor.loadSchemas();

        try
        {
            LeveledManifest.maybeMigrateManifests();
        }
        catch(IOException e)
        {
            logger.error(""Could not migrate old leveled manifest. Move away the .json file in the data directory"", e);
            System.exit(100);
        }

        // clean up compaction leftovers
        Map<Pair<String, String>, Map<Integer, UUID>> unfinishedCompactions = SystemKeyspace.getUnfinishedCompactions();
        for (Pair<String, String> kscf : unfinishedCompactions.keySet())
            ColumnFamilyStore.removeUnfinishedCompactionLeftovers(kscf.left, kscf.right, unfinishedCompactions.get(kscf));
        SystemKeyspace.discardCompactionsInProgress();

        // clean up debris in the rest of the keyspaces
        for (String keyspaceName : Schema.instance.getKeyspaces())
        {
            for (CFMetaData cfm : Schema.instance.getKeyspaceMetaData(keyspaceName).values())
                ColumnFamilyStore.scrubDataDirectories(keyspaceName, cfm.cfName);
        }

        // initialize keyspaces
        for (String keyspaceName : Schema.instance.getKeyspaces())
        {
            if (logger.isDebugEnabled())
                logger.debug(""opening keyspace "" + keyspaceName);
            // disable auto compaction until commit log replay ends
            for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
            {
                for (ColumnFamilyStore store : cfs.concatWithIndexes())
                {
                    store.disableAutoCompaction();
                }
            }
        }

        if (CacheService.instance.keyCache.size() > 0)
            logger.info(""completed pre-loading ({} keys) key cache."", CacheService.instance.keyCache.size());

        if (CacheService.instance.rowCache.size() > 0)
            logger.info(""completed pre-loading ({} keys) row cache."", CacheService.instance.rowCache.size());

        try
        {
            GCInspector.instance.start();
        }
        catch (Throwable t)
        {
            logger.warn(""Unable to start GCInspector (currently only supported on the Sun JVM)"");
        }

        // MeteredFlusher can block if flush queue fills up, so don't put on scheduledTasks
        // Start it before commit log, so memtables can flush during commit log replay
        StorageService.optionalTasks.scheduleWithFixedDelay(new MeteredFlusher(), 1000, 1000, TimeUnit.MILLISECONDS);

        // replay the log if necessary
        try
        {
            CommitLog.instance.recover();
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }

        // enable auto compaction
        for (Keyspace keyspace : Keyspace.all())
        {
            for (ColumnFamilyStore cfs : keyspace.getColumnFamilyStores())
            {
                for (final ColumnFamilyStore store : cfs.concatWithIndexes())
                {
                    store.enableAutoCompaction();
                }
            }
        }
        // start compactions in five minutes (if no flushes have occurred by then to do so)
        Runnable runnable = new Runnable()
        {
            public void run()
            {
                for (Keyspace keyspaceName : Keyspace.all())
                {
                    for (ColumnFamilyStore cf : keyspaceName.getColumnFamilyStores())
                    {
                        for (ColumnFamilyStore store : cf.concatWithIndexes())
                            CompactionManager.instance.submitBackground(store);
                    }
                }
            }
        };
        StorageService.optionalTasks.schedule(runnable, 5 * 60, TimeUnit.SECONDS);

        SystemKeyspace.finishStartup();

        // start server internals
        StorageService.instance.registerDaemon(this);
        try
        {
            StorageService.instance.initServer();
        }
        catch (ConfigurationException e)
        {
            logger.error(""Fatal configuration error"", e);
            System.err.println(e.getMessage() + ""\nFatal configuration error; unable to start server.  See log for stacktrace."");
            System.exit(1);
        }

        Mx4jTool.maybeLoad();

        // Metrics
        String metricsReporterConfigFile = System.getProperty(""cassandra.metricsReporterConfigFile"");
        if (metricsReporterConfigFile != null)
        {
            logger.info(""Trying to load metrics-reporter-config from file: {}"", metricsReporterConfigFile);
            try
            {
                String reportFileLocation = CassandraDaemon.class.getClassLoader().getResource(metricsReporterConfigFile).getFile();
                ReporterConfig.loadFromFile(reportFileLocation).enableAll();
            }
            catch (Exception e)
            {
                logger.warn(""Failed to load metrics-reporter-config, metric sinks will not be activated"", e);
            }
        }

        // Thift
        InetAddress rpcAddr = DatabaseDescriptor.getRpcAddress();
        int rpcPort = DatabaseDescriptor.getRpcPort();
        thriftServer = new ThriftServer(rpcAddr, rpcPort);

        // Native transport
        InetAddress nativeAddr = DatabaseDescriptor.getNativeTransportAddress();
        int nativePort = DatabaseDescriptor.getNativeTransportPort();
        nativeServer = new org.apache.cassandra.transport.Server(nativeAddr, nativePort);
    }"
32,4457,cassandra,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.cassandra.service,org.apache.cassandra.service.StorageService,,streamRanges,,rangesToStreamByTable,"rangesToStreamByTable,table,get",2667,2667,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//src/java/org/apache/cassandra/service/StorageService.java#L2667,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/service/StorageService.java,,close,"private CountDownLatch streamRanges(final Map<String, Multimap<Range, InetAddress>> rangesToStreamByTable)
    {
        final CountDownLatch latch = new CountDownLatch(rangesToStreamByTable.keySet().size());
        for (final String table : rangesToStreamByTable.keySet())
        {
            Multimap<Range, InetAddress> rangesWithEndpoints = rangesToStreamByTable.get(table);

            if (rangesWithEndpoints.isEmpty())
            {
                latch.countDown();
                continue;
            }

            final Set<Map.Entry<Range, InetAddress>> pending = new HashSet<Map.Entry<Range, InetAddress>>(rangesWithEndpoints.entries());

            for (final Map.Entry<Range, InetAddress> entry : rangesWithEndpoints.entries())
            {
                final Range range = entry.getKey();
                final InetAddress newEndpoint = entry.getValue();

                final Runnable callback = new Runnable()
                {
                    public void run()
                    {
                        synchronized (pending)
                        {
                            pending.remove(entry);

                            if (pending.isEmpty())
                                latch.countDown();
                        }
                    }
                };

                StageManager.getStage(Stage.STREAM).execute(new Runnable()
                {
                    public void run()
                    {
                        // TODO each call to transferRanges re-flushes, this is potentially a lot of waste
                        StreamOut.transferRanges(newEndpoint, Table.open(table), Arrays.asList(range), callback, OperationType.UNBOOTSTRAP);
                    }
                });
            }
        }
        return latch;
    }"
33,5873,cassandra,WMI_WRONG_MAP_ITERATOR,A,last,,PERFORMANCE,org.apache.cassandra.service,org.apache.cassandra.service.StorageService,,requestRanges,,ranges,"ranges,table,get",2719,2719,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//src/java/org/apache/cassandra/service/StorageService.java#L2719,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/service/StorageService.java,,unknown,"private CountDownLatch requestRanges(final Map<String, Multimap<InetAddress, Range>> ranges)
    {
        final CountDownLatch latch = new CountDownLatch(ranges.keySet().size());
        for (final String table : ranges.keySet())
        {
            Multimap<InetAddress, Range> endpointWithRanges = ranges.get(table);

            if (endpointWithRanges.isEmpty())
            {
                latch.countDown();
                continue;
            }

            final Set<InetAddress> pending = new HashSet<InetAddress>(endpointWithRanges.keySet());

            // Send messages to respective folks to stream data over to me
            for (final InetAddress source: endpointWithRanges.keySet())
            {
                Collection<Range> toFetch = endpointWithRanges.get(source);

                final Runnable callback = new Runnable()
                {
                    public void run()
                    {
                        pending.remove(source);

                        if (pending.isEmpty())
                            latch.countDown();
                    }
                };

                if (logger_.isDebugEnabled())
                    logger_.debug(""Requesting from "" + source + "" ranges "" + StringUtils.join(toFetch, "", ""));

                // sending actual request
                StreamIn.requestRanges(source, table, toFetch, callback, OperationType.BOOTSTRAP);
            }
        }
        return latch;
    }"
