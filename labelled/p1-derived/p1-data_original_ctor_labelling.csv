,warning id,project,bug_pattern,commit,last_commit_checked,?,bug pattern category,package,class,field,method,type,expr,idents,start_line,end_line,label (automatically determined),commit url,"commit url (of the version compared to, if closed)",code (if open),label,method_content
0,63,derby,DM_BOOLEAN_CTOR,B,last,,PERFORMANCE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.SelectNode,,genProjectRestrict,,prnRSN = (ResultSetNode) getNodeFactory().getNode(,,1657,1657,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/compile/SelectNode.java#L1657,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/compile/SelectNode.java,,close,"public ResultSetNode genProjectRestrict(int origFromListSize)
				throws StandardException
	{
        boolean[] eliminateSort = new boolean[orderByLists.length];

		ResultSetNode		prnRSN;

		prnRSN = (ResultSetNode) getNodeFactory().getNode(
								C_NodeTypes.PROJECT_RESTRICT_NODE,
								fromList.elementAt(0),	/* Child ResultSet */
								resultColumns,		/* Projection */
								whereClause,			/* Restriction */
								wherePredicates,/* Restriction as PredicateList */
								selectSubquerys,/* Subquerys in Projection */
								whereSubquerys,	/* Subquerys in Restriction */
								null,
								getContextManager()	 );

		/*
		** If we have aggregates OR a select list we want
		** to generate a GroupByNode.  In the case of a
		** scalar aggregate we have no grouping columns.
		**
		** JRESOLVE: what about correlated aggregates from another
		** block.
		*/ 
		if (((selectAggregates != null) && (selectAggregates.size() > 0)) 
			|| (groupByList != null))
		{
			Vector aggs = selectAggregates;
			if (havingAggregates != null && !havingAggregates.isEmpty()) {
				havingAggregates.addAll(selectAggregates);
				aggs = havingAggregates;
			}
			GroupByNode gbn = (GroupByNode) getNodeFactory().getNode(
												C_NodeTypes.GROUP_BY_NODE,
												prnRSN,
												groupByList,
												aggs,
												havingClause,
												havingSubquerys,
												null,
												new Integer(nestingLevel),
												getContextManager());
			gbn.considerPostOptimizeOptimizations(originalWhereClause != null);
			gbn.assignCostEstimate(optimizer.getOptimizedCost());

			groupByList = null;
			prnRSN  = gbn.getParent();

			// Remember whether or not we can eliminate the sort.
            for (int i=0; i < eliminateSort.length; i++ ) {
                eliminateSort[i] = eliminateSort[i] || gbn.getIsInSortedOrder();
            }
		}


		if (windows != null) {

			// Now we add a window result set wrapped in a PRN on top of what
			// we currently have.

			if (windows.size() > 1) {
				throw StandardException.newException(
					SQLState.LANG_WINDOW_LIMIT_EXCEEDED);
			}

			WindowNode wn = (WindowNode)windows.elementAt(0);

			WindowResultSetNode wrsn =
				(WindowResultSetNode)getNodeFactory().getNode(
					C_NodeTypes.WINDOW_RESULTSET_NODE,
					prnRSN,
					wn,
					windowFuncCalls,
					new Integer(nestingLevel),
					getContextManager());

			prnRSN = wrsn.getParent();
			wrsn.assignCostEstimate(optimizer.getOptimizedCost());
		}


		// if it is distinct, that must also be taken care of.
		if (isDistinct)
		{
			// We first verify that a distinct is valid on the
			// RCL.
			resultColumns.verifyAllOrderable();

			/* See if we can push duplicate elimination into the store
			 * via a hash scan.  This is possible iff:
			 *	o  A single table query
			 *	o  We haven't merged the order by and distinct sorts.
			 *	   (Results do not have to be in a particular order.)
			 *	o  All entries in the select's RCL are ColumnReferences.
			 *	o  No predicates (This is because we currently do not
			 *	   differentiate between columns referenced in the select
			 *	   list and columns referenced in other clauses.  In other
			 *	   words, the store will do duplicate elimination based on
			 *	   all referenced columns.)
			 *	   RESOLVE - We can change this to be all referenced columns
			 *	   have to be in the select list.  In that case, we need to
			 *	   refine which predicates are allowed.  Basically, all predicates
			 *	   must have been pushed down to the index/table scan.(If we make
			 *	   this change, then we need to verify that non of the columns in
			 *	   the predicates are correlated columns.)
			 *	o  NOTE: The implementation of isPossibleDistinctScan() will return
			 *	   false if there is an IndexRowToBaseRow above the 
			 *	   FromBaseTable.  This is because all of a table's columns must come
			 *	   from the same conglomerate in order to get consistent data.
			 */
			boolean distinctScanPossible = false;
			if (origFromListSize == 1 && !orderByAndDistinctMerged)
			{
				boolean simpleColumns = true;
				HashSet distinctColumns = new HashSet();
				int size = resultColumns.size();
				for (int i = 1; i <= size; i++) {
					BaseColumnNode bc = resultColumns.getResultColumn(i).getBaseColumnNode();
					if (bc == null) {
						simpleColumns = false;
						break;
					}
					distinctColumns.add(bc);
				}
				if (simpleColumns && prnRSN.isPossibleDistinctScan(distinctColumns)) {
					prnRSN.markForDistinctScan();
					distinctScanPossible = true;
				}
			}

			if (!distinctScanPossible)
			{
				/* We can't do a distinct scan. Determine if we can filter out 
				 * duplicates without a sorter. 
				 */
				boolean inSortedOrder = isOrderedResult(resultColumns, prnRSN, !(orderByAndDistinctMerged));
				prnRSN = (ResultSetNode) getNodeFactory().getNode(
											C_NodeTypes.DISTINCT_NODE,
											prnRSN,
											new Boolean(inSortedOrder),
											null,
											getContextManager());
				prnRSN.costEstimate = costEstimate.cloneMe();

                // Remember whether or not we can eliminate the sort.
                for (int i=0; i < eliminateSort.length; i++) {
                    eliminateSort[i] = eliminateSort[i] || inSortedOrder;
                }
			}
		}

		/* Generate the OrderByNode if a sort is still required for
		 * the order by.
		 */

        for (int i=0; i < orderByLists.length; i++) {
            if (orderByLists[i] != null)
            {
                if (orderByLists[i].getSortNeeded())
                {
                    prnRSN = (ResultSetNode) getNodeFactory().getNode(
                            C_NodeTypes.ORDER_BY_NODE,
                            prnRSN,
                            orderByLists[i],
                            null,
                            getContextManager());
                    prnRSN.costEstimate = costEstimate.cloneMe();
                }

                // There may be columns added to the select projection list
                // a query like:
                // select a, b from t group by a,b order by a+b
                // the expr a+b is added to the select list.
                int orderBySelect = this.getResultColumns().getOrderBySelect();
                if (orderBySelect > 0)
                {
                    // Keep the same RCL on top, since there may be references
                    // to its result columns above us, i.e. in this query:
                    //
                    // select sum(j),i from t group by i having i
                    //             in (select i from t order by j)
                    //
                    ResultColumnList topList = prnRSN.getResultColumns();
                    ResultColumnList newSelectList =
                        topList.copyListAndObjects();
                    prnRSN.setResultColumns(newSelectList);

                    topList.removeOrderByColumns();
                    topList.genVirtualColumnNodes(prnRSN, newSelectList);
                    prnRSN = (ResultSetNode) getNodeFactory().getNode(
                            C_NodeTypes.PROJECT_RESTRICT_NODE,
                            prnRSN,
                            topList,
                            null,
                            null,
                            null,
                            null,
                            null,
                            getContextManager());
                }
            }

            // Do this only after the main ORDER BY; any extra added by
            // IntersectOrExceptNode should sit on top of us.
            if (i == 0 && (offset != null || fetchFirst != null)) {
                // Keep the same RCL on top, since there may be references to
                // its result columns above us.
                ResultColumnList topList = prnRSN.getResultColumns();
                ResultColumnList newSelectList = topList.copyListAndObjects();
                prnRSN.setResultColumns(newSelectList);
                topList.genVirtualColumnNodes(prnRSN, newSelectList);
                prnRSN = (ResultSetNode)getNodeFactory().getNode(
                        C_NodeTypes.ROW_COUNT_NODE,
                        prnRSN,
                        topList,
                        offset,
                        fetchFirst,
                        Boolean.valueOf( hasJDBClimitClause ),
                        getContextManager());
            }
        }


		if (wasGroupBy &&
			resultColumns.numGeneratedColumnsForGroupBy() > 0 &&
			windows == null) // windows handling already added a PRN which
							 // obviates this.
		{
			// This case takes care of columns generated for group by's which 
			// will need to be removed from the final projection. Note that the
			// GroupByNode does remove generated columns but in certain cases
			// we dispense with a group by and replace it with a distinct instead.
			// So in a query like:
			// select c1 from t group by c1, c2
			// we would have added c2 to the projection list which will have to be 
			// projected out.
			//

			// Keep the same RCL on top, since there may be
			// references to its result columns above us, e.g. in this query:
			//
			// select sum(j),i from t group by i having i
			//             in (select i from t group by i,j )
			//
			ResultColumnList topList = prnRSN.getResultColumns();
			ResultColumnList newSelectList = topList.copyListAndObjects();
			prnRSN.setResultColumns(newSelectList);

			topList.removeGeneratedGroupingColumns();
			topList.genVirtualColumnNodes(prnRSN, newSelectList);
			prnRSN = (ResultSetNode) getNodeFactory().getNode(
						C_NodeTypes.PROJECT_RESTRICT_NODE,
						prnRSN,
						topList,
						null,
						null,
						null,
						null,
						null,
						getContextManager());
		}

        for (int i=0; i < orderByLists.length; i++) {
            if (!(orderByLists[i] != null && orderByLists[i].getSortNeeded()) &&
                orderByQuery)
            {
                // Remember whether or not we can eliminate the sort.
                eliminateSort[i] = true;
            }

            /* If we were able to eliminate the sort during optimization then
             * we must tell the underlying tree.  At minimum, this means no
             * group fetch on an index under an IndexRowToBaseRow since that
             * that could lead to incorrect results.  (Bug 2347.)
             */
            if (eliminateSort[i])
            {
                prnRSN.adjustForSortElimination(orderByLists[i]);
            }

            /* Set the cost of this node in the generated node */
            prnRSN.costEstimate = costEstimate.cloneMe();
        }

		return prnRSN;
	}"
1,837,derby,DM_BOOLEAN_CTOR,B,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.TriggerInfo,,hasTrigger,,Boolean,"Boolean,Boolean,hasTrigger,isBefore,isRow",166,166,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/execute/TriggerInfo.java#L166,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/TriggerInfo.java,,close,"boolean hasTrigger(boolean isBefore, boolean isRow)
	{
		if (triggerArray == null)
		{
			return false;
		}

		return hasTrigger(new Boolean(isBefore), new Boolean(isRow));
	}"
2,132,derby,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.derby.impl.services.monitor,org.apache.derby.impl.services.monitor.FileMonitor,,run,,Boolean,"Boolean,PBinitialize,action",287,287,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/engine/org/apache/derby/impl/services/monitor/FileMonitor.java#L287,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/services/monitor/FileMonitor.java,,unknown,"public synchronized final Object run() throws IOException {
		switch (action) {
		case 0:
		case 1:
			// SECURITY PERMISSION - OP2, OP2a, OP2b
			return new Boolean(PBinitialize(action == 0));
		case 2: 
			// SECURITY PERMISSION - IP1
			return super.getDefaultModuleProperties();
		case 3:
			// SECURITY PERMISSION - OP1
			return PBgetJVMProperty(key3);
		case 4:
        {
            boolean setMinPriority = (intValue != 0);
            try {
                return super.getDaemonThread(task, key3, setMinPriority);
            } catch (IllegalThreadStateException e) {
                // We may get an IllegalThreadStateException if all the
                // previously running daemon threads have completed and the
                // daemon group has been automatically destroyed. If that's
                // what has happened, create a new daemon group and try again.
                if (daemonGroup != null && daemonGroup.isDestroyed()) {
                    daemonGroup = createDaemonGroup();
                    return super.getDaemonThread(task, key3, setMinPriority);
                } else {
                    throw e;
                }
            }
        }
		case 5:
			super.setThreadPriority(intValue);
			return null;
		case 6:
			// SECURITY PERMISSION - OP3
			return PBapplicationPropertiesStream();

		default:
			return null;
		}
	}"
3,140,derby,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.BaseDataFileFactory$5,,run,,return new Boolean(bsegdir.isDirectory());,,2603,2603,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/engine/org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java#L2603,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/BaseDataFileFactory.java,,close,"public Object run()
          {
              CodeSource cs = null;
              try {
                  cs = cls.getProtectionDomain().getCodeSource();
              }
              catch (SecurityException se) {
                  return se.getMessage();
              }
  
              if ( cs == null || cs.getLocation() == null )
                  return null;        
      
              URL result = cs.getLocation ();
      
              return result.toString();
          }"
4,292,derby,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.derby.impl.services.monitor,org.apache.derby.impl.services.monitor.StorageFactoryService$12,,run,,Boolean,"Boolean,file,exists",964,964,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/engine/org/apache/derby/impl/services/monitor/StorageFactoryService.java#L964,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/services/monitor/StorageFactoryService.java,,close,"public Object run() throws IOException, StandardException
                        {
                            home = relativeRoot.getPath();
                            canonicalHome = relativeRoot.getCanonicalPath();
                            rootStorageFactory = getStorageFactoryInstance( true, null, null, null);

                            if( home != null)
                            {
                                StorageFile rootDir = rootStorageFactory.newStorageFile( null);
                                boolean created = rootDir.mkdirs();
                                if (created) {
                                    rootDir.limitAccessToOwner();
                                }
                            }
                            return null;
                        }"
5,727,derby,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.SQLParser,,sequentialCompress,,{if (true) return (StatementNode) nodeFactory.getNode(,,13484,13484,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java#L13484,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java,,unknown,
6,776,derby,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.SQLParser,,inplaceCompress,,{if (true) return (StatementNode) nodeFactory.getNode(,,13463,13463,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java#L13463,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java,,unknown,
7,899,derby,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.SQLParser,,routineElement,,clauseValue = new Boolean(routineSecurityClause());,,10667,10667,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java#L10667,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java,,unknown,
8,3,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.replication.net,org.apache.derby.impl.store.replication.net.ReplicationMessageTransmit,,brokerConnection,,ReplicationMessage initiatorMsg =,,259,259,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java#L259,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/replication/net/ReplicationMessageTransmit.java,,close,"private void brokerConnection(long synchOnInstant)
        throws IOException, StandardException, ClassNotFoundException {
        // Check that master and slave have the same serialVersionUID
        ReplicationMessage initiatorMsg = 
            new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_VERSION, 
                                   new Long(ReplicationMessage.
                                            serialVersionUID));
        verifyMessageType(sendMessageWaitForReply(initiatorMsg),
                          ReplicationMessage.TYPE_ACK);

        // Check that master and slave log files are in synch
        initiatorMsg =
            new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_INSTANT,
                                   new Long(synchOnInstant));
        verifyMessageType(sendMessageWaitForReply(initiatorMsg),
                          ReplicationMessage.TYPE_ACK);
    }"
9,4,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.services.monitor,org.apache.derby.impl.services.monitor.BaseMonitor,,newInstanceFromIdentifier,,"throw StandardException.newException(SQLState.REGISTERED_CLASS_INSTANCE_ERROR,",,698,698,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/services/monitor/BaseMonitor.java#L698,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/services/monitor/BaseMonitor.java,,close,"public Object newInstanceFromIdentifier(int identifier)
		throws StandardException {

		InstanceGetter ci = classFromIdentifier(identifier);

		Throwable t;
		try {
			Object result = ci.getNewInstance();
/*
				if (SanityManager.DEBUG) {
					if(SanityManager.DEBUG_ON(Monitor.NEW_INSTANCE_FROM_ID_TRACE_DEBUG_FLAG))
					{
						String traceResult = ""null"";

						if (result != null) traceResult = ""not null"";

						SanityManager.DEBUG(Monitor.NEW_INSTANCE_FROM_ID_TRACE_DEBUG_FLAG,
											""newInstanceFromIdentifier(""+identifier+"") ""+
											"" ClassName: ""+
											result.getClass().getName() +
											"" returned ""+
											traceResult);
					}
				}
*/
			return result;
		}
		catch (InstantiationException ie) {
			t = ie;
		}
 		catch (IllegalAccessException iae) {
			t = iae;
		}
		catch (InvocationTargetException ite) {
			t = ite;
		}
		catch (LinkageError le) {
			t = le;
		}
		throw StandardException.newException(SQLState.REGISTERED_CLASS_INSTANCE_ERROR,
			t, new Integer(identifier), ""XX"" /*ci.getClassName()*/);
	}"
10,5,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.LOBStreamControl,,isValidPostion,,StandardException,"StandardException,newException",165,165,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java#L165,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java,,close,"private void isValidPostion(long pos)
            throws IOException, StandardException {
        if (pos < 0)
            throw StandardException.newException(
                    SQLState.BLOB_NONPOSITIVE_LENGTH, new Long(pos + 1));
        if (pos > Integer.MAX_VALUE)
            throw StandardException.newException(
                    SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));

        if (isBytes) {
            if (dataBytes == null) {
                if (pos != 0)
                    throw StandardException.newException(
                            SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
            } else if (dataBytes.length < pos)
                throw StandardException.newException(
                        SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
        } else {
            if (pos > tmpFile.length())
                throw StandardException.newException(
                        SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos + 1));
        }
    }"
11,6,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.store.raw,org.apache.derby.iapi.store.raw.ContainerKey,,lockAttributes,,VirtualLockTable,"VirtualLockTable,attributes,CONTAINERID,put",179,179,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/store/raw/ContainerKey.java#L179,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/store/raw/ContainerKey.java,,close,"public boolean lockAttributes(int flag, Hashtable<String,Object> attributes)
	{
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(attributes != null, 
				""cannot call lockProperties with null attribute list"");
		}

		if ((flag & VirtualLockTable.TABLE_AND_ROWLOCK) == 0)
			return false;

		attributes.put(VirtualLockTable.CONTAINERID, 
					   new Long(getContainerId()));
		attributes.put(VirtualLockTable.LOCKNAME, ""Tablelock"");
		attributes.put(VirtualLockTable.LOCKTYPE, ""TABLE"");

		// attributes.put(VirtualLockTable.SEGMENTID, new Long(identity.getSegmentId()));

		return true;
	}"
12,11,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.SYSCOLUMNSRowFactory,,makeRow,,Integer,"Integer,colID,column,getPosition",176,176,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java#L176,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/SYSCOLUMNSRowFactory.java,,close,"public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent)
					throws StandardException
	{
		ExecRow    				row;

		String					colName = null;
		String					defaultID = null;
		String					tabID = null;
		Integer					colID = null;
		TypeDescriptor 		    typeDesc = null;
		Object					defaultSerializable = null;
		long					autoincStart = 0;
		long					autoincInc = 0;
		long					autoincValue = 0;
		//The SYSCOLUMNS table's autoinc related columns change with different
		//values depending on what happened to the autoinc column, ie is the 
		//user adding an autoincrement column, or is user changing the existing 
		//autoincrement column to change it's increment value or to change it's
		//start value? Following variable is used to keep track of what happened 
		//to the autoincrement column.
		long autoinc_create_or_modify_Start_Increment = -1;

		if (td != null)
		{
			ColumnDescriptor  column = (ColumnDescriptor)td;
		
			/* Lots of info in the column's type descriptor */
			typeDesc = column.getType().getCatalogType();

			tabID = column.getReferencingUUID().toString();
			colName = column.getColumnName();
			colID = new Integer(column.getPosition() );
			autoincStart = column.getAutoincStart();
			autoincInc   = column.getAutoincInc();
			autoincValue   = column.getAutoincValue();
			autoinc_create_or_modify_Start_Increment = column.getAutoinc_create_or_modify_Start_Increment();
			if (column.getDefaultInfo() != null)
			{
				defaultSerializable = column.getDefaultInfo();
			}
			else
			{
				defaultSerializable = column.getDefaultValue();
			}
			if  (column.getDefaultUUID() != null)
			{
				defaultID = column.getDefaultUUID().toString();
			}
		}

		/* Insert info into syscolumns */

		/* RESOLVE - It would be nice to require less knowledge about syscolumns
		 * and have this be more table driven.
		 * RESOLVE - We'd like to store the DataTypeDescriptor in a column.
		 */

		/* Build the row to insert  */
		row = getExecutionFactory().getValueRow(SYSCOLUMNS_COLUMN_COUNT);

		/* 1st column is REFERENCEID (UUID - char(36)) */
		row.setColumn(SYSCOLUMNS_REFERENCEID, new SQLChar(tabID));

		/* 2nd column is COLUMNNAME (varchar(128)) */
		row.setColumn(SYSCOLUMNS_COLUMNNAME, new SQLVarchar(colName));

		/* 3rd column is COLUMNNUMBER (int) */
		row.setColumn(SYSCOLUMNS_COLUMNNUMBER, new SQLInteger(colID));

		/* 4th column is COLUMNDATATYPE */
		row.setColumn(SYSCOLUMNS_COLUMNDATATYPE,
				new UserType(typeDesc));

		/* 5th column is COLUMNDEFAULT */
		row.setColumn(SYSCOLUMNS_COLUMNDEFAULT,
					  new UserType(defaultSerializable));

		/* 6th column is DEFAULTID (UUID - char(36)) */
		row.setColumn(SYSCOLUMNS_COLUMNDEFAULTID, new SQLChar(defaultID));

		if (autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.CREATE_AUTOINCREMENT ||
				autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE)
		{//user is adding an autoinc column or is changing the increment value of autoinc column
			// This code also gets run when ALTER TABLE DROP COLUMN
			// is used to drop a column other than the autoinc
			// column, and the autoinc column gets removed from
			// SYSCOLUMNS and immediately re-added with a different
			// column position (to account for the dropped column).
			// In this case, the autoincValue may have a
			// different value than the autoincStart.
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
						  new SQLLongint(autoincValue));
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
						  new SQLLongint(autoincStart));
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, 
						  new SQLLongint(autoincInc));
		} else if (autoinc_create_or_modify_Start_Increment == ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE)
		{//user asked for restart with a new value, so don't change increment by and original start
			//with values in the SYSCOLUMNS table. Just record the RESTART WITH value as the
			//next value to be generated in the SYSCOLUMNS table
			ColumnDescriptor  column = (ColumnDescriptor)td;
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, new SQLLongint(autoincStart));
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, new SQLLongint(autoincStart));
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC, new SQLLongint(
					column.getTableDescriptor().getColumnDescriptor(colName).getAutoincInc()));
		}
		else
		{
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTVALUE, 
						  new SQLLongint());
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTSTART, 
						  new SQLLongint());
			row.setColumn(SYSCOLUMNS_AUTOINCREMENTINC,
						  new SQLLongint());
		}
		return row;
	}"
13,13,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SQLChar,,locate,,throw StandardException.newException(,,2396,2396,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SQLChar.java#L2396,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SQLChar.java,,close,"public NumberDataValue locate(  StringDataValue searchFrom,
                                    NumberDataValue start,
                                    NumberDataValue result)
                                    throws StandardException
    {
        int startVal;

        if( result == null )
        {
            result = new SQLInteger();
        }
        
        if( start.isNull() )
        {
            startVal = 1;
        }
        else
        {
            startVal = start.getInt();
        }

        if( isNull() || searchFrom.isNull() )
        {
            result.setToNull();
            return result;
        }

        String mySearchFrom = searchFrom.getString();
        String mySearchFor = this.getString();

        /* the below 2 if conditions are to emulate DB2's behavior */
        if( startVal < 1 )
        {
            throw StandardException.newException(
                    SQLState.LANG_INVALID_PARAMETER_FOR_SEARCH_POSITION, 
                    getString(), mySearchFrom,
                    new Integer(startVal));
        }
        
        if( mySearchFor.length() == 0 )
        {
            result.setValue( startVal );
            return result;
        }

        result.setValue( mySearchFrom.indexOf(mySearchFor, startVal - 1) + 1);
        return result;
    }"
14,19,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.xplain,org.apache.derby.impl.sql.execute.xplain.XPLAINUtil,,getAVGNextTime,,Long,"Long,dividend",424,424,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java#L424,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,,close,"public static Long getAVGNextTime(long dividend, long divisor){
         if(divisor==0) return null;
         if(dividend==0) return new Long(0);
         return new Long(dividend/divisor);
     }"
15,26,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealTableScanStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,369,369,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealTableScanStatistics.java#L369,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealTableScanStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        String lockMode = XPLAINUtil.getLockModeCode(this.lockString);
        String lockGran = XPLAINUtil.getLockGranularityCode(this.lockString);
        
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                           // the number of index updates 
           lockMode,                       // lock mode
           lockGran,                       // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeen),            // the seen rows
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),        // the filtered rows
           new Integer(this.rowsSeen-this.rowsFiltered),// the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,                       // the stmt UUID
           (UUID)timingID);
    }"
16,30,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.SYSSEQUENCESRowFactory,,buildDescriptor,,Long,"Long,col,currentValue,getLong",255,255,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/catalog/SYSSEQUENCESRowFactory.java#L255,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/SYSSEQUENCESRowFactory.java,,close,"public TupleDescriptor buildDescriptor
            (ExecRow row,
             TupleDescriptor parentTupleDescriptor,
             DataDictionary dd)
            throws StandardException {

        DataValueDescriptor col;
        SequenceDescriptor descriptor;
        UUID ouuid;
        String sequenceName;
        UUID suuid;
        Long currentValue;
        long startValue;
        long minimumValue;
        long maximumValue;
        long increment;
        String cycleOption;

        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();

        if (SanityManager.DEBUG) {
            SanityManager.ASSERT(row.nColumns() == SYSSEQUENCES_COLUMN_COUNT,
                    ""Wrong number of columns for a SYSSEQUENCES row"");
        }

        // first column is uuid of this sequence descriptor (char(36))
        col = row.getColumn(SYSSEQUENCES_SEQUENCEID);
        String oidString = col.getString();
        ouuid = getUUIDFactory().recreateUUID(oidString);

        // second column is sequenceName (varchar(128))
        col = row.getColumn(SYSSEQUENCES_SEQUENCENAME);
        sequenceName = col.getString();

        // third column is uuid of this sequence descriptors schema (char(36))
        col = row.getColumn(SYSSEQUENCES_SCHEMAID);
        String schemaIdString = col.getString();
        suuid = getUUIDFactory().recreateUUID(schemaIdString);

        // fourth column is the data type of this sequene generator
        /*
          ** What is stored in the column is a TypeDescriptorImpl, which
          ** points to a BaseTypeIdImpl.  These are simple types that are
          ** intended to be movable to the client, so they don't have
          ** the entire implementation.  We need to wrap them in DataTypeServices
          ** and TypeId objects that contain the full implementations for
          ** language processing.
          */
        TypeDescriptor catalogType = (TypeDescriptor) row.getColumn(SYSSEQUENCES_SEQUENCEDATATYPE).
                getObject();
        DataTypeDescriptor dataTypeServices =
                DataTypeDescriptor.getType(catalogType);

        col = row.getColumn(SYSSEQUENCES_CURRENT_VALUE);
        if ( col.isNull() ) { currentValue = null; }
        else { currentValue = new Long( col.getLong() ) ; }

        col = row.getColumn(SYSSEQUENCES_START_VALUE);
        startValue = col.getLong();

        col = row.getColumn(SYSSEQUENCES_MINIMUM_VALUE);
        minimumValue = col.getLong();

        col = row.getColumn(SYSSEQUENCES_MAXIMUM_VALUE);
        maximumValue = col.getLong();

        col = row.getColumn(SYSSEQUENCES_INCREMENT);
        increment = col.getLong();

        col = row.getColumn(SYSSEQUENCES_CYCLE_OPTION);
        cycleOption = col.getString();

        descriptor = ddg.newSequenceDescriptor
                (dd.getSchemaDescriptor(suuid, null),
                        ouuid,
                        sequenceName,
                        dataTypeServices,
                        currentValue,
                        startValue,
                        minimumValue,
                        maximumValue,
                        increment,
                        cycleOption.equals(""Y"") ? true : false);

        return descriptor;
    }"
17,31,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedClob,,setString,,throw Util.generateCsSQLException(,,560,560,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java#L560,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java,,close,"public int setString(long pos, String str) throws SQLException {
            return setString (pos, str, 0, str.length());
    }"
18,35,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMAccessManager,,conglomCacheAddEntry,,CacheableConglomerate conglom_entry = (CacheableConglomerate),,508,508,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java#L508,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java,,close,"void conglomCacheAddEntry(
    long            conglomid,
    Conglomerate    conglom)
        throws StandardException
    {
        // Insert the new entry.
        CacheableConglomerate conglom_entry = (CacheableConglomerate)
            conglom_cache.create(new Long(conglomid), conglom);
        conglom_cache.release(conglom_entry);
    }"
19,36,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.Heap,,compressConglomerate,,StandardException,"StandardException,newException",949,949,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/Heap.java#L949,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/Heap.java,,close,"public void compressConglomerate(
    TransactionManager              xact_manager,
    Transaction                     rawtran)
        throws StandardException
    {
        OpenConglomerate        open_conglom    = null;
        HeapController          heapcontroller  = null;

        try
        {
            open_conglom = new OpenHeap();

            // Open table in intended exclusive mode in the top level 
            // transaction, this will stop any ddl from happening until 
            // purge of whole table is finished.

            if (open_conglom.init(
                    (ContainerHandle) null,
                    this,
                    this.format_ids,
                    this.collation_ids,
                    xact_manager,
                    rawtran,
                    false,
                    TransactionController.OPENMODE_FORUPDATE,
                    TransactionController.MODE_TABLE,
                    rawtran.newLockingPolicy(
                        LockingPolicy.MODE_CONTAINER,
                        TransactionController.ISOLATION_REPEATABLE_READ, true),
                    null) == null)
            {
                throw StandardException.newException(
                        SQLState.HEAP_CONTAINER_NOT_FOUND, 
                        new Long(id.getContainerId()));
            }

            heapcontroller = new HeapController();

            heapcontroller.init(open_conglom);

            open_conglom.getContainer().compressContainer();
        }
        finally
        {
            if (open_conglom != null)
                open_conglom.close();
        }

        return;
    }"
20,44,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.Heap,,openStoreCost,,StandardException,"StandardException,newException",1061,1061,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/Heap.java#L1061,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/Heap.java,,close,"public StoreCostController openStoreCost(
    TransactionManager  xact_manager,
    Transaction         rawtran)
		throws StandardException
    {
        OpenHeap open_conglom = new OpenHeap();

        if (open_conglom.init(
                (ContainerHandle) null,
                this,
                this.format_ids,
                this.collation_ids,
                xact_manager,
                rawtran,
                false,
                ContainerHandle.MODE_READONLY,
                TransactionController.MODE_TABLE,
                (LockingPolicy) null,
                (DynamicCompiledOpenConglomInfo) null) == null)
        {
            throw StandardException.newException(
                    SQLState.HEAP_CONTAINER_NOT_FOUND, 
                    new Long(id.getContainerId()));
        }


        HeapCostController heapcost = new HeapCostController();

        heapcost.init(open_conglom);

		return(heapcost);
    }"
21,48,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.BaseContainer,,compressContainer,,StandardException,"StandardException,newException",210,210,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java#L210,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java,,close,"public void compressContainer(BaseContainerHandle handle)
        throws StandardException
    {
		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();

		int mode = handle.getMode(); 

		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
								 ContainerHandle.MODE_FORUPDATE, 
								 ""addPage handle not for update"");
		}

		// if we are not in the same transaction as the one which created the
		// container and the container may have logged some operation already, 
		// then we need to log allocation regardless of whether user changes
		// are logged.  Otherwise, the database will be corrupted if it
		// crashed. 
		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
			(mode & ContainerHandle.MODE_UNLOGGED) ==
						ContainerHandle.MODE_UNLOGGED) 
			mode &= ~ContainerHandle.MODE_UNLOGGED;

		// make a handle which is tied to the ntt, not to the user transaction 
        // this handle is tied to.  The container is already locked by the 
        // user transaction, open it nolock
		BaseContainerHandle allocHandle = (BaseContainerHandle)
            ntt.openContainer(identity, (LockingPolicy)null, mode);

		if (allocHandle == null)
        {
			throw StandardException.newException(
                    SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
                    new Long(getSegmentId()), 
                    new Long(getContainerId()));
        }

		CompatibilitySpace cs = ntt.getCompatibilitySpace();
		// Latch this container, the commit will release the latch
		ntt.getLockFactory().lockObject(
                cs, ntt, this, null, C_LockFactory.WAIT_FOREVER);

		try
		{
            incrementReusableRecordIdSequenceNumber();						
            compressContainer(ntt, allocHandle);
		}
		finally
		{
            ntt.commit();

			ntt.close();
		}
    }"
22,49,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql,org.apache.derby.impl.sql.GenericPreparedStatement,,getParameterType,,throw StandardException.newException,,498,498,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/GenericPreparedStatement.java#L498,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/GenericPreparedStatement.java,,close,"public DataTypeDescriptor  getParameterType( int idx ) throws StandardException
    {
		if ( paramTypeDescriptors == null )
        {
			throw StandardException.newException( SQLState.NO_INPUT_PARAMETERS );
		}

		/* Check that the parameterIndex is in range. */
		if ( (idx < 0) || (idx >= paramTypeDescriptors.length) )
        {
			/* This message matches the one used by the DBMS */
			throw StandardException.newException
                (
                 SQLState.LANG_INVALID_PARAM_POSITION, 
                 new Integer( idx+1 ),
                 new Integer( paramTypeDescriptors.length )
                 );
		}

        return paramTypeDescriptors[ idx ];
    }"
23,52,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.services.jce,org.apache.derby.impl.services.jce.JCECipherFactory,,generateKey,,Integer,"Integer,MIN_BOOTPASS_LENGTH,SQLState,StandardException,ILLEGAL_BP_LENGTH,newException",309,309,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/services/jce/JCECipherFactory.java#L309,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/services/jce/JCECipherFactory.java,,close,"private SecretKey generateKey(byte[] secretKey) throws StandardException
	{
		int length = secretKey.length;

		if (length < CipherFactory.MIN_BOOTPASS_LENGTH)
			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH, new Integer(MIN_BOOTPASS_LENGTH));

		try
		{
            if (cryptoAlgorithmShort.equals(DES))
            {   // single DES
			    if (DESKeySpec.isWeak(secretKey, 0))
			    {
				    // OK, it is weak, spice it up
				    byte[] spice = StringUtil.getAsciiBytes(""louDScap"");
				    for (int i = 0; i < 7; i++)
					    secretKey[i] = (byte)((spice[i] << 3) ^ secretKey[i]);
			    }
            }
			return new SecretKeySpec(secretKey, cryptoAlgorithmShort);
		}
		catch (InvalidKeyException ike)
		{
			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
		}

	}"
24,55,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.log,org.apache.derby.impl.store.raw.log.LogToFile,,appendLogRecord,,throw StandardException.newException(,,3870,3870,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java#L3870,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java,,close,"public long appendLogRecord(byte[] data, int offset, int length,
			byte[] optionalData, int optionalDataOffset, int optionalDataLength) 
		 throws StandardException
	{
        if (inReplicationSlavePreMode) {
            // Return the *current* end of log without adding the log
            // record to the log file. Effectively, this call to
            // appendLogRecord does not do anything
            return LogCounter.makeLogInstantAsLong(logFileNumber, endPosition);
        }

		long instant;
		boolean testIncompleteLogWrite = false;

		if (ReadOnlyDB)
        {
			throw StandardException.newException(
                SQLState.LOG_READ_ONLY_DB_UPDATE);
        }

		if (length <= 0)
        {
            throw StandardException.newException(
                    SQLState.LOG_ZERO_LENGTH_LOG_RECORD);
        }

		// RESOLVE: calculate checksum here
		if (SanityManager.DEBUG)
		{
			if (SanityManager.DEBUG_ON(TEST_LOG_INCOMPLETE_LOG_WRITE))
			{
				/// /// /// /// /// /// /// /// /// /// 
				//
				// go into this alternate route instead
				//
				/// /// /// /// /// /// /// /// /// /// 
				return logtest_appendPartialLogRecord(data, offset, length,
													  optionalData,
													  optionalDataOffset,
													  optionalDataLength);

			}

		}

		try
		{
			if (SanityManager.DEBUG)
			{
				if (SanityManager.DEBUG_ON(TEST_LOG_FULL))
					testLogFull();	// if log is 'full' this routine will throw an
								// exception 
			}

			synchronized (this)
			{
				// has someone else found a problem in the raw store?
				if (corrupt != null)
                {
					throw StandardException.newException(
                            SQLState.LOG_STORE_CORRUPT, corrupt);
                }

				if (logOut == null)
                {
					throw StandardException.newException(SQLState.LOG_NULL);
                }

				/*
				 * NOTE!!
				 *
				 * subclass which logs special record to the stream depends on
				 * the EXACT byte sequence of the following segment of code.  
				 * If you change this, not only will you need to write upgrade
				 * code for this class, you also need to find all the subclass
				 * which write log record to log stream directly to make sure 
				 * they are OK
				 */

				// see if the log file is too big, if it is, switch to the next
				// log file. account for an extra INT_LENGTH because switchLogFile()
                // writes an extra 0 at the end of the log. in addition, a checksum log record
                // may need to be written (see DERBY-2254).
                int     checksumLogRecordSize = logOut.getChecksumLogRecordSize();
				if ( (endPosition + LOG_RECORD_OVERHEAD + length + INT_LENGTH + checksumLogRecordSize) >=
                     LogCounter.MAX_LOGFILE_SIZE)
				{
					switchLogFile();

					// still too big??  Giant log record?
                    if ( (endPosition + LOG_RECORD_OVERHEAD + length + INT_LENGTH + checksumLogRecordSize) >=
                         LogCounter.MAX_LOGFILE_SIZE)
                    {
						throw StandardException.newException(
                                SQLState.LOG_EXCEED_MAX_LOG_FILE_SIZE, 
                                new Long(logFileNumber), 
                                new Long(endPosition), 
                                new Long(length), 
                                new Long(LogCounter.MAX_LOGFILE_SIZE));
                    }
				}

				//reserve the space for the checksum log record
				setEndPosition( endPosition + logOut.reserveSpaceForChecksum(length, logFileNumber,endPosition) );

				// don't call currentInstant since we are already in a
				// synchronzied block 
				instant = 
                    LogCounter.makeLogInstantAsLong(logFileNumber, endPosition);

                logOut.writeLogRecord(
                    length, instant, data, offset, 
                    optionalData, optionalDataOffset, optionalDataLength);

				if (optionalDataLength != 0) 
                {
					if (SanityManager.DEBUG)
					{
						if (optionalData == null)
							SanityManager.THROWASSERT(
							""optionalDataLength = "" + optionalDataLength +
							"" with null Optional data"");

						if (optionalData.length <
											 (optionalDataOffset+optionalDataLength))
							SanityManager.THROWASSERT(
							""optionalDataLength = "" + optionalDataLength +
							"" optionalDataOffset = "" + optionalDataOffset + 
							"" optionalData.length = "" + optionalData.length);
					}
				}

				setEndPosition( endPosition + (length + LOG_RECORD_OVERHEAD) );
			}
		}
		catch (IOException ioe)
		{
			throw markCorrupt(StandardException.newException(
                    SQLState.LOG_FULL, ioe));
		}

		return instant;
	}"
25,61,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedResultSet,,getColumn,,"throw newSQLException(SQLState.COLUMN_NOT_FOUND,",,4698,4698,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java#L4698,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java,,close,"protected final DataValueDescriptor getColumn(int columnIndex)
		throws SQLException, StandardException {

	  closeCurrentStream();

	  if (columnIndex < 1 || columnIndex > resultDescription.getColumnCount()) {
		  throw newSQLException(SQLState.COLUMN_NOT_FOUND, 
								new Integer(columnIndex));
	  }
	  if (isOnInsertRow || currentRowHasBeenUpdated && columnGotUpdated[columnIndex -1]) {
		  return updateRow.getColumn(columnIndex);
	  } else {
		  checkOnRow(); // make sure there's a row
		  return currentRow.getColumn(columnIndex);
	  }
	}"
26,65,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.InsertResultSet,,bulkValidateForeignKeys,,indexConversionTable,"indexConversionTable,pkConglom,get",1541,1541,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java#L1541,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java,,close,"private void bulkValidateForeignKeys(
            TransactionController tc, ContextManager cm, ExecRow fullTemplate)
		throws StandardException
	{
		FKInfo 			fkInfo;

		/*
		** If there are no foreign keys, then nothing to worry 
		** about.
		** With bulk insert replace, we still need to verify 
		** all non-self referencing foreign keys when
		** there are no rows inserted into the table.
		*/
		if ((indexRows == null && !bulkInsertReplace) || 
			fkInfoArray == null)
		{
			return;
		}

		for (int i = 0; i < fkInfoArray.length; i++)
		{
			fkInfo = fkInfoArray[i];

			/* With regular bulk insert, we only need to check the
			 * foreign keys in the table we inserted into.  We need
			 * to get the new conglomerate #s for the foreign keys.
			 *
			 * With bulk insert replace, we need to check both the
			 * foreign keys in the table as well as any foreign keys
			 * on other tables referencing the table we inserted into.
			 * If the foreign key is self-referencing then we need to
			 * get the new conglomerate #, otherwise the conglomerate
			 * # is the same as the compile time conglomerate #.
			 * If the foreign key is self-referencing then we need to
			 * get the new conglomerate # for the primary key as it
			 * has changed.  However, if the foreign key is not self-referencing
			 * then we only need to get the new conglomerate # for
			 * the primary key if the primary key is on the table being 
			 * inserted into.
			 */
			if (bulkInsertReplace)
			{
				for (int index = 0; index < fkInfo.fkConglomNumbers.length; index++)
				{
					/* No need to check foreign key if it is self referencing
					 * and there were no rows inserted on the replace, as both
					 * indexes will be empty.
					 */
					if (fkInfo.fkIsSelfReferencing[index] && indexRows == null)
					{
						continue;
					}

					long pkConglom;
					long fkConglom;

					if (fkInfo.fkIsSelfReferencing[index])
					{
						/* Self-referencing foreign key.  Both conglomerate
						 * #s have changed.
						 */
						pkConglom = (indexConversionTable.get(
									new Long(fkInfo.refConglomNumber))).longValue();
						fkConglom = (indexConversionTable.get(
										new Long(fkInfo.fkConglomNumbers[index]))).longValue();
					}
					else
					{
						/* Non-self referencing foreign key.  At this point we
						 * don't know if the primary key or the foreign key is
						 * on this table.  So, for each one, we look to see
						 * if the old conglomerate # is in the conversion table.
						 * If so, then we get the new conglomerate #, otherwise
						 * we use the compile time conglomerate #.  This
						 * is very simple, though not very elegant.
						 */
						Long pkConglomLong = indexConversionTable.get(
												new Long(fkInfo.refConglomNumber));
						Long fkConglomLong = indexConversionTable.get(
										new Long(fkInfo.fkConglomNumbers[index]));
						if (pkConglomLong == null)
						{
							pkConglom = fkInfo.refConglomNumber;
						}
						else
						{
							pkConglom = pkConglomLong.longValue();
						}
						if (fkConglomLong == null)
						{
							fkConglom = fkInfo.fkConglomNumbers[index];
						}
						else
						{
							fkConglom = fkConglomLong.longValue();
						}
					}
					bulkValidateForeignKeysCore(
							tc, cm, fkInfoArray[i], fkConglom, pkConglom, 
							fkInfo.fkConstraintNames[index], fullTemplate);
				}
			}
			else
			{
				/*
				** We have a FKInfo for each foreign key we are
				** checking.  Note that there are no primary key
				** checks on insert, so we can always reference
				** element[0] in the current FKInfo structure.
				*/ 
				if (SanityManager.DEBUG)
				{
					SanityManager.ASSERT(fkInfo.type == FKInfo.FOREIGN_KEY, 
						""error, expected to only check foreign keys on insert"");
				}
				Long fkConglom = indexConversionTable.get(
										new Long(fkInfo.fkConglomNumbers[0]));
				bulkValidateForeignKeysCore(
						tc, cm, fkInfoArray[i], fkConglom.longValue(),
						fkInfo.refConglomNumber, fkInfo.fkConstraintNames[0],
                        fullTemplate);
			}
		}
	}"
27,67,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.GenericRIChecker,,getScanController,,Long,"Long,conglomNumber",128,128,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java#L128,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/GenericRIChecker.java,,close,"protected ScanController getScanController(long conglomNumber,
											   StaticCompiledOpenConglomInfo scoci,
											   DynamicCompiledOpenConglomInfo dcoci, ExecRow searchRow)
		throws StandardException
	{
		int				isoLevel = getRICheckIsolationLevel();
		ScanController 	scan;
		Long			hashKey = new Long(conglomNumber);

		/*
		** If we haven't already opened this scan controller,
		** we'll open it now and stick it in the hash table.
		*/
		if ((scan = scanControllers.get(hashKey)) == null)
		{
			setupQualifierRow(searchRow);
			scan = 
                tc.openCompiledScan(
                      false,                       				// hold 
                      0, 										// read only
                      TransactionController.MODE_RECORD,		// row locking
					  isoLevel,
                      (FormatableBitSet)null, 							// retrieve all fields
                      indexQualifierRow.getRowArray(),    		// startKeyValue
                      ScanController.GE,            			// startSearchOp
                      null,                         			// qualifier
                      indexQualifierRow.getRowArray(),    		// stopKeyValue
                      ScanController.GT,             			// stopSearchOp 
					  scoci,
					  dcoci
                      );
			scanControllers.put(hashKey, scan);
		}
		else
		{
			/*
			** If the base row is the same row as the previous	
			** row, this call to setupQualfierRow is redundant,
			** but it is safer this way so we'll take the
			** marginal performance hit (marginal relative
			** to the index scans that we are making).
			*/
			setupQualifierRow(searchRow);
			scan.reopenScan(
                      indexQualifierRow.getRowArray(),    	// startKeyValue
                      ScanController.GE,            		// startSearchOp
                      null,                         		// qualifier
                      indexQualifierRow.getRowArray(), 		// stopKeyValue
                      ScanController.GT             		// stopSearchOp 
                      );
		}

		return scan;
	}"
28,89,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.LOBStreamControl,,copyData,,EOFException,"EOFException,MessageService,getTextMessage",389,389,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java#L389,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java,,close,"synchronized void copyData(InputStream inStream, long length)
            throws IOException, StandardException {
        byte [] data = new byte [bufferSize];
        long sz = 0;
        while (sz < length) {
            int len = (int) Math.min (length - sz, bufferSize);
            len = inStream.read(data, 0, len);
            if (len == -1) {
                if (length != Long.MAX_VALUE) {
                    // We reached EOF before all the requested bytes are read.
                    throw new EOFException(MessageService.getTextMessage(
                            MessageId.STREAM_PREMATURE_EOF,
                            new Long(length), new Long(sz)));
                } else {
                    // End of data, but no length checking.
                    break;
                }
            }
            write(data, 0, len, sz);
            sz += len;
        }
        // If we copied until EOF, and we read more data than the length of the
        // marker, see if we have a Derby end-of-stream marker.
        long curLength = getLength();
        if (length == Long.MAX_VALUE && curLength > 2) {
            byte[] eos = new byte[3];
            // Read the three last bytes, marker is 0xE0 0x00 0x00.
            read(eos, 0, 3, curLength -3);
            if ((eos[0] & 0xFF) == 0xE0 && (eos[1] & 0xFF) == 0x00 &&
                    (eos[2] & 0xFF) == 0x00) {
                // Remove Derby end-of-stream-marker.
                truncate(curLength -3);
            }
        }
    }"
29,92,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.ColumnInfo,,getExpectedVtiColumnTypes,,Integer,"Integer,colTypeInfo,substring",495,495,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/ColumnInfo.java#L495,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/ColumnInfo.java,,close,"public static int[] getExpectedVtiColumnTypes(String columnTypesStr, 
                                                  int noOfColumns) 
    {
        // extract the table column types. Break the comma seperated 
        // column types into java.sql.Types int values from the columnTypes 
        // string that got passed to the import VTI.

        //eg: COLUMN1:1 (java.sql.Types.CHAR) , COLUMN2: -1(LONGVARCHAR) , 
        //COLUMN3 : 2004 (BLOB)

        int[] vtiColumnTypes = new int[noOfColumns];

        // expected column type information is only available 
        // for the columns that are being imported from the file.
        // columns type information is not required when 
        // a column in the data file is not one of the 
        // imported column, just assume they are of VARCHAR type. 
        
        for (int i = 0 ; i < noOfColumns ; i++)
            vtiColumnTypes[i] = java.sql.Types.VARCHAR;

        StringTokenizer st = new StringTokenizer(columnTypesStr , "","");

        while (st.hasMoreTokens()) 
        {
            String colTypeInfo = (st.nextToken()).trim();
            int colTypeOffset = colTypeInfo.indexOf("":"");

            // column names format is ""COLUMN"" + columnNumner
            int colIndex = (new Integer(colTypeInfo.substring(6, 
                                        colTypeOffset))).intValue();
            int colType = (new Integer(colTypeInfo.substring(
                                          colTypeOffset+1))).intValue();

            // column numbers start with 1. Check if user by mistake has 
            // specified a column number that is large than than the 
            // number of columns exist in the file, if that is the case
            // don't assign the type.
            if (colIndex <=  noOfColumns) 
                vtiColumnTypes[colIndex-1] = colType;
            
        }
        
        return vtiColumnTypes;
    }"
30,93,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.RecordId,,lockAttributes,,VirtualLockTable,"VirtualLockTable,attributes,CONTAINERID,put",287,287,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/RecordId.java#L287,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/RecordId.java,,close,"public boolean lockAttributes(int flag, Hashtable<String,Object> attributes)
	{

		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(attributes != null, 
				""cannot call lockProperties with null attribute list"");
			SanityManager.ASSERT(pageId != null,
				""RecordId PageId is null"");
		}

		if ((flag & VirtualLockTable.TABLE_AND_ROWLOCK) == 0)
			return false;

		attributes.put(VirtualLockTable.CONTAINERID, 
					   new Long(pageId.getContainerId().getContainerId()));

		attributes.put(VirtualLockTable.LOCKNAME,
					   ""("" + pageId.getPageNumber() + "","" + recordId + "")"");

		attributes.put(VirtualLockTable.LOCKTYPE, ""ROW"");

		// don't new unnecessary things for now
		// attributes.put(VirtualLockTable.SEGMENTID, new Long(pageId.getContainerId().getSegmentId()));
		// attributes.put(VirtualLockTable.PAGENUM, new Long(pageId.getPageNumber()));
		// attributes.put(VirtualLockTable.PAGENUM, new Long(pageId.getPageNumber()));
		// attributes.put(VirtualLockTable.RECID, new Integer(getId()));

		return true;
	}"
31,100,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedResultSetMetaData,,validColumnNumber,,Util,"Util,generateCsSQLException",337,337,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java#L337,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java,,close,"private void validColumnNumber(int column) throws SQLException {
	  if (column < 1 ||
		        column > getColumnCount() )
			    throw Util.generateCsSQLException(
                      SQLState.COLUMN_NOT_FOUND, new Integer(column));
	}"
32,103,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealRowResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,162,162,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealRowResultSetStatistics.java#L162,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealRowResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeen),
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),
           new Integer(this.rowsReturned),
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
33,105,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.SYSCONGLOMERATESRowFactory,,makeRow,,Long,"Long,conglomNumber,conglomerate,getConglomerateNumber",158,158,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/catalog/SYSCONGLOMERATESRowFactory.java#L158,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/SYSCONGLOMERATESRowFactory.java,,close,"public ExecRow makeRow(TupleDescriptor td, TupleDescriptor parent)
					throws StandardException
	{
		ExecRow    				row;
		DataValueDescriptor		col;
		String					tabID =null;
		Long					conglomNumber = null;
		String					conglomName = null;
		Boolean					supportsIndex = null;
		IndexRowGenerator		indexRowGenerator = null;
		Boolean					supportsConstraint = null;
		String					conglomUUIDString = null;
		String					schemaID = null;
		ConglomerateDescriptor  conglomerate = (ConglomerateDescriptor)td;

		/* Insert info into sysconglomerates */

		if (td != null)
		{
			/* Sometimes the SchemaDescriptor is non-null and sometimes it
			 * is null.  (We can't just rely on getting the schema id from 
			 * the ConglomerateDescriptor because it can be null when
			 * we are creating a new conglomerate.
			 */
			if (parent != null)
			{
				SchemaDescriptor sd = (SchemaDescriptor)parent;
				schemaID = sd.getUUID().toString();	
			}
			else
			{
				schemaID = conglomerate.getSchemaID().toString();	
			}
			tabID = conglomerate.getTableID().toString();
			conglomNumber = new Long( conglomerate.getConglomerateNumber() );
			conglomName = conglomerate.getConglomerateName();
			conglomUUIDString = conglomerate.getUUID().toString();

			supportsIndex = new Boolean( conglomerate.isIndex() );
			indexRowGenerator = conglomerate.getIndexDescriptor();
			supportsConstraint = new Boolean( conglomerate.isConstraint() );
		}

		/* RESOLVE - It would be nice to require less knowledge about sysconglomerates
		 * and have this be more table driven.
		 */

		/* Build the row to insert */
		row = getExecutionFactory().getValueRow(SYSCONGLOMERATES_COLUMN_COUNT);

		/* 1st column is SCHEMAID (UUID - char(36)) */
		row.setColumn(1, new SQLChar(schemaID));

		/* 2nd column is TABLEID (UUID - char(36)) */
		row.setColumn(2, new SQLChar(tabID));

		/* 3rd column is CONGLOMERATENUMBER (long) */
		row.setColumn(3, new SQLLongint(conglomNumber));

		/* 4th column is CONGLOMERATENAME (varchar(128)) 
		** If null, use the tableid so we always
		** have a unique column
		*/
		row.setColumn(4, (conglomName == null) ?
                new SQLVarchar(tabID): new SQLVarchar(conglomName));

		/* 5th  column is ISINDEX (boolean) */
		row.setColumn(5, new SQLBoolean(supportsIndex));

		/* 6th column is DESCRIPTOR
		*  (user type org.apache.derby.catalog.IndexDescriptor)
		*/
		row.setColumn(6,
			new UserType(
						(indexRowGenerator == null ?
							(IndexDescriptor) null :
							indexRowGenerator.getIndexDescriptor()
						)
					)
				);

		/* 7th column is ISCONSTRAINT (boolean) */
		row.setColumn(7, new SQLBoolean(supportsConstraint));

		/* 8th column is CONGLOMERATEID (UUID - char(36)) */
		row.setColumn(8, new SQLChar(conglomUUIDString));

		return row;
	}"
34,111,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,setBytes,,"throw Util.generateCsSQLException(SQLState.BLOB_POSITION_TOO_LARGE,",,920,920,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L920,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"public int setBytes(long pos, byte[] bytes) throws SQLException {
            return setBytes(pos, bytes, 0, bytes.length);
	}"
35,112,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.log,org.apache.derby.impl.store.raw.log.Scan,,getNextRecordForward,,throw logFactory.markCorrupt,,955,955,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/log/Scan.java#L955,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/log/Scan.java,,close,"private LogRecord getNextRecordForward(ArrayInputStream input, 
									 TransactionId tranId,  
									 int groupmask)
		 throws StandardException,  IOException, ClassNotFoundException
	{
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(scanDirection == FORWARD, ""can only called by forward scan"");

		// NOTE:
		//
		// if forward scan, scan is positioned at the first byte of the
		// next record, or the end of file - note the the 'end of file'
		// is defined at the time the scan is initialized.  If we are
		// on the current log file, it may well have grown by now...
		//
		// This is not a problem in reality because the only forward
		// scan on the log now is recovery redo and the log does not
		// grow.  If in the future, a foward scan of the log is used
		// for some other reasons, need to keep this in mind.
		//

		// first we need to make sure the entire log record is on the
		// log, or else this is a fuzzy log end.

		// RESOLVE: can get this from knownGoodLogEnd if this is not the first
		// time getNext is called.  Probably just as fast to call
		// scan.getFilePointer though...
		long recordStartPosition = scan.getFilePointer();

		boolean candidate;

		// if we have filtering, peek at the group and/or the transaction id,
		// do them in one read rather than 2 reads.
		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
		if (tranId != null)
			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);

		int readAmount;			// the number of bytes actually read

		LogRecord lr;

		do
		{
			// this log record is a candidate unless proven otherwise
			candidate = true;
			lr = null;
			readAmount = -1;

			// if we are not right at the end but this position + 4 is at
			// or exceeds the end, we know we don't have a complete log
			// record.  This is the log file and chalk it up as the fuzzy
			// end.
			if (recordStartPosition + 4 > currentLogFileLength)
			{
				// since there is no end of log file marker, we are at the
				// end of the log.
				if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                    {
                        SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                            ""detected fuzzy log end on log file "" + 
                                currentLogFileNumber + 
                            "" record start position "" + recordStartPosition + 
                            "" file length "" + currentLogFileLength);
                    }
                }
				
				//if  recordStartPosition == currentLogFileLength
				//there is NO fuzz, it just a properly ended log 
				//without the end marker. 
				if(recordStartPosition != currentLogFileLength)
					fuzzyLogEnd = true ;

				// don't bother to write the end of log file marker because
				// if it is not overwritten by the next log record then
				// the next time the database is recovered it will come
				// back right here
				return null;
			}

			// read in the length before the log record
			int recordLength = scan.readInt();

			while (recordLength == 0 || recordStartPosition + recordLength +
				   LogToFile.LOG_RECORD_OVERHEAD > currentLogFileLength) 
			{
				// if recordLength is zero or the log record goes beyond the
				// current file, then we have detected the end of a log file.
				//
				// If recordLength == 0 then we know that this log file has either
				// been properly switched or it had a 1/2 written log record which 
				// was subsequently cleared by clearFuzzyEnd.
				//
				// If recordLength != 0 but log record goes beyond the current log
				// file, we have detected a fuzzy end.  This is the last log file
				// since we will clear it by clearFuzzyEnd.

				if (recordLength != 0) // this is a fuzzy log end
				{
					if (SanityManager.DEBUG)
                    {
                        if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        {
                            SanityManager.DEBUG(
                                LogToFile.DBG_FLAG, 
                                ""detected fuzzy log end on log file "" + 
                                    currentLogFileNumber + 
                                "" record start position "" + 
                                    recordStartPosition + 
                                "" file length "" + currentLogFileLength + 
								"" recordLength="" + recordLength );
                        }
                    }

					fuzzyLogEnd = true;
					scan.close();
					scan = null;

					return null;
				}

				// recordLength == 0

				if (SanityManager.DEBUG) 
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                    {
                        if (recordStartPosition + 4 == currentLogFileLength)
                        {
                            SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                                ""detected proper log end on log file "" + 
                                currentLogFileNumber);
                        }
                        else
                        {
                            SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                                    ""detected zapped log end on log file "" + 
                                        currentLogFileNumber +
                                    "" end marker at "" + 
                                        recordStartPosition + 
                                    "" real end at "" + currentLogFileLength);
                        }
                    }
				}
				
				// don't go thru the trouble of switching log file if we
				// have will have gone past stopAt if we want to stop here
				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
				{
					return null;
				}

				//
				// we have a log end marker and we don't want to stop yet, switch
				// log file
				//
				scan.close();

				// set this.currentLogFileNumber
				scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
				if (scan == null) // we have seen the last log file
				{
					return null;
				}

				// scan is position just past the log header
				recordStartPosition = scan.getFilePointer();

                // Verify that the header of the new log file refers
                // to the end of the log record of the previous file
                // (Rest of header has been verified by getLogFileAtBeginning)
				scan.seek(LogToFile
                          .LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
                long previousLogInstant = scan.readLong();
                if (previousLogInstant != knownGoodLogEnd) {
                    // If there is a mismatch, something is wrong and
                    // we return null to stop the scan.  The same
                    // behavior occurs when getLogFileAtBeginning
                    // detects an error in the other fields of the header.
                    if (SanityManager.DEBUG) {
                        if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG)) {
                            SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                                                ""log file "" 
                                                + currentLogFileNumber  
                                                + "": previous log record: ""
                                                + previousLogInstant
                                                + "" known previous log record: ""
                                                + knownGoodLogEnd);
                        }
                    }
                    return null;
				}


				scan.seek(recordStartPosition);

				if (SanityManager.DEBUG) 
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                    {
                        SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                            ""switched to next log file "" + 
                            currentLogFileNumber);
                    }
                }

                // Advance knownGoodLogEnd to make sure that if this
                // log file is the last log file and empty, logging
                // continues in this file, not the old file.
                knownGoodLogEnd = LogCounter.makeLogInstantAsLong
                    (currentLogFileNumber, recordStartPosition);

				// set this.currentLogFileLength
				currentLogFileLength = scan.length();

				if (recordStartPosition+4 >= currentLogFileLength) // empty log file
				{
					if (SanityManager.DEBUG)
                    {
                        if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        {
                            SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                                ""log file "" + currentLogFileNumber + 
                                "" is empty"");
                        }
                    }

					return null;
				}

				// we have successfully switched to the next log file.
				// scan is positioned just before the next log record
				// see if this one is written in entirety
				recordLength = scan.readInt();
			}

			// we know the entire log record is on this log file

			// read the current log instant
			currentInstant = scan.readLong();

			/*check if the current instant happens is less than the last one. 
			 *This can happen if system crashed before writing the log instant
			 *completely. If the instant is partially written it will be less
			 *than the last one and should be the last record that was suppose to
			 *get written. Currentlt preallocated files are filled with zeros,
			 *this should hold good.
			 *Note: In case of Non-preallocated files earlier check with log
			 * file lengths should have found the end. But in prellocated files, log file
			 *length is not sufficiant to find the log end. This check 
			 *is must to find the end in preallocated log files. 
			 */
			if(currentInstant < knownGoodLogEnd)
			{
				fuzzyLogEnd = true ;
				return null;
			}

			// sanity check it 
			if (SanityManager.DEBUG)
			{
				if (LogCounter.getLogFileNumber(currentInstant) !=
					currentLogFileNumber ||
					LogCounter.getLogFilePosition(currentInstant) !=
					recordStartPosition)
					SanityManager.THROWASSERT(
							  ""Wrong LogInstant on log record "" +
								LogCounter.toDebugString(currentInstant) + 
								 "" version real position ("" +
								 currentLogFileNumber + "","" +
								 recordStartPosition + "")"");
			}


			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
			// nothing more can be read.  Else check scan limit
			if (stopAt != LogCounter.INVALID_LOG_INSTANT && currentInstant > stopAt)
			{
				currentInstant = LogCounter.INVALID_LOG_INSTANT;
				return null;			// we went past the stopAt
			}

			// read in the log record
			byte[] data = input.getData();

			if (data.length < recordLength)
			{
				// make a new array of sufficient size and reset the arrary
				// in the input stream
				data = new byte[recordLength];
				input.setData(data);
			}

			// If the log is encrypted, we must do the filtering after
			// reading and decryptiong the record.

			if (logFactory.databaseEncrypted())
			{
				scan.readFully(data, 0, recordLength);
				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
				if (SanityManager.DEBUG)
					SanityManager.ASSERT(len == recordLength);

				input.setLimit(0, len);
			}
			else // no need to decrypt, only get the group and tid if we filter 
			{
				if (groupmask == 0 && tranId == null)
				{
					// no filter, get the whole thing
					scan.readFully(data, 0, recordLength);
					input.setLimit(0, recordLength);
				}
				else
				{
					// Read only enough so that group and the tran id is in
					// the data buffer.  Group is stored as compressed int
					// and tran id is stored as who knows what.  read min
					// of peekAmount or recordLength
					readAmount = (recordLength > peekAmount) ?
						peekAmount : recordLength; 

					// in the data buffer, we now have enough to peek
					scan.readFully(data, 0, readAmount);
					input.setLimit(0, readAmount);
				}
			}

			lr = (LogRecord) input.readObject();
			if (groupmask != 0 || tranId != null)
			{
				if (groupmask != 0 && (groupmask & lr.group()) == 0)
					candidate = false; // no match, throw this log record out 

				if (candidate && tranId != null)
				{
					TransactionId tid = lr.getTransactionId();
					if (!tid.equals(tranId)) // nomatch
						candidate = false; // throw this log record out
				}

				// if this log record is not filtered out, we need to read
				// in the rest of the log record to the input buffer.
				// Except if it is an encrypted database, in which case the
				// entire log record have already be read in for
				// decryption.
				if (candidate && !logFactory.databaseEncrypted())
				{
					// read the rest of the log into the buffer
					if (SanityManager.DEBUG)
						SanityManager.ASSERT(readAmount > 0);

					if (readAmount < recordLength)
					{
						// Need to remember where we are because the log
						// record may have read part of it off the input
						// stream already and that position is lost when we
						// set limit again.
						int inputPosition = input.getPosition();

						scan.readFully(data, readAmount,
									   recordLength-readAmount); 

						input.setLimit(0, recordLength);
						input.setPosition(inputPosition);
					}
				}
			}

			/*check if the logrecord length written before and after the 
			 *log record are equal, if not the end of of the log is reached.
			 *This can happen if system crashed before writing the length field 
			 *in the end of the records completely. If the length is partially
			 *written or not written at all  it will not match with length written 
			 *in the beginning of the log record. Currentlt preallocated files
			 *are filled with zeros, log record length can never be zero; 
			 *if the lengths are not matching, end of the properly written log
			 *is reached.
			 *Note: In case of Non-preallocated files earlier fuzzy case check with log
			 * file lengths should have found the end. But in prellocated files, log file
			 *length is not sufficiant to find the log end. This check 
			 *is must to find the end in preallocated log files. 
			 */
			// read the length after the log record and check it against the
			// length before the log record, make sure we go to the correct
			// place for skipped log record.
			if (!candidate)
				scan.seek(recordStartPosition - 4);
			int checkLength = scan.readInt();
			if (checkLength != recordLength && checkLength < recordLength)
			{


				//lengh written in the end of the log record should be always
				//less then the length written in the beginning if the log
				//record was half written before the crash.
				if(checkLength < recordLength)
				{
					fuzzyLogEnd = true ;
					return null;
				}else
				{
				
					//If checklength > recordLength then it can be not be a partial write
					//probablly it is corrupted for some reason , this should never
					//happen throw error in debug mode. In non debug case , let's
					//hope it's only is wrong and system can proceed. 
						
					if (SanityManager.DEBUG)
					{	
						throw logFactory.markCorrupt
						(StandardException.newException(
							SQLState.LOG_RECORD_CORRUPTED, 
                            new Long(checkLength),
                            new Long(recordLength),
                            new Long(currentInstant),
                            new Long(currentLogFileNumber)));

					}
					
					//In non debug case, do nothing , let's hope it's only
					//length part that is incorrect and system can proceed. 
				}

			}

			// next record start position is right after this record
			recordStartPosition += recordLength + LogToFile.LOG_RECORD_OVERHEAD;
			knownGoodLogEnd = LogCounter.makeLogInstantAsLong
								(currentLogFileNumber, recordStartPosition);


			if (SanityManager.DEBUG)
			{
				if (recordStartPosition != scan.getFilePointer())
					SanityManager.THROWASSERT(
									 ""calculated end "" + recordStartPosition + 
									 "" != real end "" + scan.getFilePointer());
			}
			else
			{
				// seek to the start of the next log record
				scan.seek(recordStartPosition);
			}

			// the scan is now positioned just past this log record and right
			// at the beginning of the next log record


			/** if the current log record is a checksum log record then
			 * using the information available in this record validate
			 * that data in the log file by matching the checksum in 
			 * checksum log record and by recalculating the checksum for the 
			 * specified length of the data in the log file. cheksum values
			 * should match unless the right was incomplete before the crash.
			 */
			if(lr.isChecksum())
			{
				// checksum log record should not be returned to the logger recovery redo
				// routines, it is just used to identify the incomplete log writes.

				candidate = false;
				Loggable op = lr.getLoggable(); 
				if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY) ||
                        SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))

						SanityManager.DEBUG(LogToFile.DBG_FLAG, 
											""scanned "" + ""Null"" + "" : "" + op + 
											"" instant = "" + 
											LogCounter.toDebugString(currentInstant) + 
											"" logEnd = "" +  LogCounter.toDebugString(knownGoodLogEnd));
				}

				ChecksumOperation clop = (ChecksumOperation) op;
				int ckDataLength =  clop.getDataLength(); 
				// resize the buffer to be size of checksum data length if required.
				if (data.length < ckDataLength)
				{
					// make a new array of sufficient size and reset the arrary
					// in the input stream
					data = new byte[ckDataLength];
					input.setData(data);
					input.setLimit(0, ckDataLength);
				}
				
				boolean validChecksum = false;
				// check if the expected number of bytes by the checksum log
				// record actually exist in the file and then verify if checksum
				// is valid to identify any incomplete out of order writes.
				if((recordStartPosition + ckDataLength) <= currentLogFileLength)
				{
					// read the data into the buffer
					scan.readFully(data, 0, ckDataLength);
					// verify the checksum 
					if(clop.isChecksumValid(data, 0 , ckDataLength))
						validChecksum = true;
				}


				if(!validChecksum)
				{
					// declare that the end of the transaction log is fuzzy, checksum is invalid
					// only when the writes are incomplete; this can happen
					// only when writes at the end of the log were partially
					// written before the crash. 

					if (SanityManager.DEBUG)
                    {
                        if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        {
                            SanityManager.DEBUG(
                                LogToFile.DBG_FLAG, 
                                ""detected fuzzy log end on log file while doing checksum checks "" + 
								currentLogFileNumber + 
                                "" checksum record start position "" + recordStartPosition + 
                                "" file length "" + currentLogFileLength + 
								"" checksumDataLength="" + ckDataLength);
                        }
						
					}
					
					fuzzyLogEnd = true;
					scan.close();
					scan = null;
					return null;
				}

				// reset the scan to the start of the next log record
				scan.seek(recordStartPosition);
			}


		} while (candidate == false) ;

		return lr;
	}"
36,116,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedStatement,,setLargeMaxRows,,"throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, new Long(max));",,496,496,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java#L496,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java,,close,"public void setLargeMaxRows(long max) throws SQLException	
	{
		checkStatus();
		if (max < 0L)
		{
			throw newSQLException(SQLState.INVALID_MAX_ROWS_VALUE, new Long(max));
		}
		this.maxRows = max;
	}"
37,118,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedResultSet,,getColumnType,,"throw newSQLException(SQLState.COLUMN_NOT_FOUND,",,355,355,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java#L355,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java,,close,"final int getColumnType(int columnIndex) throws SQLException {
		if (!isOnInsertRow) checkOnRow(); // first make sure there's a row
		
		if (columnIndex < 1 ||
		    columnIndex > resultDescription.getColumnCount())
			throw newSQLException(SQLState.COLUMN_NOT_FOUND, 
                         new Integer(columnIndex));

		return resultDescription.getColumnDescriptor(columnIndex).getType().getJDBCTypeId();
	}"
38,131,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SQLLongint,,getObject,,Long,"Long,value",135,135,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SQLLongint.java#L135,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SQLLongint.java,,close,"public Object	getObject()
	{
		if (isNull())
			return null;
		else
			return new Long(value);
	}"
39,136,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,getBytes,,throw StandardException.newException(,,468,468,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L468,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"public byte[] getBytes(long startPos, int length)
        throws SQLException
    {
        //call checkValidity to exit by throwing a SQLException if
        //the Blob object has been freed by calling free() on it
        checkValidity();
        
        boolean pushStack = false;
        try
        {
            if (startPos < 1)
                throw StandardException.newException(
                    SQLState.BLOB_BAD_POSITION, new Long(startPos));
            if (length < 0)
                throw StandardException.newException(
                    SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer(length));

            byte[] result;
            // if the blob is materialized
            if (materialized) {
                 result = new byte [length];
                 int sz = control.read (result, 0, result.length, startPos - 1);
                 if (sz == -1) {
                     InterruptStatus.restoreIntrFlagIfSeen();
                     return new byte [0];
                 }
                 if (sz < length) {
                     byte [] tmparray = new byte [sz];
                     System.arraycopy (result, 0, tmparray, 0, sz);
                     result = tmparray;
                 }
                 InterruptStatus.restoreIntrFlagIfSeen();
            }
            else // we have a stream
            {
                synchronized (getConnectionSynchronization())
                {
                    EmbedConnection ec = getEmbedConnection();
                    pushStack = !ec.isClosed();
                    if (pushStack)
                        setupContextStack();

                    setBlobPosition(startPos-1);
                    // read length bytes into a string
                    result = new byte[length];
                    int n = InputStreamUtil.readLoop(myStream,result,0,length);
                    /*
                     According to the spec, if there are only n < length bytes
                     to return, we should just return these bytes. Rather than
                     return them in an array of size length, where the trailing
                     bytes are not initialized, and the user cannot tell how
                     many bytes were actually returned, we should return an
                     array of n bytes.
                     */
                    if (n < length)
                    {
                        byte[] result2 = new byte[n];
                        System.arraycopy(result,0,result2,0,n);

                        restoreIntrFlagIfSeen(pushStack, ec);

                        return result2;
                    }

                    restoreIntrFlagIfSeen(pushStack,ec);
                }
            }


            return result;
        }
        catch (StandardException e)
        {  // if this is a setPosition exception then we ran out of Blob
            if (e.getMessageId().equals(SQLState.BLOB_LENGTH_TOO_LONG))
                e = StandardException.newException(
                    SQLState.BLOB_POSITION_TOO_LARGE, new Long(startPos));
            throw handleMyExceptions(e);
        }
        catch (Throwable t)
        {
			throw handleMyExceptions(t);
        }
        finally
        {
            if (pushStack)
                restoreContextStack();
        }

    }"
40,138,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.BTreeController,,insert,,throw StandardException.newException(,,1361,1361,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/BTreeController.java#L1361,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/BTreeController.java,,close,"public int insert(DataValueDescriptor[] row) 
         throws StandardException
    {

		if (isClosed())
        {
            if (getHold())
            {
                reopen();
            }
            else
            {
                throw StandardException.newException(
                            SQLState.BTREE_IS_CLOSED,
                            new Long(err_containerid));
            } 
        }

        if (SanityManager.DEBUG)
        {
            SanityManager.ASSERT(this.container != null);
        }

		return doIns(row);
	}"
41,145,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.LoadError,,dataAfterStopDelimiter,,PublicAPI,"PublicAPI,wrapStandardException",54,54,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/LoadError.java#L54,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/LoadError.java,,close,"static SQLException dataAfterStopDelimiter(int lineNumber, int columnNumber) {
		return PublicAPI.wrapStandardException(
			   StandardException.newException(SQLState.DATA_AFTER_STOP_DELIMITER,
											  new Integer(lineNumber),new Integer(columnNumber)));				 	
	}"
42,156,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.jdbc,org.apache.derby.iapi.jdbc.DRDAServerStarter,,boot,,Object,"Object,server,serverConstructor,newInstance",214,214,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/jdbc/DRDAServerStarter.java#L214,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/jdbc/DRDAServerStarter.java,,close,"public void boot(boolean create,
                     java.util.Properties properties)
    {
        if( server != null)
        {
            if (SanityManager.DEBUG)
                SanityManager.THROWASSERT( ""Network server starter module booted twice."");
            return;
        }
        // Load the server class indirectly so that Derby does not require the network code
        try
        {
            serverClass = Class.forName( serverClassName);
        }
        catch( ClassNotFoundException cnfe)
        {
            Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_FIND, serverClassName);
            return;
        }
        catch( java.lang.Error e)
        {
            Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_CLASS_LOAD,
                                    serverClassName,
                                    e.getMessage());
            return;
        }
        try
        {
            Constructor  serverConstructor;
            try
            {
                serverConstructor = AccessController.doPrivileged(
			      new PrivilegedExceptionAction<Constructor>() {
						  public Constructor run() throws NoSuchMethodException, SecurityException
						  {
							  if (listenAddress == null)
								  return serverClass.getConstructor(
                                      new Class[]{String.class, String.class});
							  else
								  return
									  serverClass.getConstructor(new
										  Class[] {java.net.InetAddress.class,
												   Integer.TYPE,
                                                   String.class,
                                                   String.class});
                          }
					  }
				  );
            }
            catch( PrivilegedActionException e)
            {
                Exception e1 = e.getException();
                Monitor.logTextMessage(
									   MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e1.getMessage());
				e.printStackTrace(Monitor.getStream().getPrintWriter());
                return;

            }
            
            findStartStopMethods(serverClass);
            
			if (listenAddress == null) {
				server = serverConstructor.newInstance(
                    new Object[]{userArg, passwordArg});
            } else {
				server = serverConstructor.newInstance(new Object[]
					{listenAddress, new Integer(portNumber),
                     userArg, passwordArg});
            }

            serverThread = Monitor.getMonitor().getDaemonThread( this, ""NetworkServerStarter"", false);
            serverThread.start();
        }
        catch( Exception e)
        {
			Monitor.logTextMessage( MessageId.CONN_NETWORK_SERVER_START_EXCEPTION, e.getMessage());
			server = null;
			e.printStackTrace(Monitor.getStream().getPrintWriter());
        }
    }"
43,160,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.conglomerate,org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController,,fetch,,StandardException,"StandardException,newException",354,354,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java#L354,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java,,close,"public boolean fetch(
    RowLocation             loc, 
    DataValueDescriptor[]   row, 
    FormatableBitSet                 validColumns) 
		throws StandardException
	{
        if (open_conglom.isClosed())
        {
            if (open_conglom.getHold())
            {
                if (open_conglom.isClosed())
                    open_conglom.reopen();
            }
            else
            {
                throw(
                    StandardException.newException(
                        SQLState.HEAP_IS_CLOSED, 
                        open_conglom.getConglomerate().getId()));
            }
        }

        if (SanityManager.DEBUG)
        {
            // Make sure valid columns are in the list.  The RowUtil
            // call is too expensive to make in a released system for
            // every fetch.
            int invalidColumn = 
                RowUtil.columnOutOfRange(
                    row, validColumns, open_conglom.getFormatIds().length);

            if (invalidColumn >= 0)
            {
                throw(StandardException.newException(
                        SQLState.HEAP_TEMPLATE_MISMATCH,
                        new Long(invalidColumn), 
                        new Long(open_conglom.getFormatIds().length)));
            }
        }

        // Get the record handle out of its wrapper.

        RowPosition pos = 
            open_conglom.getRuntimeMem().get_scratch_row_position();

        getRowPositionFromRowLocation(loc, pos);

        if (!open_conglom.latchPage(pos))
        {
            return(false);
        }


        // Do not get U row lock - only get X or S.  There is no good point
        // currently to convert the U lock to an S lock, we don't know when
        // the calling code is through with the lock.
        // RESOLVE (mikem) - talk to language and see if it is worth it to
        //     get U lock and have language call back when we should take
        //     appropriate action on the U lock.

        if (open_conglom.isForUpdate())
        {
            open_conglom.lockPositionForWrite(pos, true);
        }
        else
        {
            open_conglom.lockPositionForRead(
                pos, (RowPosition) null, false, true);
        }

        if (pos.current_page == null)
        {
            // The page is not latched after locking the row. This happens if
            // the row was deleted while we were waiting for the lock. Return
            // false to indicate that the row is no longer valid. (DERBY-4676)
            return false;
        }

        // Fetch the row.
        // RESOLVE (STO061) - don't know whether the fetch is for update or not.
        //
        // RESOLVE (mikem) - get rid of new here.
        boolean ret_val = 
            (pos.current_page.fetchFromSlot(
                pos.current_rh, pos.current_slot, 
                row, 
                new FetchDescriptor(
                    row.length, validColumns, (Qualifier[][]) null), 
                false) != null);

        // RESOLVE (mikem) - should be some way to hide this in the unlock call,
        // and just always make the unlock call.

        if (!open_conglom.isForUpdate())
            open_conglom.unlockPositionAfterRead(pos);

        pos.current_page.unlatch();

        return(ret_val);
	}"
44,166,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMAccessManager,,conglomCacheRemoveEntry,,CacheableConglomerate conglom_entry = (CacheableConglomerate),,524,524,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java#L524,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java,,close,"void conglomCacheRemoveEntry(long conglomid)
        throws StandardException
    {
        CacheableConglomerate conglom_entry = (CacheableConglomerate)
            conglom_cache.findCached(new Long(conglomid));

        if (conglom_entry != null) {
            conglom_cache.remove(conglom_entry);
        }
    }"
45,176,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.sort,org.apache.derby.impl.store.access.sort.MergeSort,,openSortRowSource,,mergeRuns.addElement(new Long(containerId));,,299,299,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java#L299,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java,,close,"public ScanControllerRowSource openSortRowSource(TransactionManager tran)
			throws StandardException
	{
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(state == STATE_DONE_INSERTING);

		ScanControllerRowSource rowSource = null;

		if (mergeRuns == null || mergeRuns.size() == 0)
		{
			// There were no merge runs so we can just return
			// the rows from the sort buffer.
			scan = new SortBufferRowSource(sortBuffer, tran, sortObserver, false, sortBufferMax);
			rowSource = (ScanControllerRowSource)scan;

			// The scan now owns the sort buffer
			sortBuffer = null;
		}
		else
		{
			// Dump the rows in the sort buffer to a merge run.
			long containerId = createMergeRun(tran, sortBuffer);
			mergeRuns.addElement(new Long(containerId));

			// If there are more merge runs than we can sort
			// at once with our sort buffer, we have to reduce
			// the number of merge runs
			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
				mergeRuns.size() > sortBuffer.capacity())	
				multiStageMerge(tran);

			// There are now few enough merge runs to sort
			// at once, so create a rowSource for them.
			MergeScanRowSource msRowSource = 
				new MergeScanRowSource(this, tran, sortBuffer, mergeRuns, sortObserver, false);
			if (!msRowSource.init(tran))
            {
                throw StandardException.newException(
                        SQLState.SORT_COULD_NOT_INIT);
            }
			scan = msRowSource;
			rowSource = msRowSource;

			// The scan now owns the sort buffer and merge runs.
			sortBuffer = null;
			mergeRuns = null;
		}

		// Ready to start retrieving rows.
		this.state = STATE_SCANNING;

		return rowSource;
	}"
46,178,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,truncate,,throw Util.generateCsSQLException(,,1017,1017,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L1017,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"public void truncate(long len)
                                        throws SQLException
	{
            if (len > length())
                throw Util.generateCsSQLException(
                    SQLState.BLOB_LENGTH_TOO_LONG, new Long(len));
            try {
                if (materialized) {
                    control.truncate (len);
                }
                else {
                    setBlobPosition(0); // copy from the beginning
                    control = new LOBStreamControl (getEmbedConnection());
                    control.copyData (myStream, len);
                    myStream.close();
                    streamLength = -1;
                    materialized = true;
                }
            }
            catch (IOException e) {
                throw Util.setStreamFailure (e);
            }
            catch (StandardException se) {
                throw Util.generateCsSQLException (se);
            }
	}"
47,181,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,position,,throw StandardException.newException(,,629,629,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L629,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"public long position(byte[] pattern, long start)
        throws SQLException
    {
        //call checkValidity to exit by throwing a SQLException if
        //the Blob object has been freed by calling free() on it
        checkValidity();
        
        boolean pushStack = false;

        try
        {
            if (start < 1)
                throw StandardException.newException(
                    SQLState.BLOB_BAD_POSITION, new Long(start));
            if (pattern == null)
                throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
            if (pattern.length == 0)
                return start; // match DB2's SQL LOCATE function

            synchronized (getConnectionSynchronization())
            {
                EmbedConnection ec = getEmbedConnection();

                pushStack = !ec.isClosed();
                if (pushStack)
                    setupContextStack();

                long pos = setBlobPosition(start -1);
                // look for first character
                int lookFor = pattern[0];
                long curPos;
                int c;
                while (true)
                {
                    c = read(pos++); // Note the position increment.
                    if (c == -1) { // run out of stream
                        restoreIntrFlagIfSeen(pushStack, ec);
                        return -1;
                    }
                    if (c == lookFor)
                    {
                        curPos = pos;
                        if (checkMatch(pattern, pos)) {
                            restoreIntrFlagIfSeen(pushStack, ec);
                            return curPos;
                        } else
                            pos = setBlobPosition(curPos);
                    }
                }
            }
        }
        catch (StandardException e) {
            throw handleMyExceptions(e);
        }
        catch (Throwable t)
        {
			throw handleMyExceptions(t);
        }
        finally
        {
            if (pushStack)
                restoreContextStack();
        }

    }"
48,183,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMAccessManager,,conglomCacheFind,,Long         conglomid_obj = new Long(conglomid);,,464,464,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java#L464,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java,,close,"Conglomerate conglomCacheFind(
    TransactionManager  xact_mgr,
    long                conglomid)
        throws StandardException
    {
        Conglomerate conglom       = null;
        Long         conglomid_obj = new Long(conglomid);

        CacheableConglomerate cache_entry =
            (CacheableConglomerate) conglom_cache.find(conglomid_obj);

        if (cache_entry != null) {
            conglom = cache_entry.getConglom();
            conglom_cache.release(cache_entry);
        }

        return(conglom);
    }"
49,191,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.xplain,org.apache.derby.impl.sql.execute.xplain.XPLAINUtil,,extractScanProps,,Integer,"Integer,descriptor,vp_property,setNo_visited_pages",305,305,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java#L305,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,,close,"public static XPLAINScanPropsDescriptor extractScanProps(
                     XPLAINScanPropsDescriptor descriptor,
                     Properties scanProps){

         
         // Heap Scan Info Properties
         // extract scan type with the help of the international message service 
         String scan_type = """";
         String scan_type_property = scanProps.getProperty(
                 MessageService.getTextMessage(SQLState.STORE_RTS_SCAN_TYPE));
         if (scan_type_property!=null){
             if(scan_type_property.equalsIgnoreCase(
                 MessageService.getTextMessage(SQLState.STORE_RTS_HEAP))){
                 scan_type = SCAN_HEAP;
             } else 
             if(scan_type_property.equalsIgnoreCase(
                 MessageService.getTextMessage(SQLState.STORE_RTS_SORT))){
                 scan_type = SCAN_SORT;
             } else 
             if(scan_type_property.equalsIgnoreCase(
                 MessageService.getTextMessage(SQLState.STORE_RTS_BTREE))){
                 scan_type = SCAN_BTREE;
             }             
         } else {
             scan_type = null;
         }
         descriptor.setScan_type(scan_type);
         
         // extract the number of visited pages 
         String vp_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_NUM_PAGES_VISITED));
         if(vp_property!=null){
             descriptor.setNo_visited_pages(new Integer(vp_property));
         }
         
         // extract the number of visited rows 
         String vr_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_VISITED));
         if(vr_property!=null){
             descriptor.setNo_visited_rows(new Integer(vr_property));
         }
         
         // extract the number of qualified rows 
         String qr_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_QUALIFIED));
         if(qr_property!=null){
             descriptor.setNo_qualified_rows(new Integer(qr_property));
         }
         
         // extract the number of fetched columns 
         String fc_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_NUM_COLUMNS_FETCHED));
         if(fc_property!=null){
             descriptor.setNo_fetched_columns(new Integer(fc_property));
         }
         
         // extract the number of deleted visited rows 
         String dvr_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_NUM_DELETED_ROWS_VISITED));
         if(dvr_property!=null){
             descriptor.setNo_visited_deleted_rows(new Integer(dvr_property));
         }
         
         // extract the btree height 
         String bth_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_TREE_HEIGHT));
         if(bth_property!=null){
             descriptor.setBtree_height(new Integer(bth_property));
         }
         
         // extract the fetched bit set 
         String bs_property = scanProps.getProperty(
            MessageService.getTextMessage(SQLState.STORE_RTS_COLUMNS_FETCHED_BIT_SET));
         if(bs_property!=null){
             if (bs_property.equalsIgnoreCase(
                 MessageService.getTextMessage(SQLState.STORE_RTS_ALL))){
                 descriptor.setBitset_of_fetched_columns(SCAN_BITSET_ALL);
             } else {
                 descriptor.setBitset_of_fetched_columns(bs_property);
                 
             }
         }
         
         // return the filled descriptor
         return descriptor;
         
     }"
50,193,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,openSortScan,,StandardException,"StandardException,newException",1897,1897,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L1897,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"public ScanController openSortScan(
    long    id,
    boolean hold)
		throws StandardException
	{
		Sort sort;

		// Find the sort in the sorts list, throw an error
		// if it doesn't exist.
		if (sorts == null || id >= sorts.size()
			|| (sort = ((Sort) sorts.get((int) id))) == null)
		{
			throw StandardException.newException(
                    SQLState.AM_NO_SUCH_SORT, new Long(id));
		}

		// Open a scan on it.
		ScanManager sc = sort.openSortScan(this, hold);

		// Keep track of it so we can release on close.
		scanControllers.add(sc);

		return sc;
	}"
51,194,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.LoadError,,recordSeparatorMissing,,PublicAPI,"PublicAPI,wrapStandardException",153,153,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/LoadError.java#L153,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/LoadError.java,,close,"static SQLException recordSeparatorMissing(int lineNumber) {

		return  PublicAPI.wrapStandardException(
				StandardException.newException(SQLState.RECORD_SEPERATOR_MISSING,
											   new Integer(lineNumber)));
	}"
52,198,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedPreparedStatement,,setScale,,"throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));",,1617,1617,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedPreparedStatement.java#L1617,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedPreparedStatement.java,,close,"private void setScale(int parameterIndex, int scale)
		throws SQLException 
	{
		checkStatus();

		if (scale < 0)
			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));
		
		try {

			ParameterValueSet pvs = getParms();

			/* JDBC is one-based, DBMS is zero-based */
			DataValueDescriptor value = pvs.getParameter(parameterIndex - 1);


			int origvaluelen = value.getLength();
			((VariableSizeDataValue)
						value).setWidth(VariableSizeDataValue.IGNORE_PRECISION, 
							scale, 
							false);

			if (value.getLength() < origvaluelen)
			{
				activation.addWarning(StandardException.newWarning(SQLState.LANG_VALUE_TRUNCATED, value.getString()));
			}

		} catch (StandardException t) {
			throw EmbedResultSet.noStateChangeException(t);
		}
	}"
53,208,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SQLBoolean,,getObject,,return new Boolean(value);,,159,159,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SQLBoolean.java#L159,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SQLBoolean.java,,close,"public Object	getObject()
	{
		if (isNull())
			return null;
		else
			return new Boolean(value);
	}"
54,209,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.FileContainer,,createInfoFromLog,,throw StandardException.newException(,,1103,1103,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java#L1103,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java,,close,"private void createInfoFromLog(ByteArray byteArray) 
		 throws StandardException 
	{
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(byteArray != null,
				""setCreateContainerInfoFromLog: ByteArray is null"");
			SanityManager.ASSERT(byteArray.getLength() == 
								 CONTAINER_INFO_SIZE,
				""setCreateContainerInfoFromLog: ByteArrays.length() != CONTAINER_INFO_SIZE"");
		}

		byte[] array = byteArray.getArray();
		
		// now extract the relevant information from array - basically
		// duplicate the code in readHeaderFromArray 
		ArrayInputStream inStream = new ArrayInputStream(array);

		int status = 0;

		try
		{			
			inStream.setLimit(CONTAINER_INFO_SIZE);

			int fid = inStream.readInt();
			if (fid != formatIdInteger)
			{
				// RESOLVE: do something about this when we have > 1 container format
				throw StandardException.newException(
                    SQLState.DATA_UNKNOWN_CONTAINER_FORMAT, 
                    getIdentity(), new Long(fid));
			}

			status = inStream.readInt();
			pageSize = inStream.readInt();
			spareSpace = inStream.readInt();
			minimumRecordSize = inStream.readInt();
			initialPages = inStream.readShort(); 

		}
		catch (IOException ioe)
		{
			throw StandardException.newException(
                    SQLState.DATA_UNEXPECTED_EXCEPTION, ioe);
		}

		// set reusable record id property
		setReusableRecordIdState((status & FILE_REUSABLE_RECORDID) != 0);

		// sanity check to make sure we are not encoutering any
		// dropped Container 
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT((status & FILE_DROPPED) == 0 &&
								 (status & FILE_COMMITTED_DROP) == 0,
				""cannot load a dropped container"");
		}
	}"
55,213,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,createConglomerate,,Long,"Long,conglom,conglomId,tempCongloms,put",817,817,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L817,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"public long createConglomerate(
    String                  implementation,
    DataValueDescriptor[]   template,
    ColumnOrdering[]        columnOrder,
    int[]                   collationIds,
    Properties              properties,
    int                     temporaryFlag)
		throws StandardException
	{
		// Find the appropriate factory for the desired implementation.
		MethodFactory mfactory;
		mfactory = accessmanager.findMethodFactoryByImpl(implementation);
		if (mfactory == null || !(mfactory instanceof ConglomerateFactory))
        {
			throw StandardException.newException(
                    SQLState.AM_NO_SUCH_CONGLOMERATE_TYPE, implementation);
        }
		ConglomerateFactory cfactory = (ConglomerateFactory) mfactory;

		// Create the conglomerate
        // RESOLVE (mikem) - eventually segmentid's will be passed into here
        // in the properties.  For now just use 0.]
		int     segment;
        long    conglomid;
		if ((temporaryFlag & TransactionController.IS_TEMPORARY)
				== TransactionController.IS_TEMPORARY)
        {
			segment = ContainerHandle.TEMPORARY_SEGMENT;
            conglomid = ContainerHandle.DEFAULT_ASSIGN_ID;
        }
		else
        {
			segment = 0; // RESOLVE - only using segment 0
            conglomid = 
                accessmanager.getNextConglomId(
                    cfactory.getConglomerateFactoryId());
        }

        // call the factory to actually create the conglomerate.
        Conglomerate conglom =
            cfactory.createConglomerate(
                this, segment, conglomid, template, 
                columnOrder, collationIds, properties, temporaryFlag);

		long conglomId;
		if ((temporaryFlag & TransactionController.IS_TEMPORARY)
				== TransactionController.IS_TEMPORARY)
		{
			conglomId = nextTempConglomId--;
			if (tempCongloms == null)
				tempCongloms = new HashMap<Long,Conglomerate>();
			tempCongloms.put(new Long(conglomId), conglom);
		}
		else
		{
			conglomId = conglom.getContainerid();

            accessmanager.conglomCacheAddEntry(conglomId, conglom);
		}

		return conglomId;
	}"
56,215,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.sort,org.apache.derby.impl.store.access.sort.MergeSort,,openSortScan,,mergeRuns.addElement(new Long(containerId));,,240,240,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java#L240,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java,,close,"public ScanManager openSortScan(
    TransactionManager tran,
    boolean            hold)
			throws StandardException
	{
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(state == STATE_DONE_INSERTING);

		if (mergeRuns == null || mergeRuns.size() == 0)
		{
			// There were no merge runs so we can just return
			// the rows from the sort buffer.
			scan = new SortBufferScan(this, tran, sortBuffer, hold);

			// The scan now owns the sort buffer
			sortBuffer = null;
		}
		else
		{
			// Dump the rows in the sort buffer to a merge run.
			long containerId = createMergeRun(tran, sortBuffer);
			mergeRuns.addElement(new Long(containerId));

			// If there are more merge runs than we can sort
			// at once with our sort buffer, we have to reduce
			// the number of merge runs
			if (mergeRuns.size() > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN ||
				mergeRuns.size() > sortBuffer.capacity())
					multiStageMerge(tran);

			// There are now few enough merge runs to sort
			// at once, so create a scan for them.
			MergeScan mscan = 
                new MergeScan(
                    this, tran, sortBuffer, mergeRuns, sortObserver, hold);

			if (!mscan.init(tran))
            {
                throw StandardException.newException(
                        SQLState.SORT_COULD_NOT_INIT);
            }
			scan = mscan;

			// The scan now owns the sort buffer and merge runs.
			sortBuffer = null;
			mergeRuns = null;
		}

		// Ready to start retrieving rows.
		this.state = STATE_SCANNING;

		return scan;
	}"
57,216,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.ColumnInfo,,initializeColumnInfo,,Integer,"Integer,dataType,jdbcColumnTypes,add",197,197,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/ColumnInfo.java#L197,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/ColumnInfo.java,,close,"private boolean initializeColumnInfo(String columnPattern)
		throws SQLException
	{
		DatabaseMetaData dmd = conn.getMetaData();
		ResultSet rs = dmd.getColumns(null, 
									  schemaName,
									  tableName,
									  columnPattern);
		boolean foundTheColumn=false;
		while (rs.next())
		{

			// 4.COLUMN_NAME String => column name
			String columnName = rs.getString(4);

			// 5.DATA_TYPE short => SQL type from java.sql.Types
			short dataType = rs.getShort(5);

			// 6.TYPE_NAME String => Data source dependent type name
			String typeName = rs.getString(6);

			
			// 7.COLUMN_SIZE int => column size. For char or date types
			// this is the maximum number of characters, for numeric or
			// decimal types this is precision.
			int columnSize = rs.getInt(7);

			// 9.DECIMAL_DIGITS int => the number of fractional digits
			int decimalDigits = rs.getInt(9);

			// 10.NUM_PREC_RADIX int => Radix (typically either 10 or 2)
			int numPrecRadix = rs.getInt(10);
			foundTheColumn = true;
			if(importExportSupportedType(dataType))
			{

				insertColumnNames.add(columnName);
				String sqlType = typeName + getTypeOption(typeName , columnSize , columnSize , decimalDigits);
				columnTypes.add(sqlType);
                jdbcColumnTypes.add(new Integer(dataType));
				noOfColumns++;

                if ( dataType == java.sql.Types.JAVA_OBJECT )
                {
                    udtClassNames.put( ""COLUMN"" +  noOfColumns, getUDTClassName( dmd, typeName ) );
                }
			}else
			{
				rs.close();
				throw
					LoadError.nonSupportedTypeColumn(columnName,typeName);
			}

		}

		rs.close();
		return foundTheColumn;
	}"
58,250,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.tools.optional,org.apache.derby.impl.tools.optional.DBMDWrapper,,getDummyValue,,Integer,"Integer,Integer,type,TYPE",813,813,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/tools/org/apache/derby/impl/tools/optional/DBMDWrapper.java#L813,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/tools/org/apache/derby/impl/tools/optional/DBMDWrapper.java,,close,"private Object  getDummyValue( Class type )
    {
        if ( String.class == type ) { return """"; }
        else if ( Integer.TYPE == type ) { return new Integer( 1 ); }
        else if ( Short.TYPE == type ) { return new Short( (short) 1 ); }
        else if ( Boolean.TYPE == type ) { return Boolean.TRUE; }
        else { return null; }
    }"
59,258,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedStatement,,setFetchSize,,"throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, new Integer(rows));",,941,941,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java#L941,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java,,close,"public void setFetchSize(int rows) throws SQLException {
		checkStatus();
        if (rows < 0  || (this.getMaxRows() != 0 && 
                             rows > this.getMaxRows()))
        {
	        throw newSQLException(SQLState.INVALID_ST_FETCH_SIZE, new Integer(rows));
        }else if ( rows > 0 ) // ignore the call if the value is zero
            fetchSize = rows;
	}"
60,260,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealProjectRestrictStatistics,,getResultSetTimingsDescriptor,,XPLAINResultSetTimingsDescriptor,XPLAINResultSetTimingsDescriptor,319,319,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealProjectRestrictStatistics.java#L319,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealProjectRestrictStatistics.java,,close,"public Object getResultSetTimingsDescriptor(Object timingID)
    {
        return new XPLAINResultSetTimingsDescriptor(
           (UUID)timingID,
           new Long(this.constructorTime),
           new Long(this.openTime),
           new Long(this.nextTime),
           new Long(this.closeTime),
           new Long(this.getNodeTime()),
           XPLAINUtil.getAVGNextTime( (long)this.nextTime, this.rowsSeen),
           new Long(this.projectionTime),
           new Long(this.restrictionTime),
           null,                          // the temp_cong_create_time
           null                           // the temo_cong_fetch_time
        );
    }"
61,278,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.tools.ij,org.apache.derby.impl.tools.ij.xaHelper,,setDataSourceProperty,,Object,"Object,ds,m,invoke",624,624,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/tools/org/apache/derby/impl/tools/ij/xaHelper.java#L624,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/tools/org/apache/derby/impl/tools/ij/xaHelper.java,,close,"private static void setDataSourceProperty(Object ds, String property, int 
											  value) throws SQLException
	{
		String methodName =
			""set"" + Character.toUpperCase(property.charAt(0)) + property.substring(1);
		try {
			java.lang.reflect.Method m = ds.getClass().getMethod(methodName, INT_P);
			m.invoke(ds, new Object[] {new Integer(value)});
		}
		catch (Exception e)
		{
			throw new SQLException(property + "" ???"" + e.getMessage());
		}		
		
	}"
62,297,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMAccessManager,,getFactoryFromConglomId,,throw StandardException.newException(,,384,384,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java#L384,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMAccessManager.java,,close,"ConglomerateFactory getFactoryFromConglomId(
    long    conglom_id)
		throws StandardException
    {
        try
        {
            return(conglom_map[((int) (0x0f & conglom_id))]);
        }
        catch (java.lang.ArrayIndexOutOfBoundsException e)
        {
            // just in case language passes in a bad factory id.
			throw StandardException.newException(
                SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
                new Long(conglom_id));
        }
    }"
63,300,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedClob,,position,,throw Util.generateCsSQLException(,,319,319,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java#L319,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java,,close,"public long position(String searchStr, long start)
        throws SQLException
    {
        //call checkValidity to exit by throwing a SQLException if
        //the Clob object has been freed by calling free() on it
        checkValidity();
        if (start < 1)
            throw Util.generateCsSQLException(
                            SQLState.BLOB_BAD_POSITION, new Long(start));
        if (searchStr == null)
            throw Util.generateCsSQLException(
                            SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
        if ("""".equals(searchStr))
            return start; // match DB2's SQL LOCATE function

        boolean pushStack = false;
        EmbedConnection ec = getEmbedConnection();
        try
        {

            Object synchronization = getConnectionSynchronization();
            synchronized (synchronization)
            {
                pushStack = !ec.isClosed();
                if (pushStack)
                    setupContextStack();
                int matchCount = 0;
                long pos = start;
                long newStart = -1;
                Reader reader = this.clob.getInternalReader(start);
                char [] tmpClob = new char [4096];
                boolean reset;
                for (;;) {
                    reset = false;
                    int readCount = reader.read (tmpClob);
                    if (readCount == -1) {
                        restoreIntrFlagIfSeen(pushStack, ec);
                        return -1;
                    }
                    for (int clobOffset = 0;
                                clobOffset < readCount; clobOffset++) {
                        if (tmpClob[clobOffset]
                                        == searchStr.charAt(matchCount)) {
                            //find the new starting position in
                            // case this match is unsuccessful
                            if (matchCount != 0 && newStart == -1
                                    && tmpClob[clobOffset]
                                    == searchStr.charAt(0)) {
                                newStart = pos + clobOffset + 1;
                            }
                            matchCount ++;
                            if (matchCount == searchStr.length()) {
                                restoreIntrFlagIfSeen(pushStack, ec);
                                return pos + clobOffset
                                        - searchStr.length() + 1;
                            }
                        }
                        else {
                            if (matchCount > 0) {
                                if (newStart == -1) {
                                    if (matchCount > 1) {
                                        //compensate for increment in the ""for""
                                        clobOffset--;
                                    }
                                    matchCount = 0;
                                    continue;
                                }
                                matchCount = 0;
                                if (newStart < pos) {
                                    pos = newStart;
                                    reader.close();
                                    reader = this.clob.getInternalReader(
                                                                    newStart);
                                    newStart = -1;
                                    reset = true;
                                    break;
                                }
                                clobOffset = (int) (newStart - pos) - 1;
                                newStart = -1;
                                continue;
                            }
                        }
                    }
                    if (!reset) {
                        pos += readCount;
                    }
                }

            }
        } catch (EOFException eofe) {
            restoreIntrFlagIfSeen(pushStack, ec);
            throw Util.generateCsSQLException(
                    SQLState.BLOB_POSITION_TOO_LARGE, eofe, start);
        } catch (IOException ioe) {
            restoreIntrFlagIfSeen(pushStack, ec);
            throw Util.setStreamFailure(ioe);
        } finally {
            if (pushStack) {
                restoreContextStack();
            }
        }
    }"
64,314,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.BasePage,,MakeRecordHandle,,throw StandardException.newException(,,332,332,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/BasePage.java#L332,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/BasePage.java,,close,"public static final RecordHandle MakeRecordHandle(PageKey pkey, int recordHandleConstant)
		 throws StandardException
	{
		if (recordHandleConstant >= RecordHandle.FIRST_RECORD_ID)
        {
			throw StandardException.newException(
                SQLState.DATA_CANNOT_MAKE_RECORD_HANDLE, 
                new Long(recordHandleConstant));
        }

		return new RecordId(pkey, recordHandleConstant);
	}"
65,318,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.InsertResultSet,,updateAllIndexes,,Long,"Long,constants,index,indexConversionTable,indexCIDS,put",2082,2082,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java#L2082,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java,,close,"private void updateAllIndexes(long newHeapConglom, 
								  InsertConstantAction constants, 
								  TableDescriptor td,
								  DataDictionary dd,
								  ExecRow fullTemplate)
		throws StandardException
    {
		int	numIndexes = constants.irgs.length;

		/*
		** If we didn't actually read in any rows, then
		** we don't need to do anything, unless we were
		** doing a replace.
		*/
		if (indexRows == null)
		{
			if (bulkInsertReplace)
			{
				emptyIndexes(newHeapConglom, constants, td, dd, fullTemplate);
			}
			return;
		}

		dd.dropStatisticsDescriptors(td.getUUID(), null, tc);
		long[] newIndexCongloms = new long[numIndexes];

		indexConversionTable = new Hashtable<Long,Long>(numIndexes);
		// Populate each index
		for (int index = 0; index < numIndexes; index++)
		{
			ConglomerateController indexCC;
			Properties properties = new Properties();
			ConglomerateDescriptor cd;
			// Get the ConglomerateDescriptor for the index
			cd = td.getConglomerateDescriptor(constants.indexCIDS[index]);

			
			// Build the properties list for the new conglomerate
			indexCC = tc.openCompiledConglomerate(
                                false,
                                TransactionController.OPENMODE_FORUPDATE,
                                TransactionController.MODE_TABLE,
                                TransactionController.ISOLATION_SERIALIZABLE,
								constants.indexSCOCIs[index],
								indexDCOCIs[index]);

			// Get the properties on the old index
			indexCC.getInternalTablePropertySet(properties);

			/* Create the properties that language supplies when creating the
			 * the index.  (The store doesn't preserve these.)
			 */
			int indexRowLength = indexRows[index].nColumns();
			properties.put(""baseConglomerateId"", Long.toString(newHeapConglom));
			if (cd.getIndexDescriptor().isUnique())
			{
				properties.put(""nUniqueColumns"", 
							   Integer.toString(indexRowLength - 1));
			}
			else
			{
				properties.put(""nUniqueColumns"", 
							   Integer.toString(indexRowLength));
			}

            if ( cd.getIndexDescriptor().isUniqueWithDuplicateNulls() &&
                !cd.getIndexDescriptor().hasDeferrableChecking() )
			{
				properties.put(
                    ""uniqueWithDuplicateNulls"", Boolean.toString(true));
			}

			properties.put(""rowLocationColumn"", 
							Integer.toString(indexRowLength - 1));
			properties.put(""nKeyFields"", Integer.toString(indexRowLength));

			indexCC.close();

			// We can finally drain the sorter and rebuild the index
			// RESOLVE - all indexes are btrees right now
			// Populate the index.
			sorters[index].completedInserts();
			sorters[index] = null;
			rowSources[index] = 
                new CardinalityCounter(tc.openSortRowSource(sortIds[index]));

			newIndexCongloms[index] = 
                tc.createAndLoadConglomerate(
                    ""BTREE"",
                    indexRows[index].getRowArray(),
                    ordering[index],
                    collation[index],
                    properties,
                    TransactionController.IS_DEFAULT,
                    rowSources[index],
                    (long[]) null);

			CardinalityCounter cCount = (CardinalityCounter)rowSources[index];
			long numRows;
			if ((numRows = cCount.getRowCount()) > 0)
			{
				long[] c = cCount.getCardinality();

				for (int i= 0; i < c.length; i++)
				{
					StatisticsDescriptor statDesc = 
						new StatisticsDescriptor(dd, dd.getUUIDFactory().createUUID(),
													cd.getUUID(), td.getUUID(),
													""I"", new
														StatisticsImpl(numRows,
																	   c[i]),
													i + 1);
					dd.addDescriptor(statDesc, null, 
									 DataDictionary.SYSSTATISTICS_CATALOG_NUM,
									 true, tc);					
				}	
				
			}

			/* Update the DataDictionary
			 * RESOLVE - this will change in 1.4 because we will get
			 * back the same conglomerate number
			 *
			 * Update sys.sysconglomerates with new conglomerate #, if the
			 * conglomerate is shared by duplicate indexes, all the descriptors
			 * for those indexes need to be updated with the new number.
			 */
			dd.updateConglomerateDescriptor(
						td.getConglomerateDescriptors(constants.indexCIDS[index]),
						newIndexCongloms[index], tc);

			// Drop the old conglomerate
			tc.dropConglomerate(constants.indexCIDS[index]);

            // We recreated the index, so any old deferred constraints
            // information supported by the dropped index needs to be updated
            // with the new index.
            DeferredDuplicates.updateIndexCID(
                    lcc, constants.indexCIDS[index], newIndexCongloms[index]);

			indexConversionTable.put(new Long(constants.indexCIDS[index]),
									new Long(newIndexCongloms[index]));
		}
	}"
66,324,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedResultSet,,checksBeforeUpdateXXX,,"throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION,",,2458,2458,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java#L2458,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java,,close,"protected void checksBeforeUpdateXXX(String methodName, int columnIndex) throws SQLException {
      checksBeforeUpdateOrDelete(methodName, columnIndex);

      //1)Make sure for updateXXX methods, the column position is not out of range
      ResultDescription rd = theResults.getResultDescription();
      if (columnIndex < 1 || columnIndex > rd.getColumnCount())
        throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION,
					new Integer(columnIndex), String.valueOf(rd.getColumnCount()));

      //2)Make sure the column corresponds to a column in the base table and it is not a derived column
      if (rd.getColumnDescriptor(columnIndex).getSourceTableName() == null)
        throw Util.generateCsSQLException(SQLState.COLUMN_NOT_FROM_BASE_TABLE,
					methodName);

      //3)If column not updatable then throw an exception
      if (!getMetaData().isWritable(columnIndex))
        throw Util.generateCsSQLException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR,
					theResults.getResultDescription().getColumnDescriptor(columnIndex).getName(),
					getCursorName());
	}"
67,331,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.BTreeScan,,reposition,,throw StandardException.newException(,,890,890,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/BTreeScan.java#L890,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/BTreeScan.java,,close,"protected boolean reposition(
    BTreeRowPosition pos,
    boolean          missing_row_for_key_ok)
        throws StandardException
    {
        // RESOLVE (mikem) - performance - we need to do a buffer manager
        // get for every row returned from the scan.  It may be better to
        // allow a reference to the page with no latch (ie. a fixed bit).

        if (this.scan_state != SCAN_INPROGRESS)
        {
            throw StandardException.newException(
                SQLState.BTREE_SCAN_NOT_POSITIONED, 
                new Integer(this.scan_state));
        }

        // positionKey is always valid
        if (SanityManager.DEBUG)
        {
            if (pos.current_positionKey == null)
                SanityManager.THROWASSERT(
                    ""pos.current_rh  = ("" + pos.current_rh + ""), "" +
                    ""pos.current_positionKey = ("" + 
                    pos.current_positionKey + "")."");
        }

        if (pos.current_positionKey == null)
        {
            throw StandardException.newException(
                    SQLState.BTREE_SCAN_INTERNAL_ERROR, 
                    new Boolean(pos.current_rh == null), 
                    new Boolean(pos.current_positionKey == null));
        }

        // If current_rh is non-null, we know the exact physical position of
        // the scan before the latch on the leaf was released. Check if the
        // row is still on that position so that we don't need to renavigate
        // from the root of the B-tree in the common case.
        if (pos.current_rh != null)
        {
            // Reposition to remembered spot on page.

            // Get the page object. If getPage() returns null, the page is
            // not valid (could for instance have been removed by compress
            // table) so we need to reposition by key instead.
            Page page = container.getPage(pos.current_rh.getPageNumber());
            if (page != null) {
                ControlRow row =
                        ControlRow.getControlRowForPage(container, page);
                if (row instanceof LeafControlRow &&
                        !row.page.isRepositionNeeded(pos.versionWhenSaved)) {
                    // No rows have been moved off the page after we released
                    // the latch, and the page is still a leaf page. No need
                    // to reposition by key.
                    pos.current_leaf = (LeafControlRow) row;
                    pos.current_slot = row.page.getSlotNumber(pos.current_rh);
                    pos.current_positionKey = null;
                    return true;
                }
                // We couldn't use the position specified by current_rh, so we
                // need to reposition by key and may find the row on another
                // page. Therefore, give up the latch on this page.
                row.release();
            }
        }

        SearchParameters sp =
                new SearchParameters(
                    pos.current_positionKey, 
                    // this is a full key search, so this arg is not used.
                    SearchParameters.POSITION_LEFT_OF_PARTIAL_KEY_MATCH,
                    init_template, this, false);

        pos.current_leaf = (LeafControlRow)
                    ControlRow.get(this, BTree.ROOTPAGEID).search(sp);

        if (!sp.resultExact && !missing_row_for_key_ok)
        {
            // Did not find key to exactly position on.

            pos.current_leaf.release();
            pos.current_leaf = null;
            return (false);
        }

        pos.current_slot = sp.resultSlot;

        // Need to update current_rh to the new position. current_rh should
        // only be non-null if the row was locked when the position was saved,
        // so we don't set it here if its old value is null.
        if (pos.current_rh != null) {
            pos.current_rh = pos.current_leaf.page.
                    getRecordHandleAtSlot(pos.current_slot);
        }

        pos.current_positionKey = null;

        return(true);
    }"
68,343,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.FileContainer,,createInfoFromProp,,Boolean reusableRecordId = new Boolean(reusableRecordIdParameter);,,1230,1230,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java#L1230,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java,,close,"private void createInfoFromProp(Properties createArgs)
		 throws StandardException
	{
		// Need a TransactionController to get database/service wide properties.
		AccessFactory af = (AccessFactory)
			Monitor.getServiceModule(dataFactory, AccessFactory.MODULE);

		// RESOLVE: sku defectid 2014
		TransactionController tc = 
            (af == null) ? 
                null : 
                af.getTransaction(
                        ContextService.getFactory().getCurrentContextManager());

		pageSize = 
			PropertyUtil.getServiceInt(tc, createArgs,
				Property.PAGE_SIZE_PARAMETER,  
				Limits.DB2_MIN_PAGE_SIZE, 
				Limits.DB2_MAX_PAGE_SIZE, 
				RawStoreFactory.PAGE_SIZE_DEFAULT); 

        // rather than throw error, just automatically set page size to 
        // default if bad value given.
        if ((pageSize != 4096)  &&
            (pageSize != 8192)  &&
            (pageSize != 16384) &&
            (pageSize != 32768))
        {
            pageSize= RawStoreFactory.PAGE_SIZE_DEFAULT;
        }

		spareSpace = 
			PropertyUtil.getServiceInt(tc, createArgs,
				RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, 
				0, 100, 20);

		PreAllocSize = 
			PropertyUtil.getServiceInt(tc, createArgs,
					RawStoreFactory.PRE_ALLOCATE_PAGE,
					MIN_PRE_ALLOC_SIZE,
					MAX_PRE_ALLOC_SIZE,				   
					DEFAULT_PRE_ALLOC_SIZE /* default */);

		// RESOLVE - in the future, we will allow user to set minimumRecordSize
		// to be larger than pageSize, when long rows are supported.
		if (createArgs == null) {
			// if the createArgs is null, then the following method call
			// will get the system properties from the appropriete places.
			// we want to make sure minimumRecrodSize is set to at least
			// the default value MINIMUM_RECORD_SIZE_DEFAULT (12)
			// as set in rawStoreFactory.
			minimumRecordSize = 
				PropertyUtil.getServiceInt(tc,
					RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, 
					RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT, // this is different from the next call
					// reserving 100 bytes for record/field headers
					(pageSize * (1 - spareSpace/100) - 100), 
					RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT);
		} else {
			// if the createArgs is not null, then it has already been set
			// by upper layer or create statement, then, we allow the minimum
			// value of this to be MINIMUM_RECORD_SIZE_MINIMUM (1).
			minimumRecordSize = 
				PropertyUtil.getServiceInt(tc, createArgs,
					RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, 
					RawStoreFactory.MINIMUM_RECORD_SIZE_MINIMUM,  // this is different from the last call
					// reserving 100 bytes for record/field headers
					(pageSize * (1 - spareSpace/100) - 100), 
					RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT);
		}

		// For the following properties, do not check value set in global
		// properties, we only listen to what access has to say about them.
		//
		// whether or not container's recordIds can be reused
		// if container is to be created with a large number of pages
		if (createArgs != null)
		{
			String reusableRecordIdParameter = 
				createArgs.getProperty(RawStoreFactory.PAGE_REUSABLE_RECORD_ID);
			if (reusableRecordIdParameter != null)
			{	
				Boolean reusableRecordId = new Boolean(reusableRecordIdParameter);
				setReusableRecordIdState(reusableRecordId.booleanValue());
			}

			String containerInitialPageParameter =
				createArgs.getProperty(RawStoreFactory.CONTAINER_INITIAL_PAGES);
			if (containerInitialPageParameter != null)
			{
				initialPages = 
					Short.parseShort(containerInitialPageParameter);
				if (initialPages > 1)
				{
					if (initialPages > RawStoreFactory.MAX_CONTAINER_INITIAL_PAGES)
						initialPages = RawStoreFactory.MAX_CONTAINER_INITIAL_PAGES;
				}
			}
		}
	}"
69,351,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.FileContainer,,getContainerProperties,,Boolean bool = new Boolean(isReusableRecordId());,,683,683,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java#L683,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java,,close,"public void getContainerProperties(Properties prop)
		throws StandardException
    {
        // derby.storage.pageSize
        if (prop.getProperty(Property.PAGE_SIZE_PARAMETER) != null)
        {
            prop.put(
                Property.PAGE_SIZE_PARAMETER, 
                Integer.toString(pageSize));
        }

        // derby.storage.minimumRecordSize
        if (prop.getProperty(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER) != 
                null)
        {
            prop.put(
                RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, 
                Integer.toString(minimumRecordSize));
        }

        // derby.storage.pageReservedSpace
        if (prop.getProperty(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER) != 
                null)
        {
            prop.put(
                RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, 
                Integer.toString(spareSpace));
        }

		// derby.storage.reusableRecordId
		if (prop.getProperty(RawStoreFactory.PAGE_REUSABLE_RECORD_ID) != null)
		{
			Boolean bool = new Boolean(isReusableRecordId());
			prop.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID,
					 bool.toString());
		}

		// derby.storage.initialPages
		if (prop.getProperty(RawStoreFactory.CONTAINER_INITIAL_PAGES) != null)
		{
			prop.put(RawStoreFactory.CONTAINER_INITIAL_PAGES,
					 Integer.toString(initialPages));
		}

    }"
70,354,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealUpdateResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,176,176,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealUpdateResultSetStatistics.java#L176,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealUpdateResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           null,                              // the number of opens
           new Integer(this.indexesUpdated),
           null,                           // lock mode
           this.tableLock?""T"":""R"",
           (UUID)parentID,
           null,                             // estimated row count
           null,                             // estimated cost
           new Integer(this.rowCount),
           XPLAINUtil.getYesNoCharFromBoolean(this.deferred),
           null,                              // the input rows
           null,                              // the seen rows left
           null,                              // the seen rows right
           null,                              // the filtered rows
           null,                              // the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
71,359,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialBlob,,setBytes,,Object,"Object,SQLState,makeSQLException,BLOB_INVALID_OFFSET",222,222,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java#L222,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java,,close,"public int setBytes(long pos, byte[] theBytes) throws SQLException {
        return setBytes(pos, theBytes, 0, theBytes.length);
    }"
72,361,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealBasicNoPutResultSetStatistics,,getResultSetTimingsDescriptor,,XPLAINResultSetTimingsDescriptor,XPLAINResultSetTimingsDescriptor,244,244,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java#L244,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java,,close,"public Object getResultSetTimingsDescriptor(Object timingID)
    {
        return new XPLAINResultSetTimingsDescriptor(
           (UUID)timingID,
           new Long(this.constructorTime),
           new Long(this.openTime),
           new Long(this.nextTime),
           new Long(this.closeTime),
           new Long(this.getNodeTime()),
           XPLAINUtil.getAVGNextTime( (long)this.nextTime, this.rowsSeen),
           null,                          // the projection time
           null,                          // the restriction time
           null,                          // the temp_cong_create_time
           null                           // the temo_cong_fetch_time
        );
    }"
73,378,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EncryptedLOBFile,,getBlocks,,IndexOutOfBoundsException,IndexOutOfBoundsException,79,79,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EncryptedLOBFile.java#L79,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EncryptedLOBFile.java,,close,"private byte [] getBlocks (long pos, int len)
                                        throws IOException, StandardException {
        if (len < 0)
            throw new IndexOutOfBoundsException (
                    MessageService.getTextMessage (
                        SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer (len)));
        //starting position of the 1st block
        long startPos = pos - pos % blockSize;
        //end position of last block
        long endPos = (pos + len + blockSize - 1) / blockSize * blockSize;

        byte [] data = new byte [(int) (endPos - startPos)];
        super.seek (startPos);
        super.read (data, 0, data.length);
        return data;
    }"
74,393,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.LoadError,,unexpectedEndOfFile,,PublicAPI,"PublicAPI,wrapStandardException",162,162,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/LoadError.java#L162,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/LoadError.java,,close,"static SQLException unexpectedEndOfFile(int lineNumber) {
    return  PublicAPI.wrapStandardException(
			StandardException.newException(SQLState.UNEXPECTED_END_OF_FILE,
										   new Integer(lineNumber)));
	}"
75,396,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealInsertVTIResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,157,157,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealInsertVTIResultSetStatistics.java#L157,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealInsertVTIResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           null,                              // the number of opens
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           null,                             // estimated row count
           null,                             // estimated cost
           new Integer(this.rowCount),
           XPLAINUtil.getYesNoCharFromBoolean(this.deferred),
           null,                              // the input rows
           null,                              // the seen rows left
           null,                              // the seen rows right
           null,                              // the filtered rows
           null,                              // the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
76,400,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree.index,org.apache.derby.impl.store.access.btree.index.B2IFactory,,readConglomerate,,StandardException,"StandardException,newException",275,275,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/index/B2IFactory.java#L275,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/index/B2IFactory.java,,close,"public Conglomerate readConglomerate(
    TransactionManager  xact_manager,
    ContainerKey        container_key)
		throws StandardException
    {
        Conglomerate    btree      = null;
        ContainerHandle container  = null;
        ControlRow      root       = null;

        try
        {
            // open readonly, with no locks.  Dirty read is ok as it is the
            // responsibility of client code to make sure this data is not
            // changing while being read.  The only changes that currently
            // happen to this data is creation and deletion - no updates
            // ever happen to btree conglomerates.
            container = 
                (xact_manager.getRawStoreXact()).openContainer(
                    container_key,
                    (LockingPolicy) null,
                    ContainerHandle.MODE_READONLY);

            if (container == null)
            {
                // thrown a ""known"" error if the conglomerate does not exist 
                // which is checked for explicitly by callers of the store 
                // interface.

                throw StandardException.newException(
                    SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
                    new Long(container_key.getContainerId()));
            }

            // The conglomerate is located in the control row on the root page.
            root = ControlRow.get(container, BTree.ROOTPAGEID);

            if (SanityManager.DEBUG)
                SanityManager.ASSERT(root.getPage().isLatched());

            // read the Conglomerate from it's entry in the control row.
            btree = (Conglomerate) root.getConglom(B2I.FORMAT_NUMBER);

            if (SanityManager.DEBUG)
                SanityManager.ASSERT(btree instanceof B2I);
        }
        finally
        {

            if (root != null)
                root.release();

            if (container != null)
                container.close();
        }

        // if any error, just return null - meaning can't access the container.

        return(btree);
    }"
77,401,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.services.locks,org.apache.derby.impl.services.locks.Deadlock,,buildException,,Long,"Long,conglomId,containerId,tc,findConglomid,longValue",512,512,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/services/locks/Deadlock.java#L512,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/services/locks/Deadlock.java,,close,"static StandardException buildException(AbstractPool factory,
											Object[] data) {

		Stack chain = (Stack) data[0];
		Dictionary waiters = (Dictionary) data[1];


		LanguageConnectionContext lcc = (LanguageConnectionContext)
			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);

		TableNameInfo tabInfo = null;
		TransactionInfo[] tt = null;
		TransactionController tc = null;

		if (lcc != null) {

			try {
				tc = lcc.getTransactionExecute();
				tabInfo = new TableNameInfo(lcc, false);

				tt = tc.getAccessManager().getTransactionInfo();

			} catch (StandardException se) {
				// just don't get any table info.
			}
		}


		StringBuffer sb = new StringBuffer(200);

		Hashtable<String,Object> attributes = new Hashtable<String,Object>(17);

		String victimXID = null;

		for (int i = 0; i < chain.size(); i++) {
			Object space = chain.elementAt(i);
			if (space instanceof List) {
				List grants = (List) space;

				if (grants.size() != 0) {

					sb.append(""  Granted XID : "");

					for (int j = 0; j < grants.size(); j ++) {

						if (j != 0)
							sb.append("", "");

						Lock gl = (Lock) grants.get(j);

						sb.append(""{"");
						sb.append(gl.getCompatabilitySpace().getOwner());
						sb.append("", "");
						sb.append(gl.getQualifier());
						sb.append(""} "");
					}
					sb.append('\n');
				}
				continue;
			}
			// Information about the lock we are waiting on
			// TYPE |TABLENAME                     |LOCKNAME 
			Lock lock = ((Lock) waiters.get(space));
			
			// see if this lockable object wants to participate
			lock.getLockable().lockAttributes(VirtualLockTable.ALL, attributes);

			addInfo(sb, ""Lock : "", attributes.get(VirtualLockTable.LOCKTYPE));
			if (tabInfo != null) {
				Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
				if (conglomId == null) {
					Long containerId = (Long) attributes.get(VirtualLockTable.CONTAINERID);
					try {
						conglomId = new Long(tc.findConglomid(containerId.longValue()));
					} catch (StandardException se) {
					}
				}
				addInfo(sb, "", "", tabInfo.getTableName(conglomId));
			}
			addInfo(sb, "", "", attributes.get(VirtualLockTable.LOCKNAME));
			sb.append('\n');

			String xid =
				String.valueOf(lock.getCompatabilitySpace().getOwner());
			if (i == 0)
				victimXID = xid;


			addInfo(sb, ""  Waiting XID : {"", xid);
			addInfo(sb, "", "", lock.getQualifier());
			sb.append(""} "");
			if (tt != null) {
				for (int tti = tt.length - 1; tti >= 0; tti--) {
					TransactionInfo ti = tt[tti];

                    // RESOLVE (track 2771) - not sure why 
                    // ti.getTransactionIdString() or ti can return null.
                    if (ti != null)
                    {
                        String idString = ti.getTransactionIdString();

                        if (idString != null && idString.equals(xid)) {

                            addInfo(sb, "", "", ti.getUsernameString());
                            addInfo(sb, "", "", ti.getStatementTextString());
                            break;
                        }
                    }
				}
			}
			sb.append('\n');

			attributes.clear();
		}

		StandardException se = StandardException.newException(SQLState.DEADLOCK, sb.toString(), victimXID);
		se.setReport(factory.deadlockMonitor);
		return se;
	}"
78,406,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.tools.ij,org.apache.derby.impl.tools.ij.ijVectorResult,,<init>,,Integer,"Integer,this,value,w",53,53,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/tools/org/apache/derby/impl/tools/ij/ijVectorResult.java#L53,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/tools/org/apache/derby/impl/tools/ij/ijVectorResult.java,,unknown,
79,415,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedClob,,getSubString,,throw Util.generateCsSQLException(,,207,207,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java#L207,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java,,close,"public String getSubString(long pos, int length) throws SQLException
    {
        //call checkValidity to exit by throwing a SQLException if
        //the Clob object has been freed by calling free() on it
        checkValidity();

        if (pos < 1)
            throw Util.generateCsSQLException(
                SQLState.BLOB_BAD_POSITION, new Long(pos));
        if (length < 0)
            throw Util.generateCsSQLException(
                SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer(length));

        String result;
        // An exception will be thrown if the position is larger than the Clob.
        Reader reader;
        try {
            try {
                reader = this.clob.getInternalReader(pos);
            } catch (EOFException eofe) {
                throw Util.generateCsSQLException(
                        SQLState.BLOB_POSITION_TOO_LARGE, eofe, pos);
            }
            char[] chars = new char[length];
            int charsRead = 0;
            // Read all the characters requested, or until EOF is reached.
            while (charsRead < length) {
                int read = reader.read(chars, charsRead, length - charsRead);
                if (read == -1) {
                    break;
                }
                charsRead += read;
            }
            reader.close();
            // If we have an empty Clob or requested length is zero, return """".
            if (charsRead == 0) {
                result = """";
            } else {
                result = String.copyValueOf(chars, 0, charsRead);
            }
        } catch (IOException ioe) {
            throw Util.setStreamFailure(ioe);
        }
        return result;
    }"
80,418,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedCallableStatement,,registerOutParameter,,"throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));",,215,215,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedCallableStatement.java#L215,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedCallableStatement.java,,close,"public final void registerOutParameter(int parameterIndex, int sqlType)
		throws SQLException 
	{
		checkStatus();

		try {
			getParms().registerOutParameter(parameterIndex-1, sqlType, -1);
		} catch (StandardException e)
		{
			throw EmbedResultSet.noStateChangeException(e);
		}
	}"
81,419,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealJoinResultSetStatistics,,getResultSetTimingsDescriptor,,XPLAINResultSetTimingsDescriptor,XPLAINResultSetTimingsDescriptor,139,139,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealJoinResultSetStatistics.java#L139,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealJoinResultSetStatistics.java,,close,"public Object getResultSetTimingsDescriptor(Object timingID)
    {
        return new XPLAINResultSetTimingsDescriptor(
           (UUID)timingID,
           new Long(this.constructorTime),
           new Long(this.openTime),
           new Long(this.nextTime),
           new Long(this.closeTime),
           new Long(this.getNodeTime()),
           XPLAINUtil.getAVGNextTime(
               (long)this.nextTime, (this.rowsSeenLeft+this.rowsSeenRight)),
           null,                          // the projection time
           null,                          // the restriction time
           null,                          // the temp_cong_create_time
           null                           // the temo_cong_fetch_time
        );
    }"
82,426,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.LOBStreamControl,,isValidOffset,,StandardException,"StandardException,newException",188,188,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java#L188,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java,,close,"private void isValidOffset(int off, int length) throws StandardException {
        if (off < 0 || off > length)
            throw StandardException.newException(
                    SQLState.BLOB_INVALID_OFFSET, new Integer(off));
    }"
83,438,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.log,org.apache.derby.impl.store.raw.log.LogToFile,,recover,,"Monitor.logTextMessage(MessageId.LOG_INCOMPLETE_LOG_RECORD,",,1150,1150,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java#L1150,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java,,close,"public void recover(
    DataFactory         df, 
    TransactionFactory  tf)
		 throws StandardException
	{
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(df != null,  ""data factory == null"");
		}

		checkCorrupt();

		dataFactory     = df;
		
		// initialize the log writer only after the rawstorefactory is available, 
		// log writer requires encryption block size info from rawstore factory 
		// to encrypt checksum log records. 
		if (firstLog != null) 
			logOut = new LogAccessFile(this, firstLog, logBufferSize);

        // If booted in slave mode, the recovery thread is not allowed
        // to do any recovery work until the SlaveFactory tells the
        // thread it may do so. Effectively, the recovery thread is blocked 
        // here until allowedToReadFileNumber != -1. We cannot rely on the
        // inReplicationSlaveMode block in getLogFileAtBeginning
        // because that method is used to open consecutive log files,
        // but not the first one. While the recovery thread waits
        // here, the slave replication thread can perform necessary
        // initialization without causing serialization conflicts.
        if (inReplicationSlaveMode) {
            synchronized (slaveRecoveryMonitor) {
                // Recheck inReplicationSlaveMode==true every time
                // because slave replication may have been stopped
                // while this thread waited on the monitor
                while (inReplicationSlaveMode &&
                       (allowedToReadFileNumber<bootTimeLogFileNumber)) {
                    // Wait until the first log file can be read.
                    if (replicationSlaveException != null) {
                        throw replicationSlaveException;
                    }
                    try {
                        slaveRecoveryMonitor.wait();
                    } catch (InterruptedException ie) {
                        InterruptStatus.setInterrupted();
                    }
                }
            }
        }

		// we don't want to set ReadOnlyDB before recovery has a chance to look
		// at the latest checkpoint and determine that the database is shutdown
		// cleanly.  If the medium is read only but there are logs that need
		// to be redone or in flight transactions, we are hosed.  The logs that
        // are redone will leave dirty pages in the cache.

		if (recoveryNeeded)
		{
			try
			{
				/////////////////////////////////////////////////////////////
				//
				// During boot time, the log control file is accessed and
				// bootTimeLogFileNumber is determined.  LogOut is not set up.
				// bootTimeLogFileNumber is the log file the latest checkpoint
				// lives in,
				// or 1.  It may not be the latest log file (the system may have
				// crashed between the time a new log was generated and the
				// checkpoint log written), that can only be determined at the
				// end of recovery redo.
				//
				/////////////////////////////////////////////////////////////
			
				FileLogger logger = (FileLogger)getLogger();

				/////////////////////////////////////////////////////////////
				//
				// try to find the most recent checkpoint 
				//
				/////////////////////////////////////////////////////////////
				if (checkpointInstant != LogCounter.INVALID_LOG_INSTANT)
                {
					currentCheckpoint = 
                        findCheckpoint(checkpointInstant, logger);
                }

				// if we are only interested in dumping the log, start from the
				// beginning of the first log file
				if (SanityManager.DEBUG)
				{
					if (SanityManager.DEBUG_ON(DUMP_LOG_ONLY))
					{
						currentCheckpoint = null;

						System.out.println(""Dump log only"");

						// unless otherwise specified, 1st log file starts at 1
						String beginLogFileNumber =
							PropertyUtil.getSystemProperty(
                                DUMP_LOG_FROM_LOG_FILE);

						if (beginLogFileNumber != null)
                        {
							bootTimeLogFileNumber = 
                                Long.valueOf(beginLogFileNumber).longValue();
                        }
						else
                        {
							bootTimeLogFileNumber = 1;
                        }
					}
				}

				if (SanityManager.DEBUG)
				{
					if (SanityManager.DEBUG_ON(""setCheckpoint""))
					{
						currentCheckpoint = null;

						System.out.println(""Set Checkpoint."");

						// unless otherwise specified, 1st log file starts at 1
						String checkpointStartLogStr =
							PropertyUtil.getSystemProperty(
                                ""derby.storage.checkpointStartLog"");

						String checkpointStartOffsetStr =
							PropertyUtil.getSystemProperty(
                                ""derby.storage.checkpointStartOffset"");


						if ((checkpointStartLogStr != null) && 
                            (checkpointStartOffsetStr != null))
                        {
							checkpointInstant = 
                                LogCounter.makeLogInstantAsLong(
                                    Long.valueOf(checkpointStartLogStr).longValue(),
                                    Long.valueOf(checkpointStartOffsetStr).longValue());
                        }
                        else
                        {
                            SanityManager.THROWASSERT(
                                ""must set derby.storage.checkpointStartLog and derby.storage.checkpointStartOffset, if setting setCheckpoint."");
                        }

                        currentCheckpoint = 
                            findCheckpoint(checkpointInstant, logger);
					}
				}

				long redoLWM     = LogCounter.INVALID_LOG_INSTANT;
				long undoLWM     = LogCounter.INVALID_LOG_INSTANT;
				long ttabInstant = LogCounter.INVALID_LOG_INSTANT;

				StreamLogScan redoScan = null;
				if (currentCheckpoint != null)
				{	
					Formatable transactionTable = null;

					// RESOLVE: sku 
					// currentCheckpoint.getTransactionTable();

					// need to set the transaction table before the undo
					tf.useTransactionTable(transactionTable);

					redoLWM = currentCheckpoint.redoLWM();
					undoLWM = currentCheckpoint.undoLWM();

					if (transactionTable != null)
						ttabInstant = checkpointInstant;

					if (SanityManager.DEBUG)
					{
						if (SanityManager.DEBUG_ON(DBG_FLAG))
						{
							SanityManager.DEBUG(DBG_FLAG, 
                                ""Found checkpoint at "" +
                                LogCounter.toDebugString(checkpointInstant) + 
                                "" "" + currentCheckpoint.toString());
						}
					}

					firstLogFileNumber = LogCounter.getLogFileNumber(redoLWM);

					// figure out where the first interesting log file is.
					if (LogCounter.getLogFileNumber(undoLWM) < 
                            firstLogFileNumber)
                    {
						firstLogFileNumber = 
                            LogCounter.getLogFileNumber(undoLWM);
                    }


					// if the checkpoint record doesn't have a transaction
					// table, we need to rebuild it by scanning the log from
					// the undoLWM.  If it does have a transaction table, we
					// only need to scan the log from the redoLWM

					redoScan = (StreamLogScan) 
                        openForwardsScan(undoLWM, (LogInstant)null);

				}
				else
				{
					// no checkpoint
					tf.useTransactionTable((Formatable)null);

					long start = 
						LogCounter.makeLogInstantAsLong(
                            bootTimeLogFileNumber, LOG_FILE_HEADER_SIZE);

					// no checkpoint, start redo from the beginning of the 
                    // file - assume this is the first log file
					firstLogFileNumber = bootTimeLogFileNumber;

					redoScan = (StreamLogScan) 
                        openForwardsScan(start, (LogInstant)null);
				}

				// open a transaction that is used for redo and rollback
				RawTransaction recoveryTransaction =
                    tf.startTransaction(
                        rawStoreFactory,
                        ContextService.getFactory().getCurrentContextManager(),
                        AccessFactoryGlobals.USER_TRANS_NAME);

				// make this transaction aware that it is a recovery transaction
				// and don't spew forth post commit work while replaying the log
				recoveryTransaction.recoveryTransaction();

				/////////////////////////////////////////////////////////////
				//
				//  Redo loop - in FileLogger
				//
				/////////////////////////////////////////////////////////////

				// 
				// set log factory state to inRedo so that if redo caused any
				// dirty page to be written from the cache, it won't flush the
				// log since the end of the log has not been determined and we
				// know the log record that caused the page to change has
				// already been written to the log.  We need the page write to
				// go thru the log factory because if the redo has a problem,
				// the log factory is corrupt and the only way we know not to
				// write out the page in a checkpoint is if it check with the
				// log factory, and that is done via a flush - we use the WAL
				// protocol to stop corrupt pages from writing to the disk.
				//
				inRedo = true;	

				long logEnd = 
                    logger.redo(
                        recoveryTransaction, tf, redoScan, redoLWM, 
                        ttabInstant);

				inRedo = false;
				

                // Replication slave: When recovery has completed the
                // redo pass, the database is no longer in replication
                // slave mode and only the recover thread will access
                // this object until recover has complete. We
                // therefore do not need two versions of the log file
                // number anymore. From this point on, logFileNumber
                // is used for all references to the current log file
                // number; bootTimeLogFileNumber is no longer used.
                logFileNumber = bootTimeLogFileNumber;
				
				// if we are only interested in dumping the log, don't alter
				// the database and prevent anyone from using the log
				if (SanityManager.DEBUG)
				{
					if (SanityManager.DEBUG_ON(LogToFile.DUMP_LOG_ONLY))
					{
						Monitor.logMessage(""_____________________________________________________"");
						Monitor.logMessage(""\n\t\t Log dump finished"");
						Monitor.logMessage(""_____________________________________________________"");
                        // just in case, it has not been set anyway
						logOut = null; 

						return;
					}
				}


				/////////////////////////////////////////////////////////////
				//
				// determine where the log ends
				//
				/////////////////////////////////////////////////////////////
				StorageRandomAccessFile theLog = null;


				// if logend == LogCounter.INVALID_LOG_SCAN, that means there 
                // is no log record in the log - most likely it is corrupted in
                // some way ...
				if (logEnd == LogCounter.INVALID_LOG_INSTANT)
				{
					Monitor.logTextMessage(MessageId.LOG_LOG_NOT_FOUND);

					StorageFile logFile = getLogFileName(logFileNumber);

                    if (privExists(logFile))
					{
						// if we can delete this strange corrupted file, do so,
						// otherwise, skip it
                        if (!privDelete(logFile))
						{
							logFile = getLogFileName(++logFileNumber);
						}
					}
					IOException accessException = null;
					try
					{
                        theLog =   privRandomAccessFile(logFile, ""rw"");
					}
					catch (IOException ioe)
					{
						theLog = null;
						accessException = ioe;
					}

                    if (theLog == null || !privCanWrite(logFile))
					{
						if (theLog != null)
							theLog.close();

						theLog = null;
						Monitor.logTextMessage(MessageId.LOG_CHANGED_DB_TO_READ_ONLY);
						if (accessException != null)
							Monitor.logThrowable(accessException);
						ReadOnlyDB = true;
					}
					else
					{
						try
						{
							// no previous log file or previous log position
							if (!initLogFile(
                                    theLog, logFileNumber,
                                    LogCounter.INVALID_LOG_INSTANT))
                            {
								throw markCorrupt(
                                    StandardException.newException(
                                        SQLState.LOG_SEGMENT_NOT_EXIST,
                                        logFile.getPath()));
                            }
						}
						catch (IOException ioe)
						{
							throw markCorrupt(
                                StandardException.newException(
                                    SQLState.LOG_IO_ERROR, ioe));
						}

                        // successfully init'd the log file - set up markers,
                        // and position at the end of the log.
						setEndPosition( theLog.getFilePointer() );
						lastFlush   = endPosition;
						
						//if write sync is true , prellocate the log file
						//and reopen the file in rwd mode.
						if(isWriteSynced)
						{
							//extend the file by wring zeros to it
							preAllocateNewLogFile(theLog);
							theLog.close();
							theLog = openLogFileInWriteMode(logFile);
							//postion the log at the current end postion
							theLog.seek(endPosition);
						}
						
						if (SanityManager.DEBUG)
						{
							SanityManager.ASSERT(
                                endPosition == LOG_FILE_HEADER_SIZE,
                                ""empty log file has wrong size"");
						}
						
						//because we already incrementing the log number
						//here, no special log switch required for
						//backup recoveries.
						logSwitchRequired = false;
					}
				}
				else
				{
					// logEnd is the instant of the next log record in the log
					// it is used to determine the last known good position of
					// the log
					logFileNumber = LogCounter.getLogFileNumber(logEnd);

					ReadOnlyDB = df.isReadOnly();

					StorageFile logFile = getLogFileName(logFileNumber);

					if (!ReadOnlyDB)
					{
						// if datafactory doesn't think it is readonly, we can
						// do some futher test of our own
						IOException accessException = null;
						try
						{
							if(isWriteSynced)
								theLog = openLogFileInWriteMode(logFile);
							else
								theLog = privRandomAccessFile(logFile, ""rw"");
						}
						catch (IOException ioe)
						{
							theLog = null;
                            accessException = ioe;
						}
                        if (theLog == null || !privCanWrite(logFile))
						{
							if (theLog != null)
								theLog.close();
							theLog = null;
							Monitor.logTextMessage(MessageId.LOG_CHANGED_DB_TO_READ_ONLY);
							if (accessException != null)
								Monitor.logThrowable(accessException);	
							ReadOnlyDB = true;
											
						}
					}

					if (!ReadOnlyDB)
					{
						setEndPosition( LogCounter.getLogFilePosition(logEnd) );

						//
						// The end of the log is at endPosition.  Which is where
						// the next log should be appending.
						//
						// if the last log record ends before the end of the
                        // log file, then this log file has a fuzzy end.
                        // Zap all the bytes to between endPosition to EOF to 0.
						//
						// the end log marker is 4 bytes (of zeros)
						//
						// if endPosition + 4 == logOut.length, we have a
                        // properly terminated log file
						//
						// if endPosition + 4 is > logOut.length, there are 0,
                        // 1, 2, or 3 bytes of 'fuzz' at the end of the log. We
                        // can ignore that because it is guaranteed to be
                        // overwritten by the next log record.
						//
						// if endPosition + 4 is < logOut.length, we have a
                        // partial log record at the end of the log.
						//
						// We need to overwrite all of the incomplete log
                        // record, because if we start logging but cannot
                        // 'consume' all the bad log, then the log will truly
                        // be corrupted if the next 4 bytes (the length of the
                        // log record) after that is small enough that the next
                        // time the database is recovered, it will be
                        // interpreted that the whole log record is in the log
                        // and will try to objectify, only to get classNotFound
                        // error or worse.
						//

						//find out if log had incomplete log records at the end.
						if (redoScan.isLogEndFuzzy())
						{
							theLog.seek(endPosition);
							long eof = theLog.length();

							Monitor.logTextMessage(MessageId.LOG_INCOMPLETE_LOG_RECORD,
								logFile, new Long(endPosition), new Long(eof));

							/* Write zeros from incomplete log record to end of file */
							long nWrites = (eof - endPosition)/logBufferSize;
							int rBytes = (int)((eof - endPosition) % logBufferSize);
							byte zeroBuf[]= new byte[logBufferSize];
							
							//write the zeros to file
							while(nWrites-- > 0)
								theLog.write(zeroBuf);
							if(rBytes !=0)
								theLog.write(zeroBuf, 0, rBytes);
							
							if(!isWriteSynced)
								syncFile(theLog);
						}

						if (SanityManager.DEBUG)
						{
							if (theLog.length() != endPosition)
							{
								SanityManager.ASSERT(
                                    theLog.length() > endPosition,
                                    ""log end > log file length, bad scan"");
							}
						}

						// set the log to the true end position,
                        // and not the end of the file

						lastFlush = endPosition;
						theLog.seek(endPosition);
					}
				}

				if (theLog != null)
                {
                    if (logOut != null)
                    {
                        // Close the currently open log file, if there is
                        // one. DERBY-5937.
                        logOut.close();
                    }
					logOut = new LogAccessFile(this, theLog, logBufferSize);
                }
				
				if(logSwitchRequired)
					switchLogFile();


				boolean noInFlightTransactions = tf.noActiveUpdateTransaction();

				if (ReadOnlyDB)
				{
					// in the unlikely event that someone detects we are
					// dealing with a read only db, check to make sure the
					// database is quiesce when it was copied with no unflushed
					// dirty buffer
					if (!noInFlightTransactions)
                    {
						throw StandardException.newException(
                                SQLState.LOG_READ_ONLY_DB_NEEDS_UNDO);
                    }
				}

				/////////////////////////////////////////////////////////////
				//
				// Undo loop - in transaction factory.  It just gets one
				// transaction at a time from the transaction table and calls
				// undo, no different from runtime.
				//
				/////////////////////////////////////////////////////////////

                if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        SanityManager.DEBUG(LogToFile.DBG_FLAG,
                            ""About to call undo(), transaction table ="" +
                            tf.getTransactionTable());
                }

				if (!noInFlightTransactions)
				{
					if (SanityManager.DEBUG)
					{
						if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
							SanityManager.DEBUG(LogToFile.DBG_FLAG,
                                ""In recovery undo, rollback inflight transactions"");
					}

					tf.rollbackAllTransactions(recoveryTransaction, rawStoreFactory);

					if (SanityManager.DEBUG)
					{
						if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
							SanityManager.DEBUG(
                                LogToFile.DBG_FLAG, ""finish recovery undo,"");
					}
				}
				else
				{
					if (SanityManager.DEBUG)
					{
						if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
							SanityManager.DEBUG(LogToFile.DBG_FLAG,
                                ""No in flight transaction, no recovery undo work"");
					}
				}

				/////////////////////////////////////////////////////////////
				//
				// XA prepared xact loop - in transaction factory.  At this
                // point only prepared transactions should be left in the
                // transaction table, all others should have been aborted or
                // committed and removed from the transaction table.  It just
                // gets one transaction at a time from the transaction table,
                // creates a real context and transaction, reclaims locks,
                // and leaves the new xact in the transaction table.
				//
				/////////////////////////////////////////////////////////////

                if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        SanityManager.DEBUG(LogToFile.DBG_FLAG,
                            ""About to call rePrepare(), transaction table ="" +
                            tf.getTransactionTable());
                }

                tf.handlePreparedXacts(rawStoreFactory);

                if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        SanityManager.DEBUG(LogToFile.DBG_FLAG,
                            ""Finished rePrepare(), transaction table ="" +
                            tf.getTransactionTable());
                }

				/////////////////////////////////////////////////////////////
				//
				// End of recovery.
				//
				/////////////////////////////////////////////////////////////

				// recovery is finished.  Close the transaction
				recoveryTransaction.close();


				// notify the dataFactory that recovery is completed,
				// but before the checkpoint is written.
				dataFactory.postRecovery();


				//////////////////////////////////////////////////////////////
				// set the transaction factory short id, we have seen all the
				// trasactions in the log, and at the minimum, the checkpoint
				// transaction will be there.  Set the shortId to the next
				// value.
				//////////////////////////////////////////////////////////////
				tf.resetTranId();

				// do a checkpoint (will flush the log) if there is any rollback
				// if can't checkpoint for some reasons, flush log and carry on
				if (!ReadOnlyDB)
				{
					boolean needCheckpoint = true;

					// if we can figure out there there is very little in the
					// log (less than 1000 bytes), we haven't done any
                    // rollbacks, then don't checkpoint. Otherwise checkpoint.
					if (currentCheckpoint != null && noInFlightTransactions &&
						redoLWM != LogCounter.INVALID_LOG_INSTANT &&
						undoLWM != LogCounter.INVALID_LOG_INSTANT)
					{
						if ((logFileNumber == LogCounter.getLogFileNumber(redoLWM))
							&& (logFileNumber == LogCounter.getLogFileNumber(undoLWM))
							&& (endPosition < (LogCounter.getLogFilePosition(redoLWM) + 1000)))
							needCheckpoint = false;
					}

						if (needCheckpoint && !checkpoint(rawStoreFactory, df, tf, false))
							flush(logFileNumber, endPosition);
				}

				logger.close();

				recoveryNeeded = false;
			}
			catch (IOException ioe)
			{
				if (SanityManager.DEBUG)
					ioe.printStackTrace();

				throw markCorrupt(
                    StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
			}
			catch (ClassNotFoundException cnfe)
			{
				throw markCorrupt(
                    StandardException.newException(
                        SQLState.LOG_CORRUPTED, cnfe));
			}
			catch (StandardException se)
			{
				throw markCorrupt(se);
			}
			catch (Throwable th)
			{
				if (SanityManager.DEBUG)
                {
                    SanityManager.showTrace(th);
					th.printStackTrace();
                }

				throw markCorrupt(
                    StandardException.newException(
                        SQLState.LOG_RECOVERY_FAILED, th));
			}
		}
		else
		{

			tf.useTransactionTable((Formatable)null);

			// set the transaction factory short id
			tf.resetTranId();
		}

        // done with recovery        
        
		/////////////////////////////////////////////////////////////
		// setup checkpoint daemon and cache cleaner
		/////////////////////////////////////////////////////////////
		checkpointDaemon = rawStoreFactory.getDaemon();
		if (checkpointDaemon != null)
        {
			myClientNumber =
                checkpointDaemon.subscribe(this, true /*onDemandOnly */);

            // use the same daemon for the cache cleaner
            dataFactory.setupCacheCleaner(checkpointDaemon);
        }
	}"
84,441,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SQLInteger,,getObject,,Integer,"Integer,value",118,118,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SQLInteger.java#L118,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SQLInteger.java,,close,"public Object	getObject()
	{
		if (isNull())
			return null;
		else
			return new Integer(value);
	}"
85,449,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.BTreeScan,,fetch,,throw StandardException.newException(,,1357,1357,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/BTreeScan.java#L1357,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/BTreeScan.java,,close,"private void fetch(DataValueDescriptor[] row, boolean qualify)
        throws StandardException
    {
        if (scan_state != SCAN_INPROGRESS)
            throw StandardException.newException(
                SQLState.AM_SCAN_NOT_POSITIONED);
        if (SanityManager.DEBUG)
        {
            SanityManager.ASSERT(this.container != null,
                ""BTreeScan.fetch() called on a closed scan."");
        }

        try
        {
            // Get current page of scan, with latch
            if (!reposition(scan_position, false))
            {
                // TODO - write unit test to get here, language always calls
                // isCurrentPositionDeleted() right before calling this, so
                // hard to write .sql test to exercise this.

                throw StandardException.newException(
                        SQLState.AM_RECORD_NOT_FOUND,
                        new Long(err_containerid),
                        new Long(scan_position.current_rh.getPageNumber()),
                        new Long(scan_position.current_rh.getId()));
            }

            if (SanityManager.DEBUG)
            {
                SanityManager.ASSERT(
                    scan_position.current_leaf.page.fetchNumFieldsAtSlot(
                        scan_position.current_slot) > 1);
            }

            scan_position.current_rh = 
                scan_position.current_leaf.page.fetchFromSlot(
                (RecordHandle) null, 
                scan_position.current_slot, row, 
                qualify ? init_fetchDesc : null,
                true);

            // The possibility is that the row at the current position
            // has been marked as deleted (it cannot have been purged
            // since the scan maintains a lock on the row, and purges
            // are always done from system transactions).  I'm not sure
            // what the desired behavior is in this case.  For now,
            // just return null.

            // RESOLVE (mikem) - what should be done here?
            if (scan_position.current_leaf.page.isDeletedAtSlot(
                    scan_position.current_slot))
            {
                if (SanityManager.DEBUG)
                    SanityManager.ASSERT(false, ""positioned on deleted row"");
            }
        }
        finally
        {
            if (scan_position.current_leaf != null)
            {
                // release latch on page.
                savePositionAndReleasePage();
            }
        }

        return;
    }"
86,454,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialClob,,getSubString,,HarmonySerialBlob,"HarmonySerialBlob,Object,SQLState,BLOB_NONPOSITIVE_LENGTH,makeSQLException",107,107,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialClob.java#L107,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialClob.java,,close,"public String getSubString(long pos, int length) throws SQLException {
        checkValidation();
        if (length < 0)
        {
            throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Integer(length)} );
        }
        if (pos < 1 || pos > len || pos + length > len + 1)
        {
            throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );
        }
        try {
            return new String(buf, (int) (pos - 1), length);
        } catch (StringIndexOutOfBoundsException e) {
            throw new SQLException();
        }
    }"
87,470,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.sort,org.apache.derby.impl.store.access.sort.MergeSort,,multiStageMerge,,mergeRuns.addElement(new Long(id));,,735,735,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java#L735,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/sort/MergeSort.java,,close,"private void multiStageMerge(TransactionManager tran)
		throws StandardException
	{
		Enumeration<Long> e;
		//int iterations = 0; // DEBUG (nat)
		int maxMergeRuns = sortBuffer.capacity();

		if (maxMergeRuns > ExternalSortFactory.DEFAULT_MAX_MERGE_RUN)
			maxMergeRuns = ExternalSortFactory.DEFAULT_MAX_MERGE_RUN;

		Vector<Long> subset;
		Vector<Long> leftovers;

		while (mergeRuns.size() > maxMergeRuns)
		{
			// Move maxMergeRuns elements from the merge runs
			// vector into a subset, leaving the rest.
			subset = new Vector<Long>(maxMergeRuns);
			leftovers = new Vector<Long>(mergeRuns.size() - maxMergeRuns);
			e = mergeRuns.elements();
			while (e.hasMoreElements())
			{
				Long containerId = e.nextElement();
				if (subset.size() < maxMergeRuns)
					subset.addElement(containerId);
				else
					leftovers.addElement(containerId);
			}

			/* DEBUG (nat)
			iterations++;
				System.out.println(subset.size() + "" elements in subset"");
				System.out.println(leftovers.size() + "" elements in leftovers"");
				System.out.println(mergeRuns.size() + "" elements in mergeRuns"");
				System.out.println(""maxMergeRuns is "" + maxMergeRuns);
				System.out.println(""iterations = "" + iterations);
			if (subset.size() == 0)
			{
				System.exit(1);
			}
			*/

			mergeRuns = leftovers;

			// Open a merge scan on the subset.
			MergeScanRowSource msRowSource = 
				new MergeScanRowSource(this, tran, sortBuffer, subset, sortObserver, false);

			if (!msRowSource.init(tran))
            {
                throw StandardException.newException(
                        SQLState.SORT_COULD_NOT_INIT);
            }

			// Create and open another temporary stream conglomerate
			// which will become
			// a merge run made up with the merged runs from the subset.
			Transaction rawTran = tran.getRawStoreXact();
			int segmentId = StreamContainerHandle.TEMPORARY_SEGMENT;
			long id = rawTran.addAndLoadStreamContainer(segmentId,
				properties, msRowSource);

			mergeRuns.addElement(new Long(id));

			// Drop the conglomerates in the merge subset
			e = subset.elements();
			while (e.hasMoreElements())
			{
				Long containerId = (Long) e.nextElement();
				rawTran.dropStreamContainer(segmentId, containerId.longValue());
			}
		}
	}"
88,478,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialClob,,truncate,,HarmonySerialBlob,"HarmonySerialBlob,Object,SQLState,BLOB_NONPOSITIVE_LENGTH,makeSQLException",208,208,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialClob.java#L208,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialClob.java,,close,"public void truncate(long length) throws SQLException {
        checkValidation();
        if (length < 0)
        {
            throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Long(length)} );
        }
        if (length > len)
        {
            throw HarmonySerialBlob.makeSQLException( SQLState.BLOB_LENGTH_TOO_LONG, new Object[] {new Long(length)} );
        }
        char[] truncatedBuffer = new char[(int) length];
        System.arraycopy(buf, 0, truncatedBuffer, 0, (int) length);
        buf = truncatedBuffer;
        len = length;
    }"
89,483,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealMaterializedResultSetStatistics,,getResultSetTimingsDescriptor,,XPLAINResultSetTimingsDescriptor,XPLAINResultSetTimingsDescriptor,188,188,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealMaterializedResultSetStatistics.java#L188,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealMaterializedResultSetStatistics.java,,close,"public Object getResultSetTimingsDescriptor(Object timingID)
    {
        return new XPLAINResultSetTimingsDescriptor(
           (UUID)timingID,
           new Long(this.constructorTime),
           new Long(this.openTime),
           new Long(this.nextTime),
           new Long(this.closeTime),
           new Long(this.getNodeTime()),
           XPLAINUtil.getAVGNextTime( (long)this.nextTime, this.rowsSeen),
           null,                          // the projection time
           null,                          // the restriction time
           new Long(this.createTCTime),
           new Long(this.fetchTCTime)
        );
    }"
90,487,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealNestedLoopLeftOuterJoinStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,193,193,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealNestedLoopLeftOuterJoinStatistics.java#L193,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealNestedLoopLeftOuterJoinStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                           // index updates
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // affected rows
           null,                              // deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeenLeft),
           new Integer(this.rowsSeenRight),
           new Integer(this.rowsFiltered),
           new Integer(this.rowsReturned),
           new Integer(this.emptyRightRowsReturned),
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
91,495,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.SequenceUpdater,,getCurrentValueAndAdvance,,Long,"Long,currentValue,null,updateCurrentValueOnDisk",341,341,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java#L341,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java,,close,"public synchronized void getCurrentValueAndAdvance
        ( NumberDataValue returnValue ) throws StandardException
    {
        //
        // We may have to try to get a value from the Sequence Generator twice.
        // The first attempt may fail because we need to pre-allocate a new chunk
        // of values.
        //
        for ( int i = 0; i < 2; i++ )
        {
            //
            // We try to get a sequence number. The SequenceGenerator method is synchronized
            // so only one writer should be in there at a time. Lock contention is possible if
            // someone has selected from SYSSEQUENCES contrary to our advice. In that case,
            // we raise a TOO MUCH CONTENTION exception.
            //
            long[] cvaa = _sequenceGenerator.getCurrentValueAndAdvance();
            
            int status = (int) cvaa[ SequenceGenerator.CVAA_STATUS ];
            long currentValue = cvaa[ SequenceGenerator.CVAA_CURRENT_VALUE ];
            long lastAllocatedValue = cvaa[ SequenceGenerator.CVAA_LAST_ALLOCATED_VALUE ];
            long numberOfValuesAllocated = cvaa[ SequenceGenerator.CVAA_NUMBER_OF_VALUES_ALLOCATED ];
            
            switch ( status )
            {
            case SequenceGenerator.RET_OK:
                returnValue.setValue( currentValue );
                return;
                
            case SequenceGenerator.RET_MARK_EXHAUSTED:
                updateCurrentValueOnDisk( new Long( currentValue ), null );
                returnValue.setValue( currentValue );
                return;
                
            case SequenceGenerator.RET_ALLOCATE_NEW_VALUES:
                
                if ( updateCurrentValueOnDisk( new Long( currentValue ), new Long( lastAllocatedValue ) ) )
                {
                    _sequenceGenerator.allocateNewRange( currentValue, numberOfValuesAllocated );
                }
                break;
            
            default:
                throw unimplementedFeature();
            }
        }

        //
        // If we get here, then we failed to allocate a new sequence number range.
        //
        throw tooMuchContentionException();
    }"
92,497,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.BTreeScan,,delete,,throw StandardException.newException(,,1121,1121,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/BTreeScan.java#L1121,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/BTreeScan.java,,close,"public boolean delete()
        throws StandardException
    {
        boolean     ret_val      = false;

        if (scan_state != SCAN_INPROGRESS)
            throw StandardException.newException(
                SQLState.AM_SCAN_NOT_POSITIONED);

        if (SanityManager.DEBUG)
        {
            SanityManager.ASSERT(this.container != null,
                ""BTreeScan.delete() called on a closed scan."");
            SanityManager.ASSERT(init_forUpdate);
        }

        try
        {
            // Get current page of scan, with latch.
            if (!reposition(scan_position, false))
            {
                throw StandardException.newException(
                        SQLState.AM_RECORD_NOT_FOUND,
                        new Long(err_containerid),
                        new Long(scan_position.current_rh.getPageNumber()),
                        new Long(scan_position.current_rh.getId()));
            }


            if (init_useUpdateLocks)
            {
                // RESOLVE (mikem) - I don't think lockScanRow() is the right
                // thing to call.

                // if we are doing update locking, then we got an U lock on
                // this row when the scan positioned on it, but now that we
                // are doing a delete on the current position we need to upgrade
                // the lock to X.
                boolean latch_released =
                    !this.getLockingPolicy().lockScanRow(
                        this, scan_position,
                        init_lock_fetch_desc,
                        scan_position.current_lock_template,
                        scan_position.current_lock_row_loc,
                        false, init_forUpdate, lock_operation);

                // Special test to see if latch release code works.
                if (SanityManager.DEBUG)
                {
                    latch_released = test_errors(
                            this, ""BTreeScan_delete_useUpdateLocks"",
                            scan_position, getLockingPolicy(),
                            scan_position.current_leaf, latch_released);
                }

                if (latch_released)
                {
                    // lost latch on page in order to wait for row lock.
                    // reposition() will take care of the complexity of
                    // positioning on the correct page if the row has been
                    // moved to another page.
                    if (!reposition(scan_position, false))
                    {
                        throw StandardException.newException(
                                SQLState.AM_RECORD_NOT_FOUND,
                                new Long(err_containerid),
                                new Long(scan_position.current_rh.getPageNumber()),
                                new Long(scan_position.current_rh.getId()));
                    }
                }
            }

            if (SanityManager.DEBUG) 
            {
                // DERBY-2197: Assume no row locking here. If locking policy
                // requires row locking, we would need to obtain a row lock at
                // this point.
                SanityManager.ASSERT(
                    (container.getLockingPolicy().getMode() !=
                         LockingPolicy.MODE_RECORD),
                    ""Locking policy requires row locking."");
            }

            if (scan_position.current_leaf.page.isDeletedAtSlot(
                    scan_position.current_slot)) 
            {
                ret_val = false;
            } 
            else 
            {
                scan_position.current_leaf.page.deleteAtSlot(
                    scan_position.current_slot, true, this.btree_undo);
                ret_val = true;
            }

            // See if we just deleted the last row on the page, in a btree a
            // page with all rows still has 1 left - the control row.
            // Do not reclaim the root page of the btree if there are no 
            // children since we were doing too many post commit actions in a 
            // benchmark which does an insert/commit/delete/commit operations 
            // in a single user system.  Now with this change the work will 
            // move to the user thread which does the insert and finds no space
            // on the root page.  In that case it will try a split, which 
            // automatically first checks if there is committed deleted space
            // that can be reclaimed.

            if (scan_position.current_leaf.page.nonDeletedRecordCount() == 1 &&
                !(scan_position.current_leaf.getIsRoot() && 
                 scan_position.current_leaf.getLevel() == 0)) 
            {
                this.getXactMgr().addPostCommitWork(new BTreePostCommit(
                    this.getXactMgr().getAccessManager(),
                    this.getConglomerate(),
                    scan_position.current_leaf.page.getPageNumber()));
            }
        }
        finally
        {
            if (scan_position.current_leaf != null)
            {
                // release latch on page
                savePositionAndReleasePage();
            }
        }

        return(ret_val);
    }"
93,499,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,getBinaryStream,,throw Util.generateCsSQLException(,,1108,1108,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L1108,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"public java.io.InputStream getBinaryStream()
        throws SQLException
    {
        //call checkValidity to exit by throwing a SQLException if
        //the Blob object has been freed by calling free() on it
        checkValidity();
        
        boolean pushStack = false;
        try
        {
            // if we have byte array, not a stream
            if (materialized)
            {
                java.io.InputStream result = control.getInputStream(0);
                return result;
            }
            else
            { 
                // have a stream

                synchronized (getConnectionSynchronization())
                {
                    EmbedConnection ec = getEmbedConnection();
                    pushStack = !ec.isClosed();
                    if (pushStack)
                        setupContextStack();

                    // Reset stream, because AutoPositionigStream wants to read
                    // the encoded length bytes.
                    myStream.resetStream();
                    UpdatableBlobStream result = new UpdatableBlobStream(
                        this,
                        new AutoPositioningStream (this, myStream, this));

                    restoreIntrFlagIfSeen(pushStack, ec);

                    return result;
                }
            }
        }
        catch (Throwable t)
        {
			throw handleMyExceptions(t);
        }
        finally
        {
            if (pushStack)
                restoreContextStack();
        }
    }"
94,511,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.Heap,,addColumn,,StandardException,"StandardException,newException",427,427,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/Heap.java#L427,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/Heap.java,,close,"public void addColumn(
	TransactionManager  xact_manager,
    int                 column_id,
    Storable            template_column,
    int                 collation_id)
        throws StandardException
    {
        // need to open the container and update the row containing the 
        // serialized format of the heap.  
        ContainerHandle container = null;
        Page            page      = null;
        Transaction     rawtran   = xact_manager.getRawStoreXact();

        try
        {
            container = 
                rawtran.openContainer(
                    id, 
                    rawtran.newLockingPolicy(
                        LockingPolicy.MODE_CONTAINER,
                        TransactionController.ISOLATION_SERIALIZABLE, true),
                    ContainerHandle.MODE_FORUPDATE | 
                        (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));

            if (column_id != format_ids.length)
            {
                if (SanityManager.DEBUG)
                    SanityManager.THROWASSERT(
                        ""column_id = "" + column_id +
                        ""format_ids.length = "" + format_ids.length +
                        ""format_ids = "" + format_ids);

                throw(StandardException.newException(
                        SQLState.HEAP_TEMPLATE_MISMATCH,
                        new Long(column_id), 
                        new Long(this.format_ids.length)));
            }

            // create a new array, and copy old values to it.
            int[] old_format_ids = format_ids;
            format_ids              = new int[old_format_ids.length + 1];
            System.arraycopy(
                old_format_ids, 0, format_ids, 0, old_format_ids.length);

            // add the new column
            format_ids[old_format_ids.length] = 
                template_column.getTypeFormatId();

            // create a new collation array, and copy old values to it.
            int[] old_collation_ids = collation_ids;
            collation_ids           = new int[old_collation_ids.length + 1];
            System.arraycopy(
                old_collation_ids, 0, collation_ids, 0, 
                old_collation_ids.length);

            // add the new column's collation id.
            collation_ids[old_collation_ids.length] =  collation_id;
           
            // row in slot 0 of heap page 1 which is just a single column with
            // the heap entry.
            DataValueDescriptor[] control_row = new DataValueDescriptor[1];
            control_row[0] = this;

            page =
                container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);

            page.updateAtSlot(
                Page.FIRST_SLOT_NUMBER,
                control_row,
                (FormatableBitSet) null);

            page.unlatch();
            page = null;
        }
        finally
        {
            if (container != null)
                container.close();
            if (page !=null)
                page.unlatch();
        }

        return;
    }"
95,513,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialBlob,,truncate,,Object,"Object,SQLState,makeSQLException,BLOB_LENGTH_TOO_LONG",231,231,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java#L231,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java,,close,"public void truncate(long length) throws SQLException {
        if (length > this.len)
        {
            throw makeSQLException( SQLState.BLOB_LENGTH_TOO_LONG, new Object[] {new Long(len)} );
        }
        buf = getBytes(1, (int) length);
        len = length;
    }"
96,530,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealSetOpResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,252,252,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealSetOpResultSetStatistics.java#L252,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealSetOpResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeenLeft),        // the seen rows left
           new Integer(this.rowsSeenRight),       // the seen rows right
           new Integer(this.rowsFiltered),        // the filtered rows
           new Integer(this.rowsReturned),        // the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
97,535,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.CreateSequenceConstantAction,,executeConstantAction,,ddg,"ddg,seqDef,newSequenceDescriptor",119,119,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/CreateSequenceConstantAction.java#L119,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/CreateSequenceConstantAction.java,,close,"public void executeConstantAction(Activation activation)
            throws StandardException {
        SchemaDescriptor schemaDescriptor;
        LanguageConnectionContext lcc =
                activation.getLanguageConnectionContext();
        DataDictionary dd = lcc.getDataDictionary();
        TransactionController tc = lcc.getTransactionExecute();
        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();

        dd.startWriting(lcc);

        schemaDescriptor = DDLConstantAction.getSchemaDescriptorForCreate(dd, activation, _schemaName);

        //
        // Check if this sequence already exists. If it does, throw.
        //
        SequenceDescriptor seqDef = dd.getSequenceDescriptor(schemaDescriptor, _sequenceName);

        if (seqDef != null) {
            throw StandardException.
                    newException(SQLState.LANG_OBJECT_ALREADY_EXISTS,
                            seqDef.getDescriptorType(), _sequenceName);
        }

        seqDef = ddg.newSequenceDescriptor(
                schemaDescriptor,
                dd.getUUIDFactory().createUUID(),
                _sequenceName,
                _dataType,
                new Long( _initialValue ),   // current value
                _initialValue,
                _minValue,
                _maxValue,
                _stepValue,
                _cycle);        // whether the sequence can wrap-around

        dd.addDescriptor(seqDef,
                null,  // parent
                DataDictionary.SYSSEQUENCES_CATALOG_NUM,
                false, // duplicatesAllowed
                tc);
    }"
98,539,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealUnionResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,210,210,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealUnionResultSetStatistics.java#L210,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealUnionResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                           // index updates
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // affected rows
           null,                              // deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeenLeft),
           new Integer(this.rowsSeenRight),
           new Integer(this.rowsFiltered),
           new Integer(this.rowsReturned),
           null,                           // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
99,544,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.services.locks,org.apache.derby.iapi.services.locks.ShExLockable,,lockAttributes,,Long,"Long,VirtualLockTable,attributes,CONTAINERID,put",104,104,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/services/locks/ShExLockable.java#L104,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/services/locks/ShExLockable.java,,close,"public boolean lockAttributes(int flag, Hashtable<String,Object> attributes)
	{
        if((flag & VirtualLockTable.SHEXLOCK) == 0)
            return false;
        // No containerId, but need something in there so it can print
		attributes.put(VirtualLockTable.CONTAINERID, new Long(-1) ); 

		attributes.put(VirtualLockTable.LOCKNAME, this.toString() );

		attributes.put(VirtualLockTable.LOCKTYPE, ""ShExLockable"");

		return true;
	}"
100,549,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.LoadError,,invalidColumnNumber,,PublicAPI,"PublicAPI,wrapStandardException",129,129,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/LoadError.java#L129,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/LoadError.java,,close,"static SQLException invalidColumnNumber(int numberOfColumns) {
		
		return PublicAPI.wrapStandardException(
				StandardException.newException(SQLState.INVALID_COLUMN_NUMBER,
											   new Integer(numberOfColumns)
											   ));
	}"
101,558,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealTableScanStatistics,,getScanPropsDescriptor,,XPLAINScanPropsDescriptor scanRSDescriptor =,,336,336,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealTableScanStatistics.java#L336,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealTableScanStatistics.java,,close,"public Object getScanPropsDescriptor(Object scanPropsID)
    {
        String scanObjectType, scanObjectName;

        if (this.indexName!=null)
        {
            if (this.isConstraint)
            {
                scanObjectType = ""C"";  // constraint
                scanObjectName = this.indexName;
            }
            else
            {
                scanObjectType = ""I"";  // index
                scanObjectName = this.indexName;
            }
        }
        else
        {
            scanObjectType = ""T"";      // table
            scanObjectName = this.tableName;
        }
        
        String isoLevel = XPLAINUtil.getIsolationLevelCode(this.isolationLevel);
        
        XPLAINScanPropsDescriptor scanRSDescriptor =            
              new XPLAINScanPropsDescriptor(
              (UUID)scanPropsID,
              scanObjectName,
              scanObjectType,
              null,             // the scan type: heap, btree, sort
              isoLevel,         // the isolation level
              null,             // the number of visited pages
              null,             // the number of visited rows
              null,             // the number of qualified rows
              null,             // the number of visited deleted rows
              null,             // the number of fetched columns
              null,             // the bitset of fetched columns
              null,             // the btree height
              new Integer(this.fetchSize),
              this.startPosition,
              this.stopPosition,
              this.qualifiers,
              null,             // the next qualifiers
              null,             // the hash key column numbers
              null                 // the hash table size
            );
        
        FormatableProperties props = this.scanProperties;

        return XPLAINUtil.extractScanProps(scanRSDescriptor,props);
    }"
102,560,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.Import,,performImport,,Integer,"Integer,bumpImportCounter",194,194,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/Import.java#L194,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/Import.java,,close,"private static void performImport
        (Connection connection, 
         String schemaName, 
         String insertColumnList, 
         String columnIndexes,
         String tableName, 
         String inputFileName,  
         String  columnDelimiter, 
         String characterDelimiter, 
         String codeset, 
         short replace, 
         boolean lobsInExtFile)
        throws SQLException 
    {
        Integer     importCounter = new Integer( bumpImportCounter() );
        
        try {
            if (connection == null)
                throw LoadError.connectionNull();
            
            
            
            if (tableName == null)
                throw LoadError.entityNameMissing();
            
            
            ColumnInfo columnInfo = new ColumnInfo(connection , schemaName ,
                                                   tableName, insertColumnList, 
                                                   columnIndexes, COLUMNNAMEPREFIX);

            String columnTypeNames = null;
            String udtClassNames = null;
            try {
                columnTypeNames = columnInfo.getColumnTypeNames();
                udtClassNames = columnInfo.getUDTClassNames();
            }
            catch (Throwable t)
            {
                throw formatImportError( (Import) _importers.get( importCounter ), inputFileName, t );
            }

            StringBuffer sb = new StringBuffer(""new "");
            sb.append(""org.apache.derby.impl.load.Import"");
            sb.append(""("") ;
            sb.append(quoteStringArgument(inputFileName));
            sb.append("","") ;
            sb.append(quoteStringArgument(columnDelimiter));
            sb.append("","") ;
            sb.append(quoteStringArgument(characterDelimiter));
            sb.append("","") ;
            sb.append(quoteStringArgument(codeset));
            sb.append("", "");
            sb.append( columnInfo.getExpectedNumberOfColumnsInFile());
            sb.append("", "");
            sb.append(quoteStringArgument(
                    columnInfo.getExpectedVtiColumnTypesAsString()));
            sb.append("", "");
            sb.append(lobsInExtFile);
            sb.append("", "");
            sb.append( importCounter.intValue() );
            sb.append("", "");
            sb.append(quoteStringArgument( columnTypeNames ) );
            sb.append("", "");
            sb.append(quoteStringArgument( udtClassNames ) );
            sb.append("" )"") ;
            
            String importvti = sb.toString();
            
            // delimit the table and schema names with quotes.
            // because they might have been  created as quoted
            // identifiers(for example when reserved words are used, names are quoted)
            
            // Import procedures are to be called with case-senisitive names. 
            // Incase of delimited table names, they need to be passed as defined
            // and when they are not delimited, they need to be passed in upper
            // case, because all undelimited names are stored in the upper case 
            // in the database. 
            
            String entityName = IdUtil.mkQualifiedName(schemaName, tableName);
            
            String insertModeValue;
            if(replace > 0)
                insertModeValue = ""replace"";
            else
                insertModeValue = ""bulkInsert"";
            
            String cNamesWithCasts = columnInfo.getColumnNamesWithCasts();
            String insertColumnNames = columnInfo.getInsertColumnNames();
            if(insertColumnNames !=null)
                insertColumnNames = ""("" + insertColumnNames + "") "" ;
            else
                insertColumnNames = """";
            String insertSql = ""INSERT INTO "" + entityName +  insertColumnNames + 
                "" --DERBY-PROPERTIES insertMode="" + insertModeValue + ""\n"" +
                "" SELECT "" + cNamesWithCasts + "" from "" + 
                importvti + "" AS importvti"" ;
            
            //prepare the import statement to hit any errors before locking the table
            PreparedStatement ips = connection.prepareStatement(insertSql);
            
            //lock the table before perfoming import, because there may 
            //huge number of lockes aquired that might have affect on performance 
            //and some possible dead lock scenarios.
            Statement statement = connection.createStatement();
            String lockSql = ""LOCK TABLE "" + entityName + "" IN EXCLUSIVE MODE"";
            statement.executeUpdate(lockSql);
            
            //execute the import operaton.
            try {
                ips.executeUpdate();
            }
            catch (Throwable t)
            {
                throw formatImportError( (Import) _importers.get( importCounter ), inputFileName, t );
            }
            statement.close();
            ips.close();
        }
        finally
        {
            //
            // The importer was put into a hashtable so that we could look up
            // line numbers for error messages. The Import constructor put
            // the importer in the hashtable. Now garbage collect that entry.
            //
            _importers.remove( importCounter );
        }
    }"
103,561,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.conglomerate,org.apache.derby.impl.store.access.conglomerate.GenericScanController,,repositionScanForUpateOper,,StandardException,"StandardException,newException",247,247,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericScanController.java#L247,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,,close,"private final void repositionScanForUpateOper()
        throws StandardException
    {
        if (scan_state != SCAN_INPROGRESS)
            throw StandardException.newException(
                    SQLState.AM_SCAN_NOT_POSITIONED);


        if (!open_conglom.latchPage(scan_position))
        {
            throw StandardException.newException(
                    SQLState.AM_RECORD_NOT_FOUND, 
                    open_conglom.getContainer().getId(),
                    new Long(scan_position.current_rh.getPageNumber()),
                    new Long(scan_position.current_rh.getId()));
        }

        if (open_conglom.isUseUpdateLocks())
        {
            // we only have an U lock at this point which was acquired when the
            // scan positioned on the row, need to request an
            // X lock before we can actually perform the delete

            open_conglom.lockPositionForWrite(scan_position, true);
        }
    }"
104,571,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedConnection,,addLOBMapping,,"getlobHMObj().put(new Integer(loc), LOBReference);",,3291,3291,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java#L3291,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java,,close,"public int addLOBMapping(Object LOBReference) {
		int loc = getIncLOBKey();
		getlobHMObj().put(new Integer(loc), LOBReference);
		return loc;
	}"
105,576,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedConnection,,setTransactionIsolation,,"throw newSQLException(SQLState.UNIMPLEMENTED_ISOLATION_LEVEL, new Integer(level));",,2240,2240,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java#L2240,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java,,close,"public void setTransactionIsolation(int level) throws SQLException {

		if (level == getTransactionIsolation())
			return;

		// Convert the isolation level to the internal one
		int iLevel;
		switch (level)
		{
		case java.sql.Connection.TRANSACTION_READ_UNCOMMITTED:
			iLevel = TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;
			break;

		case java.sql.Connection.TRANSACTION_READ_COMMITTED:
			iLevel = TransactionControl.READ_COMMITTED_ISOLATION_LEVEL;
			break;

		case java.sql.Connection.TRANSACTION_REPEATABLE_READ:
            iLevel = TransactionControl.REPEATABLE_READ_ISOLATION_LEVEL;
            break;

		case java.sql.Connection.TRANSACTION_SERIALIZABLE:
			iLevel = TransactionControl.SERIALIZABLE_ISOLATION_LEVEL;
			break;
		default:
			throw newSQLException(SQLState.UNIMPLEMENTED_ISOLATION_LEVEL, new Integer(level));
		}

		synchronized(getConnectionSynchronization())
		{
            setupContextStack();
			try {
                LanguageConnectionContext lcc = getLanguageConnection();
                lcc.setIsolationLevel(iLevel);
                InterruptStatus.restoreIntrFlagIfSeen(lcc);
			} catch (StandardException e) {
				throw handleException(e);
			} finally {
				restoreContextStack();
			}
		}
	}"
106,584,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.diag,org.apache.derby.diag.LockTable,,dumpLock,,Long,"Long,conglomId,tc,value,findConglomid,longValue",298,298,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/diag/LockTable.java#L298,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/diag/LockTable.java,,close,"private Hashtable<String,Object> dumpLock(
    Latch                   lock)
        throws StandardException
    {
		Hashtable<String,Object>	attributes = new Hashtable<String,Object>(17);
        Object      lock_type =  lock.getQualifier();


		// 4 things we are interested in from the lockable:
		// containerId, segmentId, pageNum, recId

		Lockable lockable = lock.getLockable();

		// see if this lockable object wants to participate
		if (!lockable.lockAttributes(flag, attributes))
			return null;				

		// if it does, the lockable object must have filled in the following
		// fields
		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null,
			 ""lock table can only represent locks that have a LOCKNAME"");

			SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null,
			 ""lock table can only represent locks that have a LOCKTYPE"");

			if (attributes.get(VirtualLockTable.CONTAINERID) == null &&
				attributes.get(VirtualLockTable.CONGLOMID) == null)
				SanityManager.THROWASSERT(
			 ""lock table can only represent locks that are associated with a container or conglomerate"");
		}

		if (attributes.get(VirtualLockTable.LOCKNAME) == null ||
			attributes.get(VirtualLockTable.LOCKTYPE) == null)
			return null;				// can't deal with this for now

		// if the lock has zero count and is an instance of Lock then it
		// is a lock that has just been released. Therefore do put it into
		// the lock table. This occurs because the Lock object is the real
		// live object in the LockTable. Thus when we copied the lock table
		// it had a non-zero count, but since then it has been released
		// (after we dropped the sync). Note if it is of type ActiveLock
		// with zero count there is stil the chance it has been released.
		// Less likely, but we still need to fix that at some time.
		int lockCount = lock.getCount();
		String state;
		if (lockCount != 0)
			state = ""GRANT"";
		else if (!(lock instanceof org.apache.derby.impl.services.locks.ActiveLock))
			return null;
		else
			state = ""WAIT"";

		Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);

		if (conglomId == null)
		{
			// we need to figure this out
			if (attributes.get(VirtualLockTable.CONTAINERID) == null)
				return null; // can't deal with this for now

			Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
			conglomId = new Long(tc.findConglomid(value.longValue()));
			attributes.put(VirtualLockTable.CONGLOMID, conglomId);
		}

		attributes.put(VirtualLockTable.LOCKOBJ, lock);
		Object owner = lock.getCompatabilitySpace().getOwner();
		attributes.put(VirtualLockTable.XACTID,
					   (owner == null) ? ""<null>"" : owner.toString());
		attributes.put(VirtualLockTable.LOCKMODE, lock_type.toString());

		attributes.put(VirtualLockTable.LOCKCOUNT, Integer.toString(lockCount));

		attributes.put(VirtualLockTable.STATE, state);

		String tableName = tabInfo.getTableName(conglomId);

		attributes.put(VirtualLockTable.TABLENAME, tableName);

		String indexName = tabInfo.getIndexName(conglomId);

		if (indexName != null)
			attributes.put(VirtualLockTable.INDEXNAME, indexName);

		String tableType = tabInfo.getTableType(conglomId);
		attributes.put(VirtualLockTable.TABLETYPE, tableType);
		return attributes;

    }"
107,586,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.LOBStreamControl,,copyUtf8Data,,EOFException,"EOFException,MessageService,getTextMessage",485,485,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java#L485,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java,,close,"synchronized long copyUtf8Data(final InputStream utf8Stream,
                                   final long charLength)
            throws IOException, StandardException {
        long charCount = 0; // Number of chars read
        int offset = 0;     // Where to start looking for the start of a char
        int read = 0;       // Number of bytes read
        final byte[] buf = new byte[bufferSize];
        while (charCount < charLength) {
            int readNow = utf8Stream.read(buf, 0,
                            (int)Math.min(buf.length, charLength - charCount));
            if (readNow == -1) {
                break;
            }
            // Count the characters.
            while (offset < readNow) {
                int c = buf[offset] & 0xFF;
                if ((c & 0x80) == 0x00) { // 8th bit not set (top bit)
                    offset++;
                } else if ((c & 0x60) == 0x40) { // 7th bit set, 6th bit unset
                    // Found char of two byte width.
                    offset += 2;
                } else if ((c & 0x70) == 0x60) { // 7th & 6th bit set, 5th unset
                    // Found char of three byte width.
                    offset += 3;
                } else {
                    // This shouldn't happen, as the data is coming from the
                    // store and is supposed to be well-formed.
                    // If it happens, fail and print some internal information.
                    throw new UTFDataFormatException(""Invalid UTF-8 encoding: ""
                            + Integer.toHexString(c) + "", charCount="" +
                            charCount + "", offset="" + offset);
                }
                charCount++;
            }
            offset -= readNow; // Starting offset for next iteration
            write(buf, 0, readNow, read);
            read += readNow;
        }
        // See if an EOF-marker ended the stream. Don't check if we have fewer
        // bytes than the marker length.
        long curLength = getLength();
        if (curLength > 2) {
            byte[] eos = new byte[3];
            // Read the three last bytes, marker is 0xE0 0x00 0x00.
            read(eos, 0, 3, curLength -3);
            if ((eos[0] & 0xFF) == 0xE0 && (eos[1] & 0xFF) == 0x00 &&
                    (eos[2] & 0xFF) == 0x00) {
                // Remove Derby end-of-stream-marker.
                truncate(curLength -3);
                charCount--;
            }
        }
        if (charLength != Long.MAX_VALUE && charCount != charLength) {
            throw new EOFException(MessageService.getTextMessage(
                    MessageId.STREAM_PREMATURE_EOF,
                    new Long(charLength), new Long(charCount)));
        }
        return charCount;
    }"
108,589,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.replication.slave,org.apache.derby.impl.store.replication.slave.SlaveController$SlaveLogReceiverThread,,handleLogChunk,,StandardException,"StandardException,newException",585,585,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/replication/slave/SlaveController.java#L585,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/replication/slave/SlaveController.java,,close,"private void handleLogChunk(byte[] logChunk)
            throws StandardException{
            logScan.init(logChunk);

            while (logScan.next()){
                if (logScan.isLogFileSwitch()) {
                    logToFile.switchLogFile();
                } else {

                    long localInstant = logToFile.
                        appendLogRecord(logScan.getData(), 
                                        0, 
                                        logScan.getDataLength(), 
                                        null, 
                                        0, 
                                        0);

                    // If the log instant of the received log does not
                    // match with the local log instant, the log
                    // records are not written to the same physical
                    // location in the log files. This is fatal since
                    // log records are identified by their physical
                    // location in the log files.
                    if (logScan.getInstant() != localInstant) {
                        throw StandardException.newException
                            (SQLState.REPLICATION_LOG_OUT_OF_SYNCH,
                             dbname,
                             new Long(LogCounter.
                                      getLogFileNumber(logScan.getInstant())),
                             new Long(LogCounter.
                                      getLogFilePosition(logScan.
                                                         getInstant())),
                             new Long(LogCounter.
                                      getLogFileNumber(localInstant)),
                             new Long(LogCounter.
                                      getLogFilePosition(localInstant)));
                    }
                    highestLogInstant = localInstant;
                }
            }
        }"
109,595,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialBlob,,getBytes,,Object,"Object,SQLState,makeSQLException,BLOB_BAD_POSITION",113,113,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java#L113,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java,,close,"public byte[] getBytes(long pos, int length) throws SQLException {

        if (pos < 1 || pos > len)
        {
            throw makeSQLException( SQLState.BLOB_BAD_POSITION, new Object[] {new Long(pos)} );
        }
        if (length < 0)
        {
            throw makeSQLException( SQLState.BLOB_NONPOSITIVE_LENGTH, new Object[] {new Integer(length)} );
        }

        if (length > len - pos + 1) {
            length = (int) (len - pos + 1);
        }
        byte[] copiedArray = new byte[length];
        System.arraycopy(buf, (int) pos - 1, copiedArray, 0, length);
        return copiedArray;
    }"
110,605,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.Heap,,defragmentConglomerate,,StandardException,"StandardException,newException",1004,1004,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/Heap.java#L1004,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/Heap.java,,close,"public ScanManager defragmentConglomerate(
    TransactionManager              xact_manager,
    Transaction                     rawtran,
    boolean                         hold,
    int                             open_mode,
    int                             lock_level,
    LockingPolicy                   locking_policy,
    int                             isolation_level)
		throws StandardException
	{
        OpenConglomerate open_conglom = new OpenHeap();

        if (open_conglom.init(
                (ContainerHandle) null,
                this,
                this.format_ids,
                this.collation_ids,
                xact_manager,
                rawtran,
                hold,
                open_mode,
                lock_level,
                rawtran.newLockingPolicy(
                    LockingPolicy.MODE_RECORD,
                    TransactionController.ISOLATION_REPEATABLE_READ, true),
                null) == null)
        {
            throw StandardException.newException(
                    SQLState.HEAP_CONTAINER_NOT_FOUND, 
                    new Long(id.getContainerId()));
        }

		HeapCompressScan heap_compress_scan = new HeapCompressScan();

        heap_compress_scan.init(
            open_conglom,
            null,
            null,
            0,
            null,
            null,
            0);

		return(heap_compress_scan);
	}"
111,608,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealInsertResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,206,206,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealInsertResultSetStatistics.java#L206,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealInsertResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           null,                              // the number of opens
           new Integer(this.indexesUpdated),
           null,                           // lock mode
           this.tableLock?""T"":""R"",
           (UUID)parentID,
           null,                             // estimated row count
           null,                             // estimated cost
           new Integer(this.rowCount),
           XPLAINUtil.getYesNoCharFromBoolean(this.deferred),
           null,                              // the input rows
           null,                              // the seen rows left
           null,                              // the seen rows right
           null,                              // the filtered rows
           null,                              // the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
112,610,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,openSortRowSource,,StandardException,"StandardException,newException",1924,1924,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L1924,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"public RowLocationRetRowSource openSortRowSource(long id) 
		 throws StandardException
	{
		Sort sort;

		// Find the sort in the sorts list, throw an error
		// if it doesn't exist.
		if (sorts == null || id >= sorts.size()
			|| (sort = (sorts.get((int) id))) == null)
		{
			throw StandardException.newException(
                    SQLState.AM_NO_SUCH_SORT, new Long(id));
		}

		// Open a scan row source on it.
		ScanControllerRowSource sc = sort.openSortRowSource(this);

		// Keep track of it so we can release on close.
		scanControllers.add( (ScanManager) sc );

		return sc;
	}"
113,616,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.log,org.apache.derby.impl.store.raw.log.Scan,,getNextRecordBackward,,throw logFactory.markCorrupt(,,376,376,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/log/Scan.java#L376,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/log/Scan.java,,close,"private LogRecord getNextRecordBackward(ArrayInputStream input, 
									  TransactionId tranId,  
									  int groupmask) 
		 throws StandardException, IOException, ClassNotFoundException
	{
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(scanDirection == BACKWARD, ""can only called by backward scan"");

		// scan is positioned just past the last byte of the record, or
		// right at the beginning of the file (end of the file header)
		// may need to switch log file

		boolean candidate;
		// if we have filtering, peek at the group and/or the transaction id,
		// do them in one read rather than 2 reads.
		int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
		if (tranId != null)
			peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);

		int readAmount;			// the number of bytes actually read

		LogRecord lr;
		long curpos = scan.getFilePointer();

		do
		{
			// this log record is a candidate unless proven otherwise
			candidate = true; 
			lr = null;
			readAmount = -1;

			if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
			{
				// don't go thru the trouble of switching log file if we
				// will have gone past stopAt
				if (stopAt != LogCounter.INVALID_LOG_INSTANT &&
					LogCounter.getLogFileNumber(stopAt) == currentLogFileNumber)
				{
					if (SanityManager.DEBUG)
                    {
                        if (SanityManager.DEBUG_ON(LogToFile.DBG_FLAG))
                        {
                            SanityManager.DEBUG(LogToFile.DBG_FLAG, 
                                ""stopping at "" + currentLogFileNumber);
                        }
                    }

					return null;  // no more log record
				}
				
				// figure out where the last log record is in the previous
				// log file
				scan.seek(LogToFile.LOG_FILE_HEADER_PREVIOUS_LOG_INSTANT_OFFSET);
				long previousLogInstant = scan.readLong();
				scan.close();

				if (SanityManager.DEBUG)
				{
					SanityManager.ASSERT(previousLogInstant != LogCounter.INVALID_LOG_INSTANT,
									 ""scanning backward beyond the first log file"");
					if (currentLogFileNumber != 
							LogCounter.getLogFileNumber(previousLogInstant) + 1)
						SanityManager.THROWASSERT(
						""scanning backward but get incorrect log file number "" + 
						 ""expected "" + (currentLogFileNumber -1) + 
						 ""get "" +
						 LogCounter.getLogFileNumber(previousLogInstant));

					SanityManager.ASSERT(LogCounter.getLogFilePosition(previousLogInstant) > 
									 LogToFile.LOG_FILE_HEADER_SIZE,
									 ""scanning backward encounter completely empty log file"");

					SanityManager.DEBUG(LogToFile.DBG_FLAG, 
									""scanning backwards from log file "" +
									currentLogFileNumber + "", switch to ("" + 
									LogCounter.getLogFileNumber(previousLogInstant) + "","" +
									LogCounter.getLogFilePosition(previousLogInstant) + "")""
									);
				}

				// log file switch, set this.currentLogFileNumber
				currentLogFileNumber = LogCounter.getLogFileNumber(previousLogInstant);

				scan = logFactory.getLogFileAtPosition(previousLogInstant);

				// scan is located right past the last byte of the last log
				// record in the previous log file.  currentLogFileNumber is
				// set.  We asserted that the scan is not located right at the
				// end of the file header, in other words, there is at least
				// one log record in this log file.
				curpos = scan.getFilePointer();

				// if the log file happens to be empty skip and proceed. 
				// ideally this case should never occur because log switch is
				// not suppose to happen on an empty log file. 
				// But it is safer to put following check incase if it ever
				// happens to avoid any recovery issues. 
				if (curpos == LogToFile.LOG_FILE_HEADER_SIZE)
					continue;
			}

			scan.seek(curpos - 4);
			int recordLength = scan.readInt(); // get the length after the log record

			// calculate where this log record started.
			// include the eight bytes for the long log instant at the front
			// the four bytes of length in the front and the four bytes we just read
			long recordStartPosition = curpos - recordLength -
				LogToFile.LOG_RECORD_OVERHEAD; 

			if (SanityManager.DEBUG)
			{
				if (recordStartPosition < LogToFile.LOG_FILE_HEADER_SIZE)
					SanityManager.THROWASSERT(
								 ""next position "" + recordStartPosition +
								 "" recordLength "" + recordLength + 
								 "" current file position "" + scan.getFilePointer());

				scan.seek(recordStartPosition);

				// read the length before the log record and check it against the
				// length after the log record
				int checkLength = scan.readInt();

				if (checkLength != recordLength)
				{
					long inst = LogCounter.makeLogInstantAsLong(currentLogFileNumber, recordStartPosition);

					throw logFactory.markCorrupt(
                        StandardException.newException(
                            SQLState.LOG_RECORD_CORRUPTED, 
                            new Long(checkLength),
                            new Long(recordLength),
                            new Long(inst),
                            new Long(currentLogFileNumber)));
				}
			}
			else
			{
				// skip over the length in insane
				scan.seek(recordStartPosition+4);
			}

			// scan is positioned just before the log instant
			// read the current log instant - this is the currentInstant if we have not
			// exceeded the scan limit
			currentInstant = scan.readLong();

			if (SanityManager.DEBUG)
			{
				// sanity check the current instant against the scan position
				if (LogCounter.getLogFileNumber(currentInstant) !=
					currentLogFileNumber ||
					LogCounter.getLogFilePosition(currentInstant) !=
					recordStartPosition)
					SanityManager.THROWASSERT(
								 ""Wrong LogInstant on log record "" +
								LogCounter.toDebugString(currentInstant) + 
								 "" version real position ("" +
								 currentLogFileNumber + "","" +
								 recordStartPosition + "")"");
			}


			// if stopAt == INVALID_LOG_INSTANT, no stop instant, read till
			// nothing more can be read.  Else check scan limit
			if (currentInstant < stopAt && stopAt != LogCounter.INVALID_LOG_INSTANT)
			{
				currentInstant = LogCounter.INVALID_LOG_INSTANT;
				return null;	// we went past the stopAt
			}


			byte[] data = input.getData();

			if (data.length < recordLength)
			{
				// make a new array of sufficient size and reset the arrary
				// in the input stream
				data = new byte[recordLength];
				input.setData(data);
			}

			// If the log is encrypted, we must do the filtering after reading
			// and decrypting the record.
			if (logFactory.databaseEncrypted())
			{
				scan.readFully(data, 0, recordLength);
				int len = logFactory.decrypt(data, 0, recordLength, data, 0);
				if (SanityManager.DEBUG)
					SanityManager.ASSERT(len == recordLength);
				input.setLimit(0, recordLength);
			}
			else // no need to decrypt, only get the group and tid if we filter 
			{
				if (groupmask == 0 && tranId == null)
				{
					// no filter, get the whole thing
					scan.readFully(data, 0, recordLength);
					input.setLimit(0, recordLength);
				}
				else
				{
					// Read only enough so that group and the tran id is in
					// the data buffer.  Group is stored as compressed int
					// and tran id is stored as who knows what.  read min
					// of peekAmount or recordLength
					readAmount = (recordLength > peekAmount) ?
						peekAmount : recordLength; 

					// in the data buffer, we now have enough to peek
					scan.readFully(data, 0, readAmount);
					input.setLimit(0, readAmount);
				}
			}

			lr = (LogRecord) input.readObject();

			// skip the checksum log records, there is no need to look at them 
			// during backward scans. They are used only in forwardscan during recovery. 
			if(lr.isChecksum())
			{
				candidate = false; 
			}else if (groupmask != 0 || tranId != null)
			{

				// skip the checksum log records  
				if(lr.isChecksum())
					candidate = false; 

				if (candidate && groupmask != 0 && (groupmask & lr.group()) == 0)
					candidate = false; // no match, throw this log record out 

				if (candidate && tranId != null)
				{
					TransactionId tid = lr.getTransactionId();
					if (!tid.equals(tranId)) // nomatch
						candidate = false; // throw this log record out
				}

				// if this log record is not filtered out, we need to read
				// in the rest of the log record to the input buffer.
				// Except if it is an encrypted database, in which case the
				// entire log record have already be read in for
				// decryption.
				if (candidate && !logFactory.databaseEncrypted())
				{
					// read the rest of the log into the buffer
					if (SanityManager.DEBUG)
						SanityManager.ASSERT(readAmount > 0);

					if (readAmount < recordLength)
					{
						// Need to remember where we are because the log
						// record may have read part of it off the input
						// stream already and that position is lost when we
						// set limit again.
						int inputPosition = input.getPosition();

						scan.readFully(data, readAmount,
									   recordLength-readAmount); 

						input.setLimit(0, recordLength);
						input.setPosition(inputPosition);
					}
				}
			}

			// go back to the start of the log record so that the next time
			// this method is called, it is positioned right past the last byte
			// of the record.
			curpos = recordStartPosition;
			scan.seek(curpos);

		} while (candidate == false);

		return lr;

	}"
114,617,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.conglomerate,org.apache.derby.impl.store.access.conglomerate.GenericScanController,,fetch,,StandardException,"StandardException,newException",1509,1509,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericScanController.java#L1509,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericScanController.java,,close,"public void fetch(DataValueDescriptor[] row)
        throws StandardException
    {
        fetch(row, true);
    }"
115,625,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.InsertResultSet,,open,,AutoincrementCounter,"AutoincrementCounter,aiHashtable,makeIdentity,put",542,542,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java#L542,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java,,unknown,"public void open() throws StandardException
	{
		setup();
		// Remember if this is the 1st execution
		firstExecute = (rowChanger == null);

		autoincrementGenerated = false;

		dd = lcc.getDataDictionary();

		/*
		** verify the auto-generated key columns list(ie there are no invalid column
		** names or positions). This is done at at execution time because for a precompiled
		** insert statement, user can specify different column selections for
		** auto-generated keys.
		*/
		if(activation.getAutoGeneratedKeysResultsetMode())
		{
            int[]   agi = activation.getAutoGeneratedKeysColumnIndexes();
            if ( agi != null ) { verifyAutoGeneratedColumnsIndexes( agi ); }
            else
            {
                String[]    agc = activation.getAutoGeneratedKeysColumnNames();
                if ( agc != null ) { verifyAutoGeneratedColumnsNames( agc ); }
            }
		}
		rowCount = 0L;

		if (numOpens++ == 0)
		{
			sourceResultSet.openCore();
		}
		else
		{
			sourceResultSet.reopenCore();
		}

		/* If the user specified bulkInsert (or replace) then we need 
		 * to get an exclusive table lock on the table.  If it is a
		 * regular bulk insert then we need to check to see if the
		 * table is empty.  (If not empty, then we end up doing a row
		 * at a time insert.)
		 */
		if (userSpecifiedBulkInsert)
		{
			if (! bulkInsertReplace)
			{
				bulkInsert = verifyBulkInsert();
			}
			else
			{
				getExclusiveTableLock();
			}
		}

		if (bulkInsert)
		{
			// Notify the source that we are the target
			sourceResultSet.setTargetResultSet(this);

            ExecRow fullTemplate =
                ((ExecRowBuilder) activation.getPreparedStatement().
                    getSavedObject(fullTemplateId)).build(
                        activation.getExecutionFactory());

            long baseTableConglom =
                    bulkInsertCore(lcc, fullTemplate, heapConglom);

			if (hasBeforeStatementTrigger)
			{	
				tableScan = getTableScanResultSet(baseTableConglom); 

				// fire BEFORE trigger, do this before checking constraints
				triggerActivator.notifyEvent(TriggerEvents.BEFORE_INSERT, 
												(CursorResultSet)null,
												tableScan, 
												(int[])null);
			
				// if we have a check constraint or generation clauses, we have
				// to do it the hard way now before we get
				// to our AFTER triggers.
				if ((checkGM != null) || (generationClauses != null) )
				{
					tableScan = getTableScanResultSet(baseTableConglom); 

					try
					{
						ExecRow currRow = null;
						while ((currRow = tableScan.getNextRowCore()) != null)
						{
							// we have to set the source row so the check constraint
							// sees the correct row.
							sourceResultSet.setCurrentRow(currRow);
 							evaluateCheckConstraints();
						}
					} finally
					{
						sourceResultSet.clearCurrentRow();
					}
				}
			}
			
            bulkValidateForeignKeys(tc, lcc.getContextManager(), fullTemplate);
	
			// if we have an AFTER trigger, let 'er rip
			if ((triggerInfo != null) && 
				(triggerInfo.hasTrigger(false, true) ||
				 triggerInfo.hasTrigger(false, false))) 
			{
				triggerActivator.notifyEvent(TriggerEvents.AFTER_INSERT,
										(CursorResultSet)null,
										getTableScanResultSet(baseTableConglom), 
										(int[])null); 
			}
			bulkInsertPerformed = true;
		}
		else
		{
	        row = getNextRowCore(sourceResultSet);
			normalInsertCore(lcc, firstExecute);
		}

		/* Cache query plan text for source, before it gets blown away */
		if (lcc.getRunTimeStatisticsMode())
		{
			/* savedSource nulled after run time statistics generation */
			savedSource = sourceResultSet;
		}

		/* autoGeneratedResultset for JDBC3. Nulled after statement execution is over
		(ie after it is saved off in LocalSatement object) */
		if (activation.getAutoGeneratedKeysResultsetMode())
			autoGeneratedKeysResultSet = autoGeneratedKeysRowsHolder.getResultSet();
		else
			autoGeneratedKeysResultSet = null;

		cleanUp();

		if (aiCache != null)
		{
			HashMap<String,Long> aiHashtable = new HashMap<String,Long>();
			int numColumns = aiCache.length;
			// this insert updated ai values, store them in some persistent
			// place so that I can see these values.
			for (int i = 0; i < numColumns; i++)
			{
				if (aiCache[i] == null)
					continue;
				aiHashtable.put(AutoincrementCounter.makeIdentity(
								  constants.getSchemaName(),
								  constants.getTableName(),
								  constants.getColumnName(i)),
								new Long(aiCache[i].getLong()));
			}
			InternalTriggerExecutionContext itec =
				(InternalTriggerExecutionContext)lcc.getTriggerExecutionContext();
			if (itec == null)
				lcc.copyHashtableToAIHT(aiHashtable);
			else
				itec.copyHashtableToAIHT(aiHashtable);
		}	

		endTime = getCurrentTimeMillis();
	}"
116,628,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealSortStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,216,216,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealSortStatistics.java#L216,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealSortStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           new Integer(this.rowsInput),
           new Integer(this.rowsSeen),
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),
           new Integer(this.rowsReturned),
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
117,662,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.InsertResultSet,,verifyAutoGeneratedColumnsIndexes,,StandardException,"StandardException,newException",585,585,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java#L585,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java,,unknown,"private void verifyAutoGeneratedColumnsIndexes(int[] columnIndexes)
		throws StandardException
	{
		int size = columnIndexes.length;
		TableDescriptor td = dd.getTableDescriptor(constants.targetUUID);

		// all 1-based column ids.
		for (int i = 0; i < size; i++)
		{
			ColumnDescriptor cd = td.getColumnDescriptor(columnIndexes[i]);
			if (!verifyAutoGenColumn(cd))
			{
				throw StandardException.newException(
					SQLState.LANG_INVALID_AUTOGEN_COLUMN_POSITION,
					new Integer(columnIndexes[i]), td.getName());
			}
		}
	}"
118,664,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.IndexChanger,,doDelete,,Long,"Long,args,indexCID",367,367,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java#L367,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/IndexChanger.java,,close,"private void doDelete()
		 throws StandardException
	{
		if (ownIndexSC)
		{
			if (! indexSC.next())
			{
                // This means that the entry for the index does not exist, this
                // is a serious problem with the index.  Past fixed problems
                // like track 3703 can leave db's in the field with this problem
                // even though the bug in the code which caused it has long 
                // since been fixed.  Then the problem can surface months later
                // when the customer attempts to upgrade.  By ""ignoring"" the
                // missing row here the problem is automatically ""fixed"" and
                // since the code is trying to delete the row anyway it doesn't
                // seem like such a bad idea.  It also then gives a tool to 
                // support to be able to fix some system catalog problems where
                // they can delete the base rows by dropping the system objects
                // like stored statements.

				if (SanityManager.DEBUG)
					SanityManager.THROWASSERT(
                        ""Index row ""+RowUtil.toString(ourIndexRow)+
                        "" not found in conglomerateid "" + indexCID +
                        ""Current scan = "" + indexSC);

                Object[] args = new Object[2];
                args[0] = ourIndexRow.getRowArray()[ourIndexRow.getRowArray().length - 1];
                args[1] = new Long(indexCID);

                Monitor.getStream().println(MessageService.getTextMessage(
                    SQLState.LANG_IGNORE_MISSING_INDEX_ROW_DURING_DELETE, 
                    args));

                // just return indicating the row has been deleted.
                return;
			}
		}

        indexSC.delete();
	}"
119,666,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.BTree,,create,,Boolean,"Boolean,result_string,uniqueWithDuplicateNulls,booleanValue",480,480,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/BTree.java#L480,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/BTree.java,,close,"public void create(
    Transaction             rawtran,
    int                     segmentId,
    long                    input_containerid,
    DataValueDescriptor[]   template,
    Properties              properties,
    int                     conglom_format_id,
	int                     tmpFlag
    )
        throws StandardException
	{
        String result_string;

        if (properties == null)
        {
            throw(
                StandardException.newException(
                    SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
        }

        // Check input arguments
        allowDuplicates = 
            (Boolean.valueOf(properties.getProperty(
                PROPERTY_ALLOWDUPLICATES, ""false""))).booleanValue();

        result_string = properties.getProperty(PROPERTY_NKEYFIELDS);
        if (result_string == null)
        {
            throw(
                StandardException.newException(
                    SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NKEYFIELDS));
        }
        else
        {
            nKeyFields = Integer.parseInt(result_string);
        }

        result_string = properties.getProperty(PROPERTY_NUNIQUECOLUMNS);
        if (result_string == null)
        {
            throw(StandardException.newException(
                SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_NUNIQUECOLUMNS));
        }
        else
        {
            nUniqueColumns = Integer.parseInt(result_string);
        }
        
        result_string = 
            properties.getProperty(
                PROPERTY_UNIQUE_WITH_DUPLICATE_NULLS, ""false"");
        uniqueWithDuplicateNulls = new Boolean (result_string).booleanValue();


        if (SanityManager.DEBUG)
        {
            result_string = 
                properties.getProperty(PROPERTY_MAX_ROWS_PER_PAGE_PARAMETER);

            if (result_string != null)
            {
                maxRowsPerPage = Integer.parseInt(result_string);
            }
        }

        maintainParentLinks = (Boolean.valueOf(
            properties.getProperty(PROPERTY_PARENTLINKS, ""true""))).booleanValue();

        // RESOLVE (mikem) - true for now, if we want to support non-key 
        // fields eventually this assert may be wrong.
        if (SanityManager.DEBUG)
        {
			if (template.length != nKeyFields)
			{
				SanityManager.THROWASSERT(
					""template.length ("" + template.length +
					"") expected to equal nKeyFields ("" + 
					nKeyFields + "")"");
			}
            SanityManager.ASSERT((nUniqueColumns == nKeyFields) || 
                                 (nUniqueColumns == (nKeyFields - 1)));
        }

        // get format id's from each column in template and store it in the
        // conglomerate state.
        format_ids = ConglomerateUtil.createFormatIds(template);

        // copy the format id of the conglomerate.
        this.conglom_format_id = conglom_format_id;

		// Create a container for the b-tree with default page size and 
        // fill up pages.
		properties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, ""0"");
		properties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, ""1"");
		properties.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID, ""true"");

		long containerid = 
            rawtran.addContainer(
                segmentId, input_containerid, 
                ContainerHandle.MODE_DEFAULT, properties, tmpFlag);

		// Make sure the container was actually created.
		// Open segment will get cleaned up when transaction is.
		if (containerid <= 0)
        {
            throw(StandardException.newException(
                    SQLState.BTREE_CANT_CREATE_CONTAINER)); 
        }

        if (SanityManager.DEBUG)
        {
            if (input_containerid != ContainerHandle.DEFAULT_ASSIGN_ID)
                SanityManager.ASSERT(containerid == input_containerid);
        }

		id = new ContainerKey(segmentId, containerid);
	}"
120,671,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedResultSet,,adjustScale,,"throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));",,3300,3300,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java#L3300,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java,,close,"protected   void    adjustScale( int columnIndex, int scale )
        throws SQLException
    {
		/*
		* If the parameter type is DECIMAL or NUMERIC, then
		* we need to set them to the passed scale.
		*/
		int colType = getColumnType(columnIndex);
		if ((colType == Types.DECIMAL) || (colType == Types.NUMERIC)) {
			if (scale < 0)
				throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));

			try {
				DataValueDescriptor value = updateRow.getColumn(columnIndex);

				int origvaluelen = value.getLength();
				((VariableSizeDataValue)
						value).setWidth(VariableSizeDataValue.IGNORE_PRECISION,
							scale,
							false);

			} catch (StandardException t) {
				throw EmbedResultSet.noStateChangeException(t);
			}
		}
    }"
121,673,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.InsertResultSet,,getSetAutoincrementValue,,lcc,"lcc,td,autoincrementCreateCounter,getSchemaName",779,779,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java#L779,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java,,unknown,"public NumberDataValue
		getSetAutoincrementValue(int columnPosition, long increment)
		throws StandardException
	{
		long startValue = 0;
                NumberDataValue dvd;
		int index = columnPosition - 1;	// all our indices are 0 based.

		/* As in DB2, only for single row insert: insert into t1(c1) values (..) do
		 * we return the correct most recently generated identity column value.  For
		 * multiple row insert, or insert with sub-select, the return value is non-
		 * deterministic, and is the previous return value of the IDENTITY_VAL_LOCAL
		 * function, before the insert statement.  Also, DB2 can have at most 1 identity
		 * column per table.  The return value won't be affected either if Derby
		 * table has more than one identity columns.
		 */
		setIdentity = (! autoincrementGenerated) && isSourceRowResultSet();
		autoincrementGenerated = true;

  		if (bulkInsert)
  		{
			ColumnDescriptor cd = td.getColumnDescriptor(columnPosition);
			long ret;

			// for bulk insert we have the table descriptor
			//			System.out.println(""in bulk insert"");
			if (aiCache[index].isNull())
			{
				if (bulkInsertReplace)
				{
					startValue = cd.getAutoincStart();
				}
				else
				{
					dvd = dd.getSetAutoincrementValue(
						    constants.autoincRowLocation[index],
							tc, false, aiCache[index], true);
					startValue = dvd.getLong();
				}
				lcc.autoincrementCreateCounter(td.getSchemaName(),
											   td.getName(),
											   cd.getColumnName(),
											   new Long(startValue),
											   increment,
											   columnPosition);
			
			}  		
			ret = lcc.nextAutoincrementValue(td.getSchemaName(),
											 td.getName(),
											 cd.getColumnName());
			aiCache[columnPosition - 1].setValue(ret);
		}	
		else
		{
			NumberDataValue newValue;
			TransactionController nestedTC = null, tcToUse = tc;

			try
			{
                // DERBY-5780, defaulting log syncing to false, which improves
                // performance of identity value generation.  If system 
                // crashes may reuse an identity value because commit did not
                // sync, but only if no subsequent user transaction has 
                // committed or aborted and thus no row can exist that used
                // the previous value.  Without this identity values pay
                // a synchronous I/O to the log file for each new value no
                // matter how many are inserted in a single transaction.
				nestedTC = tc.startNestedUserTransaction(false, false);
				tcToUse = nestedTC;
			}
			catch (StandardException se)
			{
				// If I cannot start a Nested User Transaction use the parent
				// transaction to do all the work.
				tcToUse = tc;
			}

			try 
			{
				/* If tcToUse == tc, then we are using parent xaction-- this
				   can happen if for some reason we couldn't start a nested
				   transaction
				*/
				newValue = dd.getSetAutoincrementValue(
						   constants.autoincRowLocation[index],
						   tcToUse, true, aiCache[index], (tcToUse == tc));
			}
			catch (StandardException se)
			{
				if (tcToUse == tc)
				{
					/* we've using the parent xaction and we've timed out; just
					   throw an error and exit.
					*/
					throw se;
				}

				if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
				{
					// if we couldn't do this with a nested xaction, retry with
					// parent-- we need to wait this time!
					newValue = dd.getSetAutoincrementValue(
									constants.autoincRowLocation[index],
									tc, true, aiCache[index], true);
				}
				else if (se.getMessageId().equals(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE))
				{
					// if we got an overflow error, throw a more meaningful
					// error message
					throw StandardException.newException(
												 SQLState.LANG_AI_OVERFLOW,
												 se,
												 constants.getTableName(),
												 constants.getColumnName(index));
				}
				else throw se;
			}
			finally 
			{
				// no matter what, commit the nested transaction; if something
				// bad happened in the child xaction lets not abort the parent
				// here.
                
				if (nestedTC != null)
				{
                    // DERBY-5493 - prior to fix all nested user update 
                    // transactions did a nosync commit when commit() was 
                    // called, this default has been changed to do synced 
                    // commit.  Changed this commit to be commitNoSync to
                    // not introduce performce degredation for autoincrement
                    // keys.  As before, if server crashes the changes 
                    // made in the nested transaction may be lost.  If any
                    // subsequent user transaction is commited, including any
                    // inserts that would depend on the autoincrement value
                    // change then the nested tranaction is guaranteed on
                    // system crash.
					nestedTC.commitNoSync(TransactionController.RELEASE_LOCKS);
					nestedTC.destroy();
				}
			}
			aiCache[index] = newValue;
			if (setIdentity)
				identityVal = newValue.getLong();
		}

		return aiCache[index];
		
	}"
122,679,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.services.jce,org.apache.derby.impl.services.jce.JCECipherFactory,,changeBootPassword,,SQLState,"SQLState,StandardException,ILLEGAL_BP_LENGTH,newException",782,782,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/services/jce/JCECipherFactory.java#L782,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/services/jce/JCECipherFactory.java,,close,"public String changeBootPassword(String changeString, Properties properties, CipherProvider verify)
		throws StandardException {

		// the new bootPassword is expected to be of the form
		// oldkey , newkey.
		int seperator = changeString.indexOf(',');
		if (seperator == -1)
			throw StandardException.newException(SQLState.WRONG_PASSWORD_CHANGE_FORMAT);

		String oldBP = changeString.substring(0, seperator).trim();
		byte[] oldBPAscii = StringUtil.getAsciiBytes(oldBP);
		if (oldBPAscii == null || oldBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
			throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD);;

		String newBP = changeString.substring(seperator+1).trim();
		byte[] newBPAscii = StringUtil.getAsciiBytes(newBP);
		if (newBPAscii == null || newBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH,
                new Integer(CipherFactory.MIN_BOOTPASS_LENGTH));

		// verify old key

		byte[] generatedKey = getDatabaseSecretKey(properties, oldBPAscii, SQLState.WRONG_BOOT_PASSWORD);

		// make sure the oldKey is correct
		byte[] IV = generateIV(generatedKey);

		if (!((JCECipherProvider) verify).verifyIV(IV))
		{ throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD); }

        // DERBY-5622:
        // if we survive those two quick checks, verify that the generated key is still correct
        // by using it to decrypt something encrypted by the original generated key
        CipherProvider  newDecrypter = createNewCipher
            ( DECRYPT, generateKey( generatedKey ), IV );
        vetCipherProviders( newDecrypter, verify, SQLState.WRONG_BOOT_PASSWORD );
        
		// Make the new key.  The generated key is unchanged, only the
		// encrypted key is changed.
		String newkey = saveSecretKey(generatedKey, newBPAscii);
		
		properties.put(Attribute.CRYPTO_KEY_LENGTH,keyLengthBits+""-""+encodedKeyLength);
		

		return saveSecretKey(generatedKey, newBPAscii);
	}"
123,685,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,openSort,,StandardException,"StandardException,newException",1828,1828,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L1828,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"public SortController openSort(long id)
		throws StandardException
	{
		Sort sort;

		// Find the sort in the sorts list, throw an error
		// if it doesn't exist.
		if (sorts == null || id >= sorts.size()
			|| (sort = (sorts.get((int) id))) == null)
		{
			throw StandardException.newException(
                    SQLState.AM_NO_SUCH_SORT, new Long(id));
		}

		// Open it.
		SortController sc = sort.open(this);

		// Keep track of it so we can release on close.
		if (sortControllers == null)
			sortControllers = new ArrayList<SortController>();
		sortControllers.add(sc);

		return sc;
	}"
124,687,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedStatement,,setQueryTimeout,,"throw newSQLException(SQLState.INVALID_QUERYTIMEOUT_VALUE,",,538,538,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java#L538,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java,,close,"public final void setQueryTimeout(int seconds) throws SQLException {
		checkStatus();
        if (seconds < 0) {
            throw newSQLException(SQLState.INVALID_QUERYTIMEOUT_VALUE,
                                  new Integer(seconds));
        }
        timeoutMillis = (long) seconds * 1000;
	}"
125,690,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.sort,org.apache.derby.impl.store.access.sort.MergeInserter,,insert,,Integer,"Integer,runSize,stat_mergeRunsSize,addElement",199,199,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/sort/MergeInserter.java#L199,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/sort/MergeInserter.java,,close,"public void insert(DataValueDescriptor[] row)
		throws StandardException
	{
		if (SanityManager.DEBUG)
		{
			// If the sort is null, probably the caller forgot
			// to call initialize.
			SanityManager.ASSERT(sort != null);
		}

		// Check that the inserted row is of the correct type
		sort.checkColumnTypes(row);

		// Insert the row into the sort buffer, which will
		// sort it into the right order with the rest of the
		// rows and remove any duplicates.
        int insertResult = sortBuffer.insert(row);
        stat_numRowsInput++;
        if (insertResult != SortBuffer.INSERT_DUPLICATE)
            stat_numRowsOutput++;
        if (insertResult == SortBuffer.INSERT_FULL)
		{
			if (avoidMergeRun)
			{
				Runtime jvm = Runtime.getRuntime();
				if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(""SortTuning""))
                    {
                        jvm.gc();
                        jvm.gc();
                        jvm.gc();
                    }
                }

                long currentFreeMemory = jvm.freeMemory();
                long currentTotalMemory = jvm.totalMemory();
                long currentMemoryUsage =
                        currentTotalMemory - currentFreeMemory;

				// before we create an external sort, which is expensive, see if
                // we can use up more in-memory sort buffer
				// we see how much memory has been used between now and the
				// beginning of the sort.  Not all of this memory is used by
				// the sort and GC may have kicked in and release some memory.
				// But it is a rough guess.
                long estimatedMemoryUsed =
                        currentMemoryUsage - beginMemoryUsage;

 				if (SanityManager.DEBUG)
                {
                    if (SanityManager.DEBUG_ON(""SortTuning""))
                    {
						SanityManager.DEBUG(""SortTuning"",
							""Growing sortBuffer dynamically, "" +
							""current sortBuffer capacity= "" + 
                                sortBuffer.capacity() +
							"" estimatedMemoryUsed = "" + estimatedMemoryUsed +
							"" currentTotalMemory = "" + currentTotalMemory +
							"" currentFreeMemory = "" + currentFreeMemory +
							"" numcolumn = "" + row.length +
							"" real per row memory = "" + 
                                (estimatedMemoryUsed / sortBuffer.capacity()));
                    }
                }

                if (estimatedMemoryUsed < 0) {
                    // We use less memory now than before we started filling
                    // the sort buffer, probably because gc has happened. This
                    // means we don't have a good estimate for how much memory
                    // the sort buffer has occupied. To compensate for that,
                    // set the begin memory usage to the current memory usage,
                    // so that we get a more correct (but probably still too
                    // low) estimate the next time we get here. See DERBY-5416.
                    beginMemoryUsage = currentMemoryUsage;
                }

				// we want to double the sort buffer size if that will result
				// in the sort to use up no more than 1/2 of all the free
				// memory (including the sort memory)
				// or if GC is so effective we are now using less memory than before
				// or if we are using less than 1Meg of memory and the jvm is
				// using < 5 meg of memory (this indicates that the JVM can
				// afford to be more bloated ?)
				if (estimatedMemoryUsed < 0 ||
					((2*estimatedMemoryUsed) < (estimatedMemoryUsed+currentFreeMemory)/2) ||
					(2*estimatedMemoryUsed < ExternalSortFactory.DEFAULT_MEM_USE &&
					 currentTotalMemory < (5*1024*1024)))
				{
					// ok, double the sort buffer size
					sortBuffer.grow(100);

					if (sortBuffer.insert(row) != SortBuffer.INSERT_FULL)
						return;
				}

				avoidMergeRun = false; // once we did it, too late to do in
									   // memory sort
			}

			// The sort buffer became full.  Empty it into a
			// merge run, and add the merge run to the vector
			// of merge runs.
            stat_sortType = ""external"";
			long conglomid = sort.createMergeRun(tran, sortBuffer);
			if (mergeRuns == null)
				mergeRuns = new Vector<Long>();
			mergeRuns.addElement(new Long(conglomid));

            stat_numMergeRuns++;
            // calculate size of this merge run
            // buffer was too full for last row
            runSize = stat_numRowsInput - totalRunSize - 1;
            totalRunSize += runSize;
            stat_mergeRunsSize.addElement(new Integer(runSize));

			// Re-insert the row into the sort buffer.
			// This is guaranteed to work since the sort
			// buffer has just been emptied.
			sortBuffer.insert(row);
		}
	}"
126,694,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedClob,,truncate,,throw Util.generateCsSQLException(,,667,667,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java#L667,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java,,close,"public void truncate(long len) throws SQLException
    {
        checkValidity();
        if (len < 0)
            throw Util.generateCsSQLException(
                SQLState.BLOB_NONPOSITIVE_LENGTH, new Long(len));
        try {
            if (!clob.isWritable()) {
                makeWritableClobClone(len);
            }
            else {
                clob.truncate (len);
            }
        }
        catch (EOFException eofe) {
            throw Util.generateCsSQLException(
                        SQLState.BLOB_LENGTH_TOO_LONG,
                        eofe, len);
        } catch (IOException e) {
            throw Util.setStreamFailure(e);
        }
    }"
127,698,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.LOBStreamControl,,updateData,,StandardException,"StandardException,newException",137,137,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java#L137,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/LOBStreamControl.java,,close,"private long updateData(byte[] bytes, int offset, int len, long pos)
            throws StandardException {
        if (dataBytes == null) {
            if ((int) pos == 0) {
                dataBytes = new byte [len];
                System.arraycopy(bytes, offset, dataBytes, (int) pos, len);
                return len;
            }
            else {
                //invalid postion
                throw StandardException.newException(
                        SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
            }
        }
        else {
            if (pos > dataBytes.length) {
                //invalid postion
                throw StandardException.newException(
                        SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
            }
            else {
                if (pos + len < dataBytes.length) {
                    System.arraycopy(bytes, offset, dataBytes, (int) pos, len);
                }
                else {
                    byte [] tmpBytes = new byte [len + (int) pos];
                    System.arraycopy(dataBytes, 0 , tmpBytes, 0, (int) pos);
                    System.arraycopy(bytes, offset, tmpBytes, (int) pos, len);
                    dataBytes = tmpBytes;
                }
            }
            return pos + len;
        }
    }"
128,699,derby,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.Export$1,,run,,Boolean,"Boolean,file,exists",162,162,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/Export.java#L162,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/Export.java,,close,"public Boolean run() {
                        return new Boolean(file.exists());
                    }"
129,701,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.JarUtil$2,,run,,Long,"Long,generationId",390,390,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/JarUtil.java#L390,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/JarUtil.java,,close,"public InputStream run() throws IOException {    
                    try {
                        return new URL(externalPath).openStream();
                    } catch (MalformedURLException mfurle)
                    {
                        return new FileInputStream(externalPath);
                    }
                }"
130,708,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedConnection,,getLOBMapping,,return getlobHMObj().get(new Integer(key));,,3310,3310,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java#L3310,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java,,close,"public Object getLOBMapping(int key) {
		return getlobHMObj().get(new Integer(key));
	}"
131,715,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialClob,,setString,,HarmonySerialBlob,"HarmonySerialBlob,Object,SQLState,BLOB_BAD_POSITION,makeSQLException",182,182,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialClob.java#L182,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialClob.java,,close,"public int setString(long pos, String str) throws SQLException {
        checkValidation();
        return setString(pos, str, 0, str.length());
    }"
132,728,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.BTreeController,,getTableProperties,,throw StandardException.newException(,,1420,1420,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/BTreeController.java#L1420,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/BTreeController.java,,close,"public void getTableProperties(Properties prop)
		throws StandardException
    {
		if (this.container == null)
        {
            throw StandardException.newException(
                        SQLState.BTREE_IS_CLOSED,
                        new Long(err_containerid));
        }

        container.getContainerProperties(prop);

        return;
    }"
133,732,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc.authentication,org.apache.derby.impl.jdbc.authentication.AuthenticationServiceBase,,parsePasswordLifetime,,Long,"Long,passwordLifetime",460,460,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java#L460,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,,close,"protected   Long    parsePasswordLifetime( String passwordLifetimeString )
    {
            try {
                long    passwordLifetime = Long.parseLong( passwordLifetimeString );

                if ( passwordLifetime < 0L ) { passwordLifetime = 0L; }

                return new Long( passwordLifetime );
            } catch (Exception e) { return null; }
    }"
134,734,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.HeapController,,doInsert,,StandardException,"StandardException,newException",235,235,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/HeapController.java#L235,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/HeapController.java,,close,"private RecordHandle doInsert(DataValueDescriptor[] row)
		throws StandardException
	{
		Page page = null;
        byte  insert_mode;
		
        RecordHandle rh;

        if (SanityManager.DEBUG)
        {
            Heap heap = (Heap) open_conglom.getConglomerate();
            // Make sure valid columns are in the list.  The RowUtil
            // call is too expensive to make in a released system for
            // every insert.

            int invalidColumn = 
                RowUtil.columnOutOfRange(
                    row, null, heap.format_ids.length);

            if (invalidColumn >= 0)
            {
                throw(StandardException.newException(
                        SQLState.HEAP_TEMPLATE_MISMATCH,
                        new Long(invalidColumn), 
                        new Long(heap.format_ids.length)));
            }
        }

        // Get the last page that was returned for insert or the last page
        // that was allocated.
        page = open_conglom.getContainer().getPageForInsert(0);

        if (page != null) {

            // if there are 0 rows on the page allow the insert to overflow.
            insert_mode = 
                (page.recordCount() == 0) ? 
                    Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;

            // Check to see if there is enough space on the page
            // for the row.
            rh = page.insert(row, null, insert_mode,
				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
            page.unlatch();
            page = null;

            // If we have found a page with enough space for the row,
            // insert it and release exclusive access to the page.
            if (rh != null)
            {
                return rh;

            }
        }

        // If the last inserted page is now full, or RawStore have
        // forgotten what it was, or the row cannot fit on the last
        // inserted page, try to have rawStore get a relatively unfilled
        // page.

        page = 
            open_conglom.getContainer().getPageForInsert(
                ContainerHandle.GET_PAGE_UNFILLED);

        if (page != null)
        {
            // Do the insert all over again hoping that it will fit into
            // this page, and if not, allocate a new page.

            // if there are 0 rows on the page allow the insert to overflow.
            insert_mode = 
                (page.recordCount() == 0) ? 
                    Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
            
            rh = page.insert(row, null, insert_mode,
				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);

            page.unlatch();
            page = null;

            // If we have found a page with enough space for the row,
            // insert it and release exclusive access to the page.
            if (rh != null)
            {
                return rh;
            }
        }

        page = open_conglom.getContainer().addPage();

        // At this point with long rows the raw store will guarantee
        // that any size row will fit on an empty page.

        rh = page.insert(row, null, Page.INSERT_OVERFLOW,
			AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
        page.unlatch();
        page = null;

        if (SanityManager.DEBUG)
        {
            // a null will only be returned if this page is not empty
            SanityManager.ASSERT(rh != null);
        }

        return rh;
	}"
135,745,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealDeleteResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,160,160,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealDeleteResultSetStatistics.java#L160,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealDeleteResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           null,                              // the number of opens
           new Integer(this.indexesUpdated),
           null,                           // lock mode
           this.tableLock?""T"":""R"",
           (UUID)parentID,
           null,                             // estimated row count
           null,                             // estimated cost
           new Integer(this.rowCount),
           XPLAINUtil.getYesNoCharFromBoolean(this.deferred),
           null,                              // the input rows
           null,                              // the seen rows left
           null,                              // the seen rows right
           null,                              // the filtered rows
           null,                              // the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
136,751,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealDeleteVTIResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,142,142,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealDeleteVTIResultSetStatistics.java#L142,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealDeleteVTIResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           null,                              // the number of opens
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           null,                             // estimated row count
           null,                             // estimated cost
           new Integer(this.rowCount),
           null,                              // the deferred rows.
           null,                              // the input rows
           null,                              // the seen rows left
           null,                              // the seen rows right
           null,                              // the filtered rows
           null,                              // the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
137,753,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,setBinaryStream,,throw Util.generateCsSQLException(,,975,975,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L975,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"public java.io.OutputStream setBinaryStream (long pos)
                                    throws SQLException {
            checkValidity ();
            if (pos - 1 > length())
                throw Util.generateCsSQLException(
                    SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
            if (pos < 1)
                throw Util.generateCsSQLException(
                    SQLState.BLOB_BAD_POSITION, new Long(pos));
            try {
                if (materialized) {
                    return control.getOutputStream (pos - 1);
                }
                else {
                    control = new LOBStreamControl (
                                            getEmbedConnection());
                    control.copyData (myStream, pos - 1);
                    myStream.close ();
                    streamLength = -1;
                    materialized = true;
                    return control.getOutputStream(pos - 1);

                }
            }
            catch (IOException e) {
                throw Util.setStreamFailure (e);
            }
            catch (StandardException se) {
                throw Util.generateCsSQLException (se);
            }
	}"
138,756,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.Import,,<init>,,Integer,"Integer,_importers,importCounter,this,put",81,81,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/Import.java#L81,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/Import.java,,close,
139,758,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.btree,org.apache.derby.impl.store.access.btree.OpenBTree,,init,,StandardException,"StandardException,newException",397,397,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/btree/OpenBTree.java#L397,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/btree/OpenBTree.java,,close,"public void init(
    TransactionManager              open_user_scans,
    TransactionManager              xact_manager,
    ContainerHandle                 input_container,
    Transaction                     rawtran,
    boolean                         hold,
	int                             open_mode,
    int                             lock_level,
    BTreeLockingPolicy              btree_locking_policy,
    BTree                           conglomerate,
    LogicalUndo                     undo,
    DynamicCompiledOpenConglomInfo  dynamic_info)
        throws StandardException
	{
		// If the b-tree is already open, close it.
		if (this.container != null)
        {
            if (SanityManager.DEBUG)
                SanityManager.ASSERT(false, ""why is the container open?"");
			close();
        }
        err_containerid = conglomerate.id.getContainerId();

        // Locking policy to pass back to concrete implementation lock calls
        this.init_btree_locking_policy = btree_locking_policy;

		// if the conglomerate is temporary, open with IS_KEPT set.
		// RESOLVE(mikem): track 1825
		// don't want to open temp cantainer with IS_KEPT always.
		if (conglomerate.isTemporary())
			open_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;

        // now open the container if it wasn't already opened by the client.
        // No locks will be requested by raw store on this open.
        if (input_container == null)
        {
            // Open the container. 
            this.container = 
                rawtran.openContainer(
                    conglomerate.id, 
                    (LockingPolicy) null /* get no locks on btree */,
					open_mode);
        }
        else
        {
            // Use the open container passed in.
            this.container = input_container;

			// RESOLVE (sku) - ContainerHandle should have an interface to
			// verify that it is opened with open_mode
        }

		if (this.container == null)
        {
            throw StandardException.newException(
                    SQLState.BTREE_CONTAINER_NOT_FOUND,
                    new Long(err_containerid));
        }

		// Remember the conglomerate so its properties can be found.
        init_conglomerate   = conglomerate;

        // Remember the transaction manager so commit() can be called
        init_xact_manager   = xact_manager;

        init_rawtran        = rawtran;

        init_openmode       = open_mode;

        // Isolation level of this btree.
        init_lock_level     = lock_level;

        init_hold           = hold;


        this.init_open_user_scans = open_user_scans;

        // Logical undo class to pass to raw store, on inserts/deletes.
        this.btree_undo = undo;

        // either use passed in ""compiled"" runtime scratch space, or create
        // new space.
        this.runtime_mem    = 
            (dynamic_info != null ? 
             ((OpenConglomerateScratchSpace) dynamic_info) : 
              (OpenConglomerateScratchSpace)
                conglomerate.getDynamicCompiledConglomInfo());

	}"
140,761,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.conglomerate,org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController,,replace,,StandardException,"StandardException,newException",458,458,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java#L458,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/conglomerate/GenericConglomerateController.java,,close,"public boolean replace(
    RowLocation             loc, 
    DataValueDescriptor[]   row, 
    FormatableBitSet                 validColumns)
		throws StandardException
	{
        if (open_conglom.isClosed())
        {
            if (open_conglom.getHold())
            {
                if (open_conglom.isClosed())
                    open_conglom.reopen();
            }
            else
            {
                throw(
                    StandardException.newException(
                        SQLState.HEAP_IS_CLOSED, 
                        open_conglom.getConglomerate().getId()));
            }
        }

        if (SanityManager.DEBUG)
        {
            // Make sure valid columns are in the list.  The RowUtil
            // call is too expensive to make in a released system for
            // every fetch.
            int invalidColumn = 
                RowUtil.columnOutOfRange(
                    row, validColumns, open_conglom.getFormatIds().length);

            if (invalidColumn >= 0)
            {
                throw(StandardException.newException(
                        SQLState.HEAP_TEMPLATE_MISMATCH,
                        new Long(invalidColumn), 
                        new Long(open_conglom.getFormatIds().length)));
            }
        }

        RowPosition pos = 
            open_conglom.getRuntimeMem().get_scratch_row_position();

        getRowPositionFromRowLocation(loc, pos);

        if (!open_conglom.latchPage(pos)) 
        {
            return false;
        }

        open_conglom.lockPositionForWrite(pos, true);

        boolean ret_val = true;

        if (pos.current_page.isDeletedAtSlot(pos.current_slot))
        {
            ret_val = false;
        }
        else
        {
            // Update the record.  
            pos.current_page.updateAtSlot(pos.current_slot, row, validColumns);
        }

        pos.current_page.unlatch();

        return(ret_val);
    }"
141,766,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.sort,org.apache.derby.impl.store.access.sort.MergeInserter,,completedInserts,,Integer,"Integer,stat_mergeRunsSize,stat_numRowsInput,totalRunSize,addElement",229,229,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/sort/MergeInserter.java#L229,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/sort/MergeInserter.java,,close,"public void completedInserts()
	{
		// Tell the sort that we're closed, and hand off
		// the sort buffer and the vector of merge runs.
		if (sort != null)
			sort.doneInserting(this, sortBuffer, mergeRuns);

        // if this is an external sort, there will actually
        // be one last merge run with the contents of the
        // current sortBuffer. It will be created when the user
        // reads the result of the sort using openSortScan
        if (stat_sortType == ""external"")
        {
            stat_numMergeRuns++;
            stat_mergeRunsSize.addElement(new Integer(stat_numRowsInput - totalRunSize));
        }

        // close the SortController in the transaction.
        tran.closeMe(this);

		// Clean up.
		sort = null;
		tran = null;
		mergeRuns = null;
		sortBuffer = null;
	}"
142,770,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealGroupedAggregateStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,204,204,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealGroupedAggregateStatistics.java#L204,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealGroupedAggregateStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           new Integer(this.rowsInput),
           new Integer(this.rowsSeen),
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),
           null,                              // the rows returned
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
143,774,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedClob,,getCharacterStream,,throw Util.generateCsSQLException(,,739,739,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java#L739,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedClob.java,,close,"public java.io.Reader getCharacterStream() throws SQLException
    {
        //call checkValidity to exit by throwing a SQLException if
        //the Clob object has been freed by calling free() on it
        checkValidity();
        try {
            return new ClobUpdatableReader (this);
        } catch (IOException ioe) {
            throw Util.setStreamFailure(ioe);
        }
    }"
144,779,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealLastIndexKeyScanStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,252,252,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealLastIndexKeyScanStatistics.java#L252,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealLastIndexKeyScanStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        String lockMode = XPLAINUtil.getLockModeCode(this.lockString);
        String lockGran = XPLAINUtil.getLockGranularityCode(this.lockString);
        
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                           // the number of index updates 
           lockMode,
           lockGran,
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeen),            // the seen rows
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),        // the filtered rows
           new Integer(this.rowsSeen-this.rowsFiltered),// the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,                       // the stmt UUID
           (UUID)timingID);
    }"
145,783,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedBlob,,setBlobPosition,,throw StandardException.newException(,,320,320,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java#L320,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedBlob.java,,close,"private long setBlobPosition(long logicalPos)
        throws StandardException, IOException
    {
        if (SanityManager.DEBUG)
            SanityManager.ASSERT(logicalPos >= 0);
        if (materialized) {
            // Nothing to do here, except checking if the position is valid.
            if (logicalPos >= control.getLength()) {
                throw StandardException.newException(
                        SQLState.BLOB_POSITION_TOO_LARGE, new Long(logicalPos));
            }
        } else {
            // Reposition the store stream, account for the length field offset.
            try {
                this.myStream.reposition(
                        logicalPos + this.streamPositionOffset);
            } catch (EOFException eofe) {
                throw StandardException.newException(
                        SQLState.BLOB_POSITION_TOO_LARGE, eofe,
                        new Long(logicalPos));
            }
        }
        return logicalPos;
    }"
146,799,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.DataDictionaryImpl,,hashAllConglomerateDescriptorsByNumber,,Long hashKey = new Long(cd.getConglomerateNumber());,,6841,6841,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java#L6841,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,,close,"public Hashtable<Long,ConglomerateDescriptor> hashAllConglomerateDescriptorsByNumber(TransactionController tc)
		throws StandardException
	{
		Hashtable<Long,ConglomerateDescriptor> ht = new Hashtable<Long,ConglomerateDescriptor>();
		ConglomerateDescriptor	  cd = null;
		ScanController			  scanController;
		ExecRow 				  outRow;
		TabInfoImpl					  ti = coreInfo[SYSCONGLOMERATES_CORE_NUM];
		SYSCONGLOMERATESRowFactory  rf = (SYSCONGLOMERATESRowFactory) ti.getCatalogRowFactory();

		outRow = rf.makeEmptyRow();
		scanController = tc.openScan(
				ti.getHeapConglomerate(),  // conglomerate to open
				false, // don't hold open across commit
				0, // for read
                TransactionController.MODE_RECORD,  // scans whole table.
                TransactionController.ISOLATION_READ_UNCOMMITTED,
				(FormatableBitSet) null, // all fields as objects
				(DataValueDescriptor[]) null, //keyRow.getRowArray(),   // start position - first row
				ScanController.GE,      // startSearchOperation
				(ScanQualifier [][]) null,
				(DataValueDescriptor[]) null, //keyRow.getRowArray(),   // stop position - through last row
				ScanController.GT);     // stopSearchOperation

        // it is important for read uncommitted scans to use fetchNext() rather
        // than fetch, so that the fetch happens while latch is held, otherwise
        // the next() might position the scan on a row, but the subsequent
        // fetch() may find the row deleted or purged from the table.
		while (scanController.fetchNext(outRow.getRowArray()))
		{
			cd = (ConglomerateDescriptor) rf.buildDescriptor(
												outRow,
												(TupleDescriptor) null,
												this );
			Long hashKey = new Long(cd.getConglomerateNumber());
			ht.put(hashKey, cd);
		}

        scanController.close();

		return ht;
	}"
147,816,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.AutoincrementCounter,,getCurrentValue,,return new Long(counter);,,177,177,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/AutoincrementCounter.java#L177,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/AutoincrementCounter.java,,close,"public Long getCurrentValue()
	{
		if (initialized == false)
			return null;
		return new Long(counter);
	}"
148,817,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.log,org.apache.derby.impl.store.raw.log.LogToFile,,switchLogFile,,throw StandardException.newException(,,2063,2063,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java#L2063,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/log/LogToFile.java,,close,"public void switchLogFile() throws StandardException
	{
		boolean switchedOver = false;

		/////////////////////////////////////////////////////
		// Freeze the log for the switch over to a new log file.
		// This blocks out any other threads from sending log
		// record to the log stream.
		// 
		// The switching of the log file and checkpoint are really
		// independent events, they are tied together just because a
		// checkpoint is the natural place to switch the log and vice
		// versa.  This could happen before the cache is flushed or
		// after the checkpoint log record is written.
		/////////////////////////////////////////////////////
		synchronized (this)
		{

			// Make sure that this thread of control is guaranteed to complete
            // it's work of switching the log file without having to give up
            // the semaphore to a backup or another flusher.  Do this by looping
            // until we have the semaphore, the log is not being flushed, and
            // the log is not frozen for backup.  Track (2985). 
			while(logBeingFlushed | isFrozen)
			{
				try
				{
					wait();
				}
				catch (InterruptedException ie)
				{
                    InterruptStatus.setInterrupted();
				}	
			}

			// we have an empty log file here, refuse to switch.
			if (endPosition == LOG_FILE_HEADER_SIZE)
			{
				if (SanityManager.DEBUG)
				{
					Monitor.logMessage(""not switching from an empty log file ("" +
						   logFileNumber + "")"");
				}	
				return;
			}

			// log file isn't being flushed right now and logOut is not being
			// used.
			StorageFile newLogFile = getLogFileName(logFileNumber+1);

			if (logFileNumber+1 >= maxLogFileNumber)
            {
				throw StandardException.newException(
                        SQLState.LOG_EXCEED_MAX_LOG_FILE_NUMBER, 
                        new Long(maxLogFileNumber)); 
            }

			StorageRandomAccessFile newLog = null;	// the new log file
			try 
			{
				// if the log file exist and cannot be deleted, cannot
				// switch log right now
                if (privExists(newLogFile) && !privDelete(newLogFile))
				{
					logErrMsg(MessageService.getTextMessage(
                        MessageId.LOG_NEW_LOGFILE_EXIST,
					    newLogFile.getPath()));
					return;
				}

				try
				{
                    newLog =   privRandomAccessFile(newLogFile, ""rw"");
				}
				catch (IOException ioe)
				{
					newLog = null;
				}

                if (newLog == null || !privCanWrite(newLogFile))
				{
					if (newLog != null)
						newLog.close();
					newLog = null;

					return;
				}

				if (initLogFile(newLog, logFileNumber+1,
								LogCounter.makeLogInstantAsLong(logFileNumber, endPosition)))
				{

					// New log file init ok, close the old one and
					// switch over, after this point, need to shutdown the
					// database if any error crops up
					switchedOver = true;

					// write out an extra 0 at the end to mark the end of the log
					// file.
					
					logOut.writeEndMarker(0);

					setEndPosition( endPosition + INT_LENGTH );
					//set that we are in log switch to prevent flusher 
					//not requesting  to switch log again 
					inLogSwitch = true; 
					// flush everything including the int we just wrote
					flush(logFileNumber, endPosition);
					
					
					// simulate out of log error after the switch over
					if (SanityManager.DEBUG)
					{
						if (SanityManager.DEBUG_ON(TEST_SWITCH_LOG_FAIL2))
							throw new IOException(""TestLogSwitchFail2"");
					}


					logOut.close();		// close the old log file
					
					logWrittenFromLastCheckPoint += endPosition;

					setEndPosition( newLog.getFilePointer() );
					lastFlush = endPosition;
					
					if(isWriteSynced)
					{
						//extend the file by wring zeros to it
						preAllocateNewLogFile(newLog);
						newLog.close();
						newLog = openLogFileInWriteMode(newLogFile);
						newLog.seek(endPosition);
					}

					logOut = new LogAccessFile(this, newLog, logBufferSize);
					newLog = null;


					if (SanityManager.DEBUG)
					{
						if (endPosition != LOG_FILE_HEADER_SIZE)
							SanityManager.THROWASSERT(
											""new log file has unexpected size"" +
											 + endPosition);
					}
					logFileNumber++;

					if (SanityManager.DEBUG)
					{
						SanityManager.ASSERT(endPosition == LOG_FILE_HEADER_SIZE,
											 ""empty log file has wrong size"");
					}

				}
				else	// something went wrong, delete the half baked file
				{
					newLog.close();
					newLog = null;

					if (privExists(newLogFile))
					    privDelete(newLogFile);

					logErrMsg(MessageService.getTextMessage(
                        MessageId.LOG_CANNOT_CREATE_NEW,
                        newLogFile.getPath()));
					newLogFile = null;
 				}

			}
			catch (IOException ioe)
			{

				inLogSwitch = false;
				// switching log file is an optional operation and there is no direct user
				// control.  Just sends a warning message to whomever, if any,
				// system adminstrator there may be

                logErrMsg(MessageService.getTextMessage(
                    MessageId.LOG_CANNOT_CREATE_NEW_DUETO,
                    newLogFile.getPath(),
                    ioe.toString()));

				try
				{
					if (newLog != null)
					{
						newLog.close();
						newLog = null;
					}
				}
				catch (IOException ioe2) {}

                if (newLogFile != null && privExists(newLogFile))
				{
                    privDelete(newLogFile);
					newLogFile = null;
				}

				if (switchedOver)	// error occur after old log file has been closed!
				{
					logOut = null; // limit any damage
					throw markCorrupt(
                        StandardException.newException(
                                SQLState.LOG_IO_ERROR, ioe));
				}
			}
			
            // Replication slave: Recovery thread should be allowed to
            // read the previous log file
            if (inReplicationSlaveMode) {
                allowedToReadFileNumber = logFileNumber-1;
                synchronized (slaveRecoveryMonitor) {
                    slaveRecoveryMonitor.notify();
                }
            }
			inLogSwitch = false;
		}
		// unfreezes the log
	}"
149,822,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.Heap,,openScan,,StandardException,"StandardException,newException",772,772,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/Heap.java#L772,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/Heap.java,,close,"public ScanManager openScan(
    TransactionManager              xact_manager,
    Transaction                     rawtran,
    boolean                         hold,
    int                             open_mode,
    int                             lock_level,
    LockingPolicy                   locking_policy,
    int                             isolation_level,
	FormatableBitSet				scanColumnList,
    DataValueDescriptor[]	        startKeyValue,
    int                             startSearchOperator,
    Qualifier                       qualifier[][],
    DataValueDescriptor[]	        stopKeyValue,
    int                             stopSearchOperator,
    StaticCompiledOpenConglomInfo   static_info,
    DynamicCompiledOpenConglomInfo  dynamic_info)
		throws StandardException
	{
        if (SanityManager.DEBUG) {
            if ((open_mode &
                    TransactionController.OPENMODE_LOCK_ROW_NOWAIT) != 0) {
                SanityManager.THROWASSERT(
                    ""Bad open mode to Heap#openScan:"" +
                    Integer.toHexString(open_mode));
            }
        }

        // Heap scans do not suppport start and stop scan positions (these
        // only make sense for ordered storage structures).
		if (!RowUtil.isRowEmpty(startKeyValue)
			|| !RowUtil.isRowEmpty(stopKeyValue))
		{
            throw StandardException.newException(
                    SQLState.HEAP_UNIMPLEMENTED_FEATURE);
		}

        OpenConglomerate open_conglom = new OpenHeap();

        if (open_conglom.init(
                (ContainerHandle) null,
                this,
                this.format_ids,
                this.collation_ids,
                xact_manager,
                rawtran,
                hold,
                open_mode,
                lock_level,
                locking_policy,
                dynamic_info) == null)
        {
            throw StandardException.newException(
                    SQLState.HEAP_CONTAINER_NOT_FOUND, 
                    new Long(id.getContainerId()));
        }

		HeapScan heapscan = new HeapScan();

        heapscan.init(
            open_conglom,
            scanColumnList,
            startKeyValue,
            startSearchOperator,
            qualifier,
            stopKeyValue,
            stopSearchOperator);

		return(heapscan);
	}"
150,823,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.xplain,org.apache.derby.impl.sql.execute.xplain.XPLAINUtil,,extractSortProps,,Integer,"Integer,descriptor,ir_property,setNo_input_rows",387,387,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java#L387,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINUtil.java,,close,"public static XPLAINSortPropsDescriptor extractSortProps(
             XPLAINSortPropsDescriptor descriptor,
             Properties sortProps){
         
         String sort_type = null;
         String sort_type_property = sortProps.getProperty(
                 MessageService.getTextMessage(SQLState.STORE_RTS_SORT_TYPE));
         if(sort_type_property!=null){
         if(sort_type_property.equalsIgnoreCase(
             MessageService.getTextMessage(SQLState.STORE_RTS_EXTERNAL))){
             sort_type = SORT_EXTERNAL;
         } else {
             sort_type = SORT_INTERNAL;
         }}
         descriptor.setSort_type(sort_type);

         
         String ir_property = sortProps.getProperty(
                 MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_INPUT));
         if(ir_property!=null){
              descriptor.setNo_input_rows(new Integer(ir_property));
         }

          String or_property = sortProps.getProperty(
                  MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_OUTPUT));
          if(or_property!=null){
               descriptor.setNo_output_rows(new Integer(or_property));
          }
              
          if (sort_type == SORT_EXTERNAL){
              String nomr_property = sortProps.getProperty(
              MessageService.getTextMessage(SQLState.STORE_RTS_NUM_MERGE_RUNS));
              
              if(nomr_property!=null){
                 descriptor.setNo_merge_runs(new Integer(nomr_property));
              }
             
              String nomrd_property = sortProps.getProperty(
              MessageService.getTextMessage(SQLState.STORE_RTS_MERGE_RUNS_SIZE));
              
              if(nomrd_property!=null){
                  descriptor.setMerge_run_details(nomrd_property);
              }
          
         }
         
         return descriptor;
     }"
151,825,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SQLSmallint,,getObject,,Integer,"Integer,value",161,161,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SQLSmallint.java#L161,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SQLSmallint.java,,close,"public Object	getObject() 
	{
		if (isNull())
			return null;
		else
			return new Integer(value);
	}"
152,830,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealHashLeftOuterJoinStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,115,115,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashLeftOuterJoinStatistics.java#L115,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashLeftOuterJoinStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                           // index updates
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // affected rows
           null,                              // deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeenLeft),
           new Integer(this.rowsSeenRight),
           new Integer(this.rowsFiltered),
           new Integer(this.rowsReturned),
           new Integer(this.emptyRightRowsReturned),
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
153,840,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.StoredPage,,validateChecksum,,throw StandardException.newException(,,917,917,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/StoredPage.java#L917,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/StoredPage.java,,close,"protected void validateChecksum(PageKey id) 
        throws StandardException
    {
        long onDiskChecksum;

        try 
        {
            // read the checksum stored on the page on disk.  It is stored
            // in the last ""CHECKSUM_SIZE"" bytes of the page, and is a long.

            rawDataIn.setPosition(getPageSize() - CHECKSUM_SIZE);
            onDiskChecksum = rawDataIn.readLong();
        } 
        catch (IOException ioe) 
        {

            // i/o methods on the byte array have thrown an IOException
            throw dataFactory.markCorrupt(
                StandardException.newException(
                    SQLState.DATA_CORRUPT_PAGE, ioe, id));
        }

        // Force the checksum to be recalculated based on the current page.
        checksum.reset();
        checksum.update(pageData, 0, getPageSize() - CHECKSUM_SIZE);
        
        // force a bad checksum error
        if (SanityManager.DEBUG)
        {
            if (SanityManager.DEBUG_ON(""TEST_BAD_CHECKSUM""))
            {
                // set on disk checksum to wrong value
                onDiskChecksum = 123456789; 
            }
        }

        if (onDiskChecksum != checksum.getValue())
        {
            // try again using new checksum object to be doubly sure
            CRC32 newChecksum = new CRC32();
            newChecksum.reset();
            newChecksum.update(pageData, 0, getPageSize()-CHECKSUM_SIZE);
            if (onDiskChecksum != newChecksum.getValue())
            {
                throw StandardException.newException(
                    SQLState.FILE_BAD_CHECKSUM,
                    id, 
                    new Long(checksum.getValue()), 
                    new Long(onDiskChecksum), 
                    pagedataToHexDump(pageData));
            }
            else
            {
                // old one is bad, get rid of it
                if (SanityManager.DEBUG)
                    SanityManager.THROWASSERT(""old checksum gets wrong value"");

                checksum = newChecksum;
            }
        }
    }"
154,844,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealHashScanStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,367,367,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java#L367,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        String lockMode = XPLAINUtil.getLockModeCode(this.lockString);
        String lockGran = XPLAINUtil.getLockGranularityCode(this.lockString);
        
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),            // the number of opens
           null,                           // the number of index updates 
           lockMode,                       // lock mode
           lockGran,                       // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeen),            // the seen rows
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),        // the filtered rows
           new Integer(this.rowsSeen-this.rowsFiltered),// the returned rows
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
155,846,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealNoRowsResultSetStatistics,,getResultSetTimingsDescriptor,,XPLAINResultSetTimingsDescriptor,XPLAINResultSetTimingsDescriptor,175,175,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealNoRowsResultSetStatistics.java#L175,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealNoRowsResultSetStatistics.java,,close,"public Object getResultSetTimingsDescriptor(Object timingID)
    {
        return new XPLAINResultSetTimingsDescriptor(
           (UUID)timingID,
           null,                                   // the constructor time
           null,                                   // the open time
           null,                                   // the next time
           null,                                   // the close time
           new Long(this.executeTime),             // the execute time
           null,                                   // the avg next time/row
           null,                                   // the projection time
           null,                                   // the restriction time
           null,                                   // the temp_cong_create_time
           null                                    // the temo_cong_fetch_time
        );
    }"
156,847,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealHashTableStatistics,,getScanPropsDescriptor,,XPLAINScanPropsDescriptor scanRSDescriptor =,,312,312,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashTableStatistics.java#L312,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashTableStatistics.java,,close,"public Object getScanPropsDescriptor(Object scanPropsID)
    {
        FormatableProperties props = this.scanProperties;
        
        String isoLevel = XPLAINUtil.getIsolationLevelCode(this.isolationLevel);
        
        String hashkey_columns =
            XPLAINUtil.getHashKeyColumnNumberString(this.hashKeyColumns);
        
        // create new scan info descriptor with some basic information
        XPLAINScanPropsDescriptor scanRSDescriptor =            
              new XPLAINScanPropsDescriptor(
              (UUID)scanPropsID,      // the scan props UUID
              ""Temporary HashTable"", // the index/table name
              null,             // the scan object, either (C)onstraint, (I)ndex or (T)able
              null,             // the scan type: heap, btree, sort
              isoLevel,         // the isolation level
              null,             // the number of visited pages
              null,             // the number of visited rows
              null,             // the number of qualified rows
              null,             // the number of visited deleted rows
              null,             // the number of fetched columns
              null,             // the bitset of fetched columns
              null,             // the btree height
              null,             // the fetch size
              null,                          // the start position, internal encoding
              null,                          // the stop position, internal encoding
              null,                          // the scan qualifiers
              this.nextQualifiers,     // the next qualifiers
              hashkey_columns,               // the hash key column numbers
              new Integer(this.hashtableSize) // the hash table size
            );
        
        // fill additional information from scan properties
        return XPLAINUtil.extractScanProps(scanRSDescriptor,props);
    }"
157,857,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.load,org.apache.derby.impl.load.Import,,formatImportError,,StandardException,"StandardException,newException",335,335,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/load/Import.java#L335,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/load/Import.java,,close,"private static  SQLException    formatImportError( Import importer, String inputFile, Throwable t )
    {
        int     lineNumber = -1;

        if ( importer != null ) { lineNumber = importer.getCurrentLineNumber(); }
        
        StandardException se = StandardException.newException
            ( SQLState.UNEXPECTED_IMPORT_ERROR, new Integer( lineNumber ), inputFile, t.getMessage() );
        se.initCause(t);

        return PublicAPI.wrapStandardException(se);
    }"
158,863,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.xplain,org.apache.derby.impl.sql.execute.xplain.XPLAINSystemTableVisitor,,doXPLAIN,,XPLAINStatementTimingsDescriptor,"XPLAINStatementTimingsDescriptor,stmtTimings",211,211,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java#L211,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/xplain/XPLAINSystemTableVisitor.java,,close,"public void doXPLAIN(RunTimeStatistics rss, Activation activation)
        throws StandardException
    {
         // save this activation
         this.activation = activation;
         
         // reset this visitor
         reset();
         
         // get the timings settings
         considerTimingInformation = lcc.getStatisticsTiming();
         
         // placeholder for the stmt timings UUID 
         UUID stmtTimingsUUID = null;
         
         //1. create new stmt timings descriptor 
         if (considerTimingInformation){
             stmtTimingsUUID = dd.getUUIDFactory().createUUID();
             Timestamp endExeTS   = rss.getEndExecutionTimestamp();
             Timestamp beginExeTS = rss.getBeginExecutionTimestamp();
             long exeTime;
             if (endExeTS!=null && beginExeTS!=null){
                 exeTime = endExeTS.getTime() - beginExeTS.getTime();
             } else {
                 exeTime = 0;
             }
             
             stmtTimings = new XPLAINStatementTimingsDescriptor(
                 stmtTimingsUUID,                    // the Timing UUID
                 new Long(rss.getParseTimeInMillis()),         // the Parse Time
                 new Long(rss.getBindTimeInMillis()),          // the Bind Time
                 new Long(rss.getOptimizeTimeInMillis()),      // the Optimize Time
                 new Long(rss.getGenerateTimeInMillis()),      // the Generate Time
                 new Long(rss.getCompileTimeInMillis()),       // the Compile Time
                 new Long(exeTime),                            // the Execute Time, TODO resolve why getExecutionTime() returns 0
                 rss.getBeginCompilationTimestamp(), // the Begin Compilation TS
                 rss.getEndCompilationTimestamp(),   // the End   Compilation TS
                 rss.getBeginExecutionTimestamp(),   // the Begin Execution   TS
                 rss.getEndExecutionTimestamp()      // the End   Execution   TS
             );
         }
         
         // 2. create new Statement Descriptor 

         // create new UUID
         stmtUUID = dd.getUUIDFactory().createUUID();
         // extract stmt type
         String type = XPLAINUtil.getStatementType(rss.getStatementText());
         
         // don`t explain CALL Statements, quick implementation
         // TODO improve usability to switch between call stmt explanation on or off
         if (type.equalsIgnoreCase(""C"") && no_call_stmts) return;
         
         // get transaction ID
         String xaID = lcc.getTransactionExecute().getTransactionIdString();
         // get session ID
         String sessionID = Integer.toString(lcc.getInstanceNumber());
         // get the JVM ID
         String jvmID = Integer.toString(JVMInfo.JDK_ID); 
         // get the OS ID 
         String osID  = System.getProperty(""os.name""); 
         // the current system time
         long current = System.currentTimeMillis();
         // the xplain type
         String XPLAINtype = lcc.getXplainOnlyMode() ?
             XPLAINUtil.XPLAIN_ONLY : XPLAINUtil.XPLAIN_FULL;
         // the xplain time
         Timestamp time = new Timestamp(current);
         // the thread id
         String threadID = Thread.currentThread().toString();
         
         stmt = new XPLAINStatementDescriptor(
            stmtUUID,               // unique statement UUID
            rss.getStatementName(), // the statement name
            type,                   // the statement type
            rss.getStatementText(), // the statement text
            jvmID,                  // the JVM ID
            osID,                   // the OS ID
            XPLAINtype,             // the EXPLAIN tpye
            time,                   // the EXPLAIN Timestamp
            threadID,               // the Thread ID
            xaID,                   // the transaction ID
            sessionID,              // the Session ID
            lcc.getDbname(),        // the Database name
            lcc.getDrdaID(),        // the DRDA ID
            stmtTimingsUUID         // Timing ID, if available
            );
         
        try {
         // add it to system catalog
         addStmtDescriptorsToSystemCatalog();                 
         
         // get TopRSS and start the traversal of the RSS-tree
         rss.acceptFromTopResultSet(this);
         
         // add the filled lists to the dictionary
         addArraysToSystemCatalogs();
        }
        catch (SQLException e)
        {
            throw StandardException.plainWrapException(e);
        }
         
         // clean up to free kept resources
         clean();
    }"
159,865,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,findConglomerate,,Long,"Long,conglom,conglomId,tempCongloms,get",409,409,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L409,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"private Conglomerate findConglomerate(long conglomId)
		throws StandardException
	{
		Conglomerate conglom = null;

		if (conglomId >= 0)
        {
            conglom = accessmanager.conglomCacheFind(this, conglomId);
        }
        else
		{
			if (tempCongloms != null)
				conglom = (Conglomerate) tempCongloms.get(new Long(conglomId));
		}

        return(conglom);
	}"
160,876,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.Util,,newBatchUpdateException,,constructor,"constructor,newInstance",385,385,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/Util.java#L385,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/Util.java,,unknown,"static  SQLException    newBatchUpdateException
        ( String message, String sqlState, int errorCode, long[] updateCounts, Throwable cause )
    {
        if ( JVMInfo.JDK_ID >= JVMInfo.J2SE_18 )
        {
            try {
                Constructor constructor = BatchUpdateException.class.getConstructor
                    (
                     new Class[] { String.class, String.class, Integer.TYPE, updateCounts.getClass(), Throwable.class }
                     );

                return (BatchUpdateException) constructor.newInstance
                    ( new Object[] { message, sqlState, new Integer( errorCode ), updateCounts, cause } );
            }
            catch (Exception e)
            {
                // unanticipated problem. log it and return the Java 7 version of the exception
                logError( ""\nERROR "" +  e.getMessage() + ""\n"", e );
            }
        }

        // use this constructor if we're not on Java 8 or if an error occurred
        // while using the Java 8 constructor
        BatchUpdateException batch = new BatchUpdateException
            ( message, sqlState, errorCode, squashLongs( updateCounts ) );
        
        if ( cause instanceof SQLException ) { batch.setNextException( (SQLException) cause ); }
        batch.initCause( cause );

        return batch;
    }"
161,881,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealScalarAggregateStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,185,185,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealScalarAggregateStatistics.java#L185,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealScalarAggregateStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           new Integer(this.rowsInput),
           new Integer(this.rowsSeen),
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),
           new Integer(this.rowsInput - this.rowsFiltered),
           null,                              // the empty right rows
           this.indexKeyOptimization?""Y"":""N"",
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
162,883,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.FileContainer,,readHeaderFromArray,,throw StandardException.newException(,,793,793,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java#L793,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java,,close,"private void readHeaderFromArray(byte[] a)
		 throws StandardException, IOException
	{
		ArrayInputStream inStream = new ArrayInputStream(a);

		inStream.setLimit(CONTAINER_INFO_SIZE);
		int fid = inStream.readInt();
		if (fid != formatIdInteger)
        {
			throw StandardException.newException(
                SQLState.DATA_UNKNOWN_CONTAINER_FORMAT, getIdentity(), 
                new Long(fid));
        }

		int status = inStream.readInt();
		pageSize = inStream.readInt();
		spareSpace = inStream.readInt();
		minimumRecordSize = inStream.readInt();
		initialPages = inStream.readShort(); 
		PreAllocSize = inStream.readShort();
		firstAllocPageNumber = inStream.readLong();
		firstAllocPageOffset = inStream.readLong();
		containerVersion = inStream.readLong();
		estimatedRowCount = inStream.readLong();
		reusableRecordIdSequenceNumber = inStream.readLong();
		lastLogInstant = null;

		if (PreAllocSize == 0)	// pre 2.0, we don't store this.
			PreAllocSize = DEFAULT_PRE_ALLOC_SIZE;

		long spare3 = inStream.readLong();	// read spare long

		// upgrade - if this is a container that was created before
		// initialPages was stored, it will have a zero value.  Set it to the
		// default of 1.
		if (initialPages == 0)	
			initialPages = 1;

		// container read in from disk, reset preAllocation values
		PreAllocThreshold = PRE_ALLOC_THRESHOLD;

		// validate checksum
		long onDiskChecksum = inStream.readLong();
		checksum.reset();
		checksum.update(a, 0, CONTAINER_INFO_SIZE - CHECKSUM_SIZE);

		if (onDiskChecksum != checksum.getValue())
		{
			PageKey pk = new PageKey(identity, FIRST_ALLOC_PAGE_NUMBER);

			throw dataFactory.markCorrupt
				(StandardException.newException(
                    SQLState.FILE_BAD_CHECKSUM, 
                    pk, 
                    new Long(checksum.getValue()), 
                    new Long(onDiskChecksum), 
                    org.apache.derby.iapi.util.StringUtil.hexDump(a)));
		}

		allocCache.reset();

		// set the in memory state
		setDroppedState((status & FILE_DROPPED) != 0);
		setCommittedDropState((status & FILE_COMMITTED_DROP) != 0);
		setReusableRecordIdState((status & FILE_REUSABLE_RECORDID) != 0);
	}"
163,888,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,addColumnToConglomerate,,StandardException,"StandardException,newException",594,594,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L594,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"public void addColumnToConglomerate(
    long        conglomId,
    int         column_id,
    Storable    template_column,
    int         collation_id)
		throws StandardException
    {
        boolean is_temporary = (conglomId < 0);

		Conglomerate conglom = findConglomerate(conglomId);
		if (conglom == null)
        {
			throw StandardException.newException(
                SQLState.AM_NO_SUCH_CONGLOMERATE_DROP, new Long(conglomId));
        }

        // Get exclusive lock on the table being altered.
		ConglomerateController cc =
            conglom.open(
                this, rawtran, false, OPENMODE_FORUPDATE,
                MODE_TABLE,
                accessmanager.table_level_policy[
                    TransactionController.ISOLATION_SERIALIZABLE],
                (StaticCompiledOpenConglomInfo) null,
                (DynamicCompiledOpenConglomInfo) null);

		conglom.addColumn(this, column_id, template_column, collation_id);

        // Set an indication that ALTER TABLE has been called so that the
        // conglomerate will be invalidated if an error happens. Only needed
        // for non-temporary conglomerates, since they are the only ones that
        // live in the conglomerate cache.
        if (!is_temporary)
		{
            alterTableCallMade = true;
        }

        cc.close();

        return;
    }"
164,890,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedStatement,,setFetchDirection,,"throw newSQLException(SQLState.INVALID_FETCH_DIRECTION,",,905,905,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java#L905,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java,,close,"public void setFetchDirection(int direction) throws SQLException {
		
		checkStatus();
                /* fetch direction is meaningless to us. we just save
                 * it off if it is valid  and return the current value if asked.
                 */
                if (direction == java.sql.ResultSet.FETCH_FORWARD || 
                    direction == java.sql.ResultSet.FETCH_REVERSE ||
                    direction == java.sql.ResultSet.FETCH_UNKNOWN )
                {
                    fetchDirection = direction;
                }else
                    throw newSQLException(SQLState.INVALID_FETCH_DIRECTION, 
                                   new Integer(direction));
	}"
165,898,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,dropConglomerate,,Long,"Long,conglomId,tempCongloms,remove",1000,1000,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L1000,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"public void dropConglomerate(long conglomId)
		throws StandardException
	{
		Conglomerate conglom = findExistingConglomerate(conglomId);

		conglom.drop(this);

		if (conglomId < 0)
		{
			if (tempCongloms != null)
				tempCongloms.remove(new Long(conglomId));
		}
		else
        {
			accessmanager.conglomCacheRemoveEntry(conglomId);
        }
	}"
166,901,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedResultSet,,setFetchSize,,"throw Util.generateCsSQLException(SQLState.INVALID_FETCH_SIZE,",,2300,2300,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java#L2300,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java,,close,"public void setFetchSize(int rows) throws SQLException {
		checkIfClosed(""setFetchSize"");
		if (rows < 0) {
			throw Util.generateCsSQLException(SQLState.INVALID_FETCH_SIZE,
					new Integer(rows));
		} else if (rows > 0) // if it is zero ignore the call
		{
			fetchSize = rows;
		}
	}"
167,904,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.HarmonySerialBlob,,getBinaryStream,,Object,"Object,SQLState,makeSQLException,BLOB_NONPOSITIVE_LENGTH",245,245,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java#L245,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/HarmonySerialBlob.java,,close,"public InputStream getBinaryStream() throws SQLException {
        return new ByteArrayInputStream(buf);
    }"
168,905,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.PageBasicOperation,,needsRedo,,StandardException,"StandardException,newException",165,165,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/PageBasicOperation.java#L165,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/PageBasicOperation.java,,close,"public final boolean needsRedo(Transaction xact)
		 throws StandardException
	{
		if (findpage(xact) == null)	// committed dropped container
			return false;

		long pversion = page.getPageVersion();
		if (pversion == pageVersion)
			return true;

		releaseResource(xact);

		if (pversion > pageVersion)
			return false;
		else
			throw StandardException.newException(
                    SQLState.DATA_MISSING_LOG, pageId, 
                    new Long(pversion), 
                    new Long(pageVersion));
	}"
169,907,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealJoinResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,112,112,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealJoinResultSetStatistics.java#L112,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealJoinResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                           // index updates
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // affected rows
           null,                              // deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeenLeft),
           new Integer(this.rowsSeenRight),
           new Integer(this.rowsFiltered),
           new Integer(this.rowsReturned),
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
170,915,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealHashScanStatistics,,getScanPropsDescriptor,,XPLAINScanPropsDescriptor scanRSDescriptor =,,334,334,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java#L334,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealHashScanStatistics.java,,close,"public Object getScanPropsDescriptor(Object scanPropsID)
    {
        String scanObjectType, scanObjectName;

        if(this.indexName!=null){
            if(this.isConstraint){
                scanObjectType = ""C"";  // constraint
                scanObjectName = this.indexName;
            } else {
                scanObjectType = ""I"";  // index
                scanObjectName = this.indexName;
            }
        } else {
            scanObjectType = ""T"";      // table
            scanObjectName = this.tableName;
        }
        
        String isoLevel = XPLAINUtil.getIsolationLevelCode(this.isolationLevel);
        String hashkey_columns =
            XPLAINUtil.getHashKeyColumnNumberString(this.hashKeyColumns);
        
        XPLAINScanPropsDescriptor scanRSDescriptor =            
              new XPLAINScanPropsDescriptor(
              (UUID)scanPropsID,      // the scan props UUID
              scanObjectName,
              scanObjectType,
              null,             // the scan type: heap, btree, sort
              isoLevel,         // the isolation level
              null,             // the number of visited pages
              null,             // the number of visited rows
              null,             // the number of qualified rows
              null,             // the number of visited deleted rows
              null,             // the number of fetched columns
              null,             // the bitset of fetched columns
              null,             // the btree height
              null,             // the fetch size
              this.startPosition,
              this.stopPosition,
              this.scanQualifiers,
              this.nextQualifiers,
              hashkey_columns,
              new Integer(this.hashtableSize)
            );
        
        FormatableProperties props = this.scanProperties;

        return XPLAINUtil.extractScanProps(scanRSDescriptor,props);
    }"
171,921,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,,findExistingConglomerate,,StandardException,"StandardException,newException",387,387,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L387,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,close,"private Conglomerate findExistingConglomerate(long conglomId)
		throws StandardException
	{
		Conglomerate conglom = findConglomerate(conglomId);

		if (conglom == null)
        {
			throw StandardException.newException(
                SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
                new Long(conglomId));
        }
        else
        {
            return(conglom);
        }
	}"
172,929,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.HeapController,,load,,StandardException,"StandardException,newException",364,364,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/HeapController.java#L364,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/HeapController.java,,close,"protected long load(
    TransactionManager      xact_manager,
    Heap                    heap,
    boolean                 createConglom,
    RowLocationRetRowSource rowSource)
		 throws StandardException
	{
        long    num_rows_loaded = 0;

		if (SanityManager.DEBUG)
        {
			SanityManager.ASSERT(open_conglom == null,
				""load expects container handle to be closed on entry."");
        }

		// The individual rows that are inserted are not logged.  To use a
		// logged interface, use insert.  RESOLVE: do we want to allow client
		// to use the load interface even for logged insert?
		int mode = 
            (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_UNLOGGED); 

		// If the container is being created in the same operation, don't log
		// page allocation.  
		if (createConglom)
			mode |= ContainerHandle.MODE_CREATE_UNLOGGED;

        OpenConglomerate open_conglom = new OpenHeap();

        if (open_conglom.init(
                (ContainerHandle) null,
                heap,
                heap.format_ids,
                heap.collation_ids,
                xact_manager,
                xact_manager.getRawStoreXact(),
                false,
                mode,
                TransactionController.MODE_TABLE,
                xact_manager.getRawStoreXact().newLockingPolicy(
                    LockingPolicy.MODE_CONTAINER,
                    TransactionController.ISOLATION_SERIALIZABLE, true),
                (DynamicCompiledOpenConglomInfo) null) == null)
        {
            throw StandardException.newException(
                    SQLState.HEAP_CONTAINER_NOT_FOUND, 
                    new Long(heap.getId().getContainerId()));
        }

        this.init(open_conglom);

		// For bulk loading, we always use only brand new page because the row
		// insertion itself is not logged.  We cannot pollute pages with
		// pre-existing data with unlogged rows because nobody is going to wipe
		// out these rows if the transaction rolls back.  We are counting on
		// the allocation page rollback to obliterate these rows if the
		// transaction fails, or, in the CREAT_UNLOGGED case, the whole
		// container to be removed.

		Page page = open_conglom.getContainer().addPage();

		boolean callbackWithRowLocation = rowSource.needsRowLocation();
		RecordHandle rh;
		HeapRowLocation rowlocation;

		if (callbackWithRowLocation)
			rowlocation = new HeapRowLocation();
		else
			rowlocation = null;

        FormatableBitSet validColumns = rowSource.getValidColumns();

		try
		{
 			// get the next row and its valid columns from the rowSource
			DataValueDescriptor[] row;
            while ((row = rowSource.getNextRowFromRowSource()) != null)
            {
                num_rows_loaded++;

                if (SanityManager.DEBUG)
                {
                    // Make sure valid columns are in the list.  The RowUtil
                    // call is too expensive to make in a released system for 
                    // every insert.
                    int invalidColumn = 
                        RowUtil.columnOutOfRange(
                            row, validColumns, heap.format_ids.length);

                    if (invalidColumn >= 0)
                    {
                        throw(StandardException.newException(
                                SQLState.HEAP_TEMPLATE_MISMATCH,
                                new Long(invalidColumn), 
                                new Long(heap.format_ids.length)));
                    }
                }


				// Insert it onto this page as long as it can fit more rows.
				if ((rh = page.insert(
                        row, validColumns, Page.INSERT_DEFAULT,
						AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD)) 
                                == null)
				{
					// Insert faied, row did not fit.  Get a new page.  

					page.unlatch();
					page = null;

					page = open_conglom.getContainer().addPage();

					// RESOLVE (mikem) - no long rows yet so the following code
					// will get an exception from the raw store for a row that
					// does not fit on a page.
					//
					// Multi-thread considerations aside, the raw store will 
                    // guarantee that any size row will fit on an empty page.
					rh = page.insert(
                            row, validColumns, Page.INSERT_OVERFLOW,
							AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);

				}

				// Else, the row fit.  If we are expected to call back with the
				// row location, do so.  All the while keep the page latched
				// and go for the next row.
				if (callbackWithRowLocation)
				{
					rowlocation.setFrom(rh);
					rowSource.rowLocation(rowlocation);
				}
			}
			page.unlatch();
			page = null;

			// Done with the container, now we need to flush it to disk since
			// it is unlogged.
            if (!heap.isTemporary())
                open_conglom.getContainer().flushContainer();
		}
		finally
		{
            // If an error happened here, don't bother flushing the
            // container since the changes should be rolled back anyhow.
            close();
		}
        return(num_rows_loaded);
	}"
173,930,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.tools.ij,org.apache.derby.impl.tools.ij.mtGrammar,,getError,,Integer,"Integer,errorList,s,put",268,268,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//generated/java/org/apache/derby/impl/tools/ij/mtGrammar.java#L268,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//generated/java/org/apache/derby/impl/tools/ij/mtGrammar.java,,unknown,
174,938,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.access.heap,org.apache.derby.impl.store.access.heap.HeapConglomerateFactory,,readConglomerate,,StandardException,"StandardException,newException",254,254,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/access/heap/HeapConglomerateFactory.java#L254,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/heap/HeapConglomerateFactory.java,,close,"public Conglomerate readConglomerate(
    TransactionManager      xact_mgr,
    ContainerKey            container_key)
		throws StandardException
    {
        ContainerHandle         container   = null;
        Page                    page        = null;
        DataValueDescriptor[]   control_row = new DataValueDescriptor[1];

        try
        {
            // open container to read the Heap object out of it's control row.
            container = 
                xact_mgr.getRawStoreXact().openContainer(
                    container_key, (LockingPolicy) null, 0);

            if (container == null)
            {
                throw StandardException.newException(
                    SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST,
                    new Long(container_key.getContainerId()));
            }

            // row in slot 0 of heap page 1 which is just a single column with
            // the heap entry.
            control_row[0]       = new Heap();

            page = container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);

            RecordHandle rh = 
                page.fetchFromSlot(
                   (RecordHandle) null, 0, control_row, 
                   (FetchDescriptor) null,
                   true);

            if (SanityManager.DEBUG)
            {
                SanityManager.ASSERT(rh != null);

                // for now the control row is always the first id assigned on
                // page 1.
                SanityManager.ASSERT(rh.getId() == 6);
            }
        }
        finally
        {
            if (page != null)
                page.unlatch();

            if (container != null)
                container.close();
        }

        return((Conglomerate) control_row[0]);
    }"
175,941,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.execute.rts,org.apache.derby.impl.sql.execute.rts.RealBasicNoPutResultSetStatistics,,getResultSetDescriptor,,XPLAINResultSetDescriptor,XPLAINResultSetDescriptor,217,217,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java#L217,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/rts/RealBasicNoPutResultSetStatistics.java,,close,"public Object getResultSetDescriptor(Object rsID, Object parentID,
            Object scanID, Object sortID, Object stmtID, Object timingID)
    {
        return new XPLAINResultSetDescriptor(
           (UUID)rsID,
           getRSXplainType(),
           getRSXplainDetails(),
           new Integer(this.numOpens),
           null,                              // the number of index updates 
           null,                           // lock mode
           null,                           // lock granularity
           (UUID)parentID,
           new Double(this.optimizerEstimatedRowCount),
           new Double(this.optimizerEstimatedCost),
           null,                              // the affected rows
           null,                              // the deferred rows
           null,                              // the input rows
           new Integer(this.rowsSeen),
           null,                              // the seen rows right
           new Integer(this.rowsFiltered),
           new Integer(this.rowsSeen - this.rowsFiltered),
           null,                              // the empty right rows
           null,                           // index key optimization
           (UUID)scanID,
           (UUID)sortID,
           (UUID)stmtID,
           (UUID)timingID);
    }"
176,960,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedParameterSetMetaData,,checkPosition,,Util,"Util,generateCsSQLException",216,216,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedParameterSetMetaData.java#L216,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedParameterSetMetaData.java,,close,"private void checkPosition(int parameterIndex) throws SQLException {
   		/* Check that the parameterIndex is in range. */
   		if (parameterIndex < 1 ||
				parameterIndex > paramCount) {

			/* This message matches the one used by the DBMS */
			throw Util.generateCsSQLException(
            SQLState.LANG_INVALID_PARAM_POSITION,
            new Integer(parameterIndex), new Integer(paramCount));
		}
    }"
177,964,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.BaseContainer,,addPage,,StandardException,"StandardException,newException",300,300,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java#L300,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java,,close,"public Page addPage(BaseContainerHandle handle, boolean isOverflow) throws StandardException {
		
		RawTransaction ntt = handle.getTransaction().startNestedTopTransaction();

		int mode = handle.getMode(); 

		if (SanityManager.DEBUG)
		{
			SanityManager.ASSERT((mode & ContainerHandle.MODE_FORUPDATE) ==
								 ContainerHandle.MODE_FORUPDATE, 
								 ""addPage handle not for update"");
		}

		// if we are not in the same transaction as the one which created the
		// container and the container may have logged some operation already, 
		// then we need to log allocation regardless of whether user changes
		// are logged.  Otherwise, the database will be corrupted if it
		// crashed. 
		if ((mode & ContainerHandle.MODE_CREATE_UNLOGGED) == 0 &&
			(mode & ContainerHandle.MODE_UNLOGGED) ==
						ContainerHandle.MODE_UNLOGGED) 
			mode &= ~ContainerHandle.MODE_UNLOGGED;

		// make a handle which is tied to the ntt, not to the user transaction this
		// handle is tied to.  The container is already locked by the user transaction,
		// open it nolock
		BaseContainerHandle allocHandle = (BaseContainerHandle)ntt.openContainer
			(identity, (LockingPolicy)null, mode);

		if (allocHandle == null)
        {
			throw StandardException.newException(
                    SQLState.DATA_ALLOC_NTT_CANT_OPEN, 
                    new Long(getSegmentId()), 
                    new Long(getContainerId()));
        }

		// Latch this container, the commit will release the latch
		CompatibilitySpace cs = ntt.getCompatibilitySpace();
		ntt.getLockFactory().lockObject(
                cs, ntt, this, null, C_LockFactory.WAIT_FOREVER);

		BasePage newPage = null;
		try
		{
			newPage = newPage(handle, ntt, allocHandle, isOverflow);
		}
		finally
		{
			if (newPage != null)
            {
                // it is ok to commit without syncing, as it is ok if this
                // transaction never makes it to the db, if no subsequent
                // log record makes it to the log.  If any subsequent log
                // record is sync'd then this transaction will be sync'd
                // as well.
				ntt.commitNoSync(Transaction.RELEASE_LOCKS);
            }
			else
            {      
				ntt.abort();
            }
			ntt.close();
		}

		if (SanityManager.DEBUG) {
			SanityManager.ASSERT(newPage.isLatched());
		}

		if (!this.identity.equals(newPage.getPageId().getContainerId())) {

			if (SanityManager.DEBUG) {
				SanityManager.THROWASSERT(""BaseContainer.addPage(), just got a new page from a different container""
					+ ""\n this.identity = "" + this.identity
					+ ""\n newPage.getPageId().getContainerId() = "" + newPage.getPageId().getContainerId()
					+ ""\n handle is: "" + handle
					+ ""\n allocHandle is: "" + allocHandle
					+ ""\n this container is: "" + this);
			}

			throw StandardException.newException(
                    SQLState.DATA_DIFFERENT_CONTAINER,
                    this.identity, newPage.getPageId().getContainerId());
		}

		return newPage;
	}"
178,972,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.SequenceGenerator,,peekAtCurrentValue,,Long,"Long,_currentValue,_isExhausted,currentValue",277,277,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/catalog/SequenceGenerator.java#L277,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/SequenceGenerator.java,,close,"public synchronized Long peekAtCurrentValue()
    {
        Long currentValue = null;

        if ( !_isExhausted ) { currentValue = new Long( _currentValue ); }
        
        return currentValue;
    }"
179,977,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.CachedPage,,readPage,,StandardException se =,,697,697,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/CachedPage.java#L697,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/CachedPage.java,,close,"private void readPage(
    FileContainer   myContainer, 
    PageKey         newIdentity) 
        throws StandardException 
	{
		int pagesize = myContainer.getPageSize();

        // we will reuse the existing page array if it is same size, the
        // cache does support caching various sized pages.
		setPageArray(pagesize);

		for (int io_retry_count = 0;;)
        {
			try 
            {
				myContainer.readPage(newIdentity.getPageNumber(), pageData);
				break;
			} 
            catch (IOException ioe) 
            {
				io_retry_count++;	
								
				// Retrying read I/O's has been found to be successful sometimes
                // in completing the read without having to fail the calling
                // query, and in some cases avoiding complete db shutdown.
                // Some situations are:
                //     spurious interrupts being sent to thread by clients.
                //     unreliable hardware like a network mounted file system.
                //
                // The only option other than retrying is to fail the I/O 
                // immediately and throwing an error, thus performance cost
                // not really a consideration.
                //
                // The retry max of 4 is arbitrary, but has been enough that
                // not many read I/O errors have been reported.
				if (io_retry_count > 4)
                {
					// page cannot be physically read
	
					StandardException se = 
						StandardException.newException(
								   SQLState.FILE_READ_PAGE_EXCEPTION, 
								   ioe, newIdentity, new Integer(pagesize));

						
				    if (dataFactory.getLogFactory().inRFR())
                    {
                        //if in rollforward recovery, it is possible that this 
                        //page actually does not exist on the disk yet because
                        //the log record we are proccessing now is actually 
                        //creating the page, we will recreate the page if we 
                        //are in rollforward recovery, so just throw the 
                        //exception.
                        throw se;
                    }
                    else
                    {
                        if (SanityManager.DEBUG)
                        {
                            // by shutting down system in debug mode, maybe
                            // we can catch root cause of the interrupt.
                            throw dataFactory.markCorrupt(se);
                        }
                        else
                        {
                            // No need to shut down runtime database on read
                            // error in delivered system, throwing exception 
                            // should be enough.  Thrown exception has nested
                            // IO exception which is root cause of error.
                            throw se;
                        }
					}
				}
			}
		}
	}"
180,980,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SQLTinyint,,getObject,,isNull,isNull,201,201,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SQLTinyint.java#L201,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SQLTinyint.java,,close,"public Object	getObject() 
	{
		return (isNull()) ?
					null:
					new Integer(value);
	}"
181,987,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.store.raw.data,org.apache.derby.impl.store.raw.data.AllocPage,,WriteContainerInfo,,throw StandardException.newException(,,575,575,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/data/AllocPage.java#L575,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/data/AllocPage.java,,close,"public static void WriteContainerInfo(byte[] containerInfo,
										  byte[] epage,
										  boolean create)
		 throws StandardException
	{
		int N = (containerInfo == null) ? 0 : containerInfo.length;

		if (SanityManager.DEBUG)
		{
			if (create)
				SanityManager.ASSERT(
                    containerInfo != null, ""containerInfo is null"");

			SanityManager.ASSERT(epage != null, ""page array is null"");

            if (!((containerInfo == null) ||
                  ((containerInfo.length + BORROWED_SPACE_OFFSET + 
                      BORROWED_SPACE_LEN) < epage.length))) 
            {
                SanityManager.THROWASSERT(
                    ""containerInfo too big for page array: "" + 
                    containerInfo.length);
            }

			if (BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN + N >=
															MAX_BORROWED_SPACE)
				SanityManager.THROWASSERT(
								 ""exceed max borrowable space: "" + N);
        }

        if ((N + BORROWED_SPACE_LEN + BORROWED_SPACE_OFFSET) > epage.length)
        {
			if (SanityManager.DEBUG)
				SanityManager.THROWASSERT(
				   ""exceed max borrowable space on page: "" + N);
		}

		if (create)
		{
			epage[BORROWED_SPACE_OFFSET] = (byte)N;
		}
		else
		{
			int oldN = (int)epage[BORROWED_SPACE_OFFSET];
			if (oldN != N)
            {
				throw StandardException.newException(
                        SQLState.DATA_CHANGING_CONTAINER_INFO, 
                        new Long(oldN), 
                        new Long(N));
            }
		}

		if (N != 0)
			System.arraycopy(containerInfo, 0, epage,
							 BORROWED_SPACE_OFFSET + BORROWED_SPACE_LEN,
							 N);
	}"
182,990,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedConnection,,removeLOBMapping,,getlobHMObj().remove(new Integer(key));,,3301,3301,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java#L3301,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedConnection.java,,close,"public void removeLOBMapping(int key) {
		getlobHMObj().remove(new Integer(key));
	}"
183,992,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.jdbc,org.apache.derby.impl.jdbc.EmbedStatement,,setMaxFieldSize,,"throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, new Integer(max));",,435,435,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java#L435,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/EmbedStatement.java,,close,"public void setMaxFieldSize(int max) throws SQLException {
		checkStatus();

		if (max < 0)
		{
			throw newSQLException(SQLState.INVALID_MAXFIELD_SIZE, new Integer(max));
		}
        this.MaxFieldSize = max;
	}"
184,994,derby,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.ResultColumnList,,updateArrays,,"seenMap.put(new Integer(vcId), new Integer(index));",,4297,4297,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java#L4297,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java,,close,"private static void updateArrays(int[] mapArray,
                             boolean[] cloneMap,
                             Map<Integer,Integer> seenMap,
                             ResultColumn rc,
                             int index) {

        int vcId = rc.getVirtualColumnId();

        mapArray[index] = vcId;

        if (streamableType(rc)) {
            Integer seenIndex = seenMap.get(Integer.valueOf(vcId));

            if (seenIndex != null) {
                // We have already mapped this column at index
                // seenIndex, so mark occurence 2..n  for cloning.
                cloneMap[index] = true;
            } else {
                seenMap.put(new Integer(vcId), new Integer(index));
            }
        }
    }"
185,1787,lucene-solr,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.lucene.util,org.apache.lucene.util.TestSetOnce,,testSettingCtor,,Integer,"Integer,SetOnce<Integer>",60,60,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/util/TestSetOnce.java#L60,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/util/TestSetOnce.java,,unknown,"@Test(expected=AlreadySetException.class)
  public void testSettingCtor() throws Exception {
    SetOnce<Integer> set = new SetOnce<Integer>(new Integer(5));
    assertEquals(5, set.get().intValue());
    set.set(new Integer(7));
  }"
186,1950,lucene-solr,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.lucene.facet.taxonomy.writercache.lru,org.apache.lucene.facet.taxonomy.writercache.lru.LruTaxonomyWriterCache,,put,,Integer,"Integer,cache,categoryPath,ordinal,put",93,93,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//modules/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/LruTaxonomyWriterCache.java#L93,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//modules/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/LruTaxonomyWriterCache.java,,unknown,"public boolean put(CategoryPath categoryPath, int ordinal) {
    boolean ret = cache.put(categoryPath, new Integer(ordinal));
    // If the cache is full, we need to clear one or more old entries
    // from the cache. However, if we delete from the cache a recent
    // addition that isn't yet in our reader, for this entry to be
    // visible to us we need to make sure that the changes have been
    // committed and we reopen the reader. Because this is a slow
    // operation, we don't delete entries one-by-one but rather in bulk
    // (put() removes the 2/3rd oldest entries).
    if (ret) {
      cache.makeRoomLRU();
    }
    return ret;
  }"
187,2252,lucene-solr,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.solr.spelling.suggest,org.apache.solr.spelling.suggest.Suggester,,add,,Integer,"Integer,lookup,numHits,query,add",157,157,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//solr/core/src/java/org/apache/solr/spelling/suggest/Suggester.java#L157,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/spelling/suggest/Suggester.java,,unknown,"public void add(String query, int numHits) {
    LOG.info(""add "" + query + "", "" + numHits);
    lookup.add(query, new Integer(numHits));
  }"
188,2387,lucene-solr,DM_BOOLEAN_CTOR,A,last,,PERFORMANCE,org.apache.lucene.benchmark.byTask.utils,org.apache.lucene.benchmark.byTask.utils.Config,,propToBooleanArray,,Boolean,"Boolean,a,t,add",375,375,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java#L375,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java,,unknown,"private boolean[] propToBooleanArray(String s) {
    if (s.indexOf("":"") < 0) {
      return new boolean[]{Boolean.valueOf(s).booleanValue()};
    }

    ArrayList<Boolean> a = new ArrayList<Boolean>();
    StringTokenizer st = new StringTokenizer(s, "":"");
    while (st.hasMoreTokens()) {
      String t = st.nextToken();
      a.add(new Boolean(t));
    }
    boolean res[] = new boolean[a.size()];
    for (int i = 0; i < a.size(); i++) {
      res[i] = a.get(i).booleanValue();
    }
    return res;
  }"
189,2644,lucene-solr,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.lucene.util,org.apache.lucene.util.TestSetOnce,,testSetOnce,,Integer,"Integer,set,set",68,68,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/util/TestSetOnce.java#L68,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/util/TestSetOnce.java,,unknown,"@Test(expected=AlreadySetException.class)
  public void testSetOnce() throws Exception {
    SetOnce<Integer> set = new SetOnce<Integer>();
    set.set(new Integer(5));
    assertEquals(5, set.get().intValue());
    set.set(new Integer(7));
  }"
190,1973,lucene-solr,DM_NUMBER_CTOR,B,last,,PERFORMANCE,org.apache.lucene.index,org.apache.lucene.index.CheckIndex,,checkDocValues,,int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));,,1318,1318,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//lucene/core/src/java/org/apache/lucene/index/CheckIndex.java#L1318,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/index/CheckIndex.java,,unknown,"private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {
    if (docValues == null) {
      throw new RuntimeException(""field: "" + fieldName + "" omits docvalues but should have them!"");
    }
    DocValues.Type type = docValues.getType();
    if (type != expectedType) {
      throw new RuntimeException(""field: "" + fieldName + "" has type: "" + type + "" but fieldInfos says:"" + expectedType);
    }
    final Source values = docValues.getDirectSource();
    int size = docValues.getValueSize();
    for (int i = 0; i < expectedDocs; i++) {
      switch (type) {
      case BYTES_FIXED_SORTED:
      case BYTES_VAR_SORTED:
      case BYTES_FIXED_DEREF:
      case BYTES_FIXED_STRAIGHT:
      case BYTES_VAR_DEREF:
      case BYTES_VAR_STRAIGHT:
        BytesRef bytes = new BytesRef();
        values.getBytes(i, bytes);
        if (size != -1 && size != bytes.length) {
          throw new RuntimeException(""field: "" + fieldName + "" returned wrongly sized bytes, was: "" + bytes.length + "" should be: "" + size);
        }
        break;
      case FLOAT_32:
        assert size == 4;
        values.getFloat(i);
        break;
      case FLOAT_64:
        assert size == 8;
        values.getFloat(i);
        break;
      case VAR_INTS:
        assert size == -1;
        values.getInt(i);
        break;
      case FIXED_INTS_16:
        assert size == 2;
        values.getInt(i);
        break;
      case FIXED_INTS_32:
        assert size == 4;
        values.getInt(i);
        break;
      case FIXED_INTS_64:
        assert size == 8;
        values.getInt(i);
        break;
      case FIXED_INTS_8:
        assert size == 1;
        values.getInt(i);
        break;
      default:
        throw new IllegalArgumentException(""Field: "" + fieldName
                    + "" - no such DocValues type: "" + type);
      }
    }
    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {
      // check sorted bytes
      SortedSource sortedValues = values.asSortedSource();
      Comparator<BytesRef> comparator = sortedValues.getComparator();
      int lastOrd = -1;
      BytesRef lastBytes = new BytesRef();
      for (int i = 0; i < expectedDocs; i++) {
        int ord = sortedValues.ord(i);
        if (ord < 0 || ord > expectedDocs) {
          throw new RuntimeException(""field: "" + fieldName + "" ord is out of bounds: "" + ord);
        }
        BytesRef bytes = new BytesRef();
        sortedValues.getByOrd(ord, bytes);
        if (lastOrd != -1) {
          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));
          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));
          if (ordComp != bytesComp) {
            throw new RuntimeException(""field: "" + fieldName + "" ord comparison is wrong: "" + ordComp + "" comparator claims: "" + bytesComp);
          }
        }
        lastOrd = ord;
        lastBytes = bytes;
      }
    }
  }"
191,2060,lucene-solr,DM_NUMBER_CTOR,B,last,,PERFORMANCE,org.apache.solr.servlet,org.apache.solr.servlet.SolrDispatchFilter,,getErrorInfo,,"info.add(""code"", new Integer(code));",,449,449,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java#L449,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java,,unknown,"protected int getErrorInfo(Throwable ex, NamedList info) {
    int code=500;
    if( ex instanceof SolrException ) {
      code = ((SolrException)ex).code();
    }

    String msg = null;
    for (Throwable th = ex; th != null; th = th.getCause()) {
      msg = th.getMessage();
      if (msg != null) break;
    }
    if(msg != null) {
      info.add(""msg"", msg);
    }
    
    // For any regular code, don't include the stack trace
    if( code == 500 || code < 100 ) {
      StringWriter sw = new StringWriter();
      ex.printStackTrace(new PrintWriter(sw));
      SolrException.log(log, null, ex);
      info.add(""trace"", sw.toString());

      // non standard codes have undefined results with various servers
      if( code < 100 ) {
        log.warn( ""invalid return code: ""+code );
        code = 500;
      }
    }
    info.add(""code"", new Integer(code));
    return code;
  }"
192,1934,lucene-solr,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.lucene.facet.taxonomy.writercache.lru,org.apache.lucene.facet.taxonomy.writercache.lru.NameHashIntCacheLRU,,key,,Long,"Long,name,prefixLen,longHashCode,subpath",44,44,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameHashIntCacheLRU.java#L44,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/facet/src/java/org/apache/lucene/facet/taxonomy/writercache/lru/NameHashIntCacheLRU.java,,unknown,"@Override
  Object key(CategoryPath name) {
    return new Long(name.longHashCode());
  }"
193,2173,lucene-solr,DM_STRING_CTOR,C,last,,PERFORMANCE,org.apache.lucene.analysis.compound.hyphenation,org.apache.lucene.analysis.compound.hyphenation.TernaryTree$Iterator,,nextElement,,String,"String,curkey",520,520,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/hyphenation/TernaryTree.java#L520,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/hyphenation/TernaryTree.java,,close,"@Override
    public String nextElement() {
      String res = new String(curkey);
      cur = up();
      run();
      return res;
    }"
194,2208,lucene-solr,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.lucene.search.join,org.apache.lucene.search.join.ToChildBlockJoinQuery,,hashCode,,Boolean,"Boolean,doScores,hash,hash,prime,hashCode",355,355,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java#L355,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java,,unknown,"@Override
  public int hashCode() {
    final int prime = 31;
    int hash = super.hashCode();
    hash = prime * hash + origParentQuery.hashCode();
    hash = prime * hash + new Boolean(doScores).hashCode();
    hash = prime * hash + parentsFilter.hashCode();
    return hash;
  }"
195,2237,lucene-solr,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.solr.request,org.apache.solr.request.SimpleFacets$IntegerRangeEndpointCalculator,,parseAndAddGap,,Integer,"Integer,Integer,gap,value,intValue,intValue,valueOf",1519,1519,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/request/SimpleFacets.java#L1519,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/request/SimpleFacets.java,,unknown,"@Override
    public Float parseAndAddGap(Float value, String gap) {
      return new Float(value.floatValue() + Float.valueOf(gap).floatValue());
    }"
196,2539,lucene-solr,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.solr.update.processor,org.apache.solr.update.processor.FieldLengthUpdateProcessorFactory$1,,mutateValue,,Integer,"Integer,src,length",73,73,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/update/processor/FieldLengthUpdateProcessorFactory.java#L73,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/update/processor/FieldLengthUpdateProcessorFactory.java,,unknown,"@Override
      protected Object mutateValue(final Object src) {
        if (src instanceof CharSequence) {
          return new Integer(((CharSequence)src).length());
        }
        return src;
      }"
197,2548,lucene-solr,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.solr.spelling,org.apache.solr.spelling.SpellCheckCollation,,compareTo,,Integer,"Integer,internalRank,scc,compareTo,internalRank",30,30,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/spelling/SpellCheckCollation.java#L30,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/spelling/SpellCheckCollation.java,,close,"@Override
  public int compareTo(SpellCheckCollation scc) {
    int c = new Integer(internalRank).compareTo(scc.internalRank);
    if (c == 0) {
      return collationQuery.compareTo(scc.collationQuery);
    }
    return c;
  }"
198,2813,lucene-solr,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.solr.cloud,org.apache.solr.cloud.DistributedQueue,,orderedChildren,,Long childId = new Long(suffix);,,102,102,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/cloud/DistributedQueue.java#L102,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/cloud/DistributedQueue.java,,unknown,"private TreeMap<Long,String> orderedChildren(Watcher watcher)
      throws KeeperException, InterruptedException {
    TreeMap<Long,String> orderedChildren = new TreeMap<Long,String>();
    
    List<String> childNames = null;
    try {
      childNames = zookeeper.getChildren(dir, watcher, true);
    } catch (KeeperException.NoNodeException e) {
      throw e;
    }
    
    for (String childName : childNames) {
      try {
        // Check format
        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {
          LOG.debug(""Found child node with improper name: "" + childName);
          continue;
        }
        String suffix = childName.substring(prefix.length());
        Long childId = new Long(suffix);
        orderedChildren.put(childId, childName);
      } catch (NumberFormatException e) {
        LOG.warn(""Found child node with improper format : "" + childName + "" ""
            + e, e);
      }
    }
    
    return orderedChildren;
  }"
199,9674,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Tstamp$Unit,,<init>,,MILLISECOND,"MILLISECOND,calendarFields,put",311,311,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Tstamp.java#L311,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Tstamp.java,,close,
200,9696,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.splash,org.apache.tools.ant.taskdefs.optional.splash.SplashScreen,,messageLogged,,Integer,"Integer,MAX,Math,gr,intValue,min",164,164,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java#L164,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/splash/SplashScreen.java,,close,"public void messageLogged(BuildEvent event) {
        actionPerformed(null);
        if (hasProgressPattern()) {
            String message = event.getMessage();
            Matcher matcher = progressRegExpPattern.matcher(message);
            if (matcher != null && matcher.matches()) {
                String gr = matcher.group(1);
                try {
                    int i = Math.min(new Integer(gr).intValue() * 2, MAX);
                    pb.setValue(i);
                } catch (NumberFormatException e) {
                    //TODO: how to reach logger?!?
                    //log(""Number parsing error in progressRegExp"", Project.MSG_VERBOSE);

                }
            }
        }
    }"
201,9708,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.depend.constantpool,org.apache.tools.ant.taskdefs.optional.depend.constantpool.IntegerCPInfo,,read,,Integer,"Integer,cpStream,setValue,readInt",43,43,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/IntegerCPInfo.java#L43,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/IntegerCPInfo.java,,close,"public void read(DataInputStream cpStream) throws IOException {
        setValue(new Integer(cpStream.readInt()));
    }"
202,9728,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.condition,org.apache.tools.ant.taskdefs.condition.IsReachable,,eval,,Integer,"Integer,SECOND,params,timeout",182,182,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/condition/IsReachable.java#L182,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/condition/IsReachable.java,,close,"public boolean eval() throws BuildException {
        if (empty(host) && empty(url)) {
            throw new BuildException(ERROR_NO_HOSTNAME);
        }
        if (timeout < 0) {
            throw new BuildException(ERROR_BAD_TIMEOUT);
        }
        String target = host;
        if (!empty(url)) {
            if (!empty(host)) {
                throw new BuildException(ERROR_BOTH_TARGETS);
            }
            try {
                //get the host of a url
                URL realURL = new URL(url);
                target = realURL.getHost();
                if (empty(target)) {
                    throw new BuildException(ERROR_NO_HOST_IN_URL + url);
                }
            } catch (MalformedURLException e) {
                throw new BuildException(ERROR_BAD_URL + url, e);
            }
        }
        log(""Probing host "" + target, Project.MSG_VERBOSE);
        InetAddress address;
        try {
            address = InetAddress.getByName(target);
        } catch (UnknownHostException e1) {
            log(WARN_UNKNOWN_HOST + target);
            return false;
        }
        log(""Host address = "" + address.getHostAddress(),
                Project.MSG_VERBOSE);
        boolean reachable;
        //Java1.5: reachable = address.isReachable(timeout * 1000);
        Method reachableMethod = null;
        try {
            reachableMethod = InetAddress.class.getMethod(METHOD_NAME,
                    parameterTypes);
            Object[] params = new Object[1];
            params[0] = new Integer(timeout * SECOND);
            try {
                reachable = ((Boolean) reachableMethod.invoke(address, params))
                        .booleanValue();
            } catch (IllegalAccessException e) {
                //utterly implausible, but catered for anyway
                throw new BuildException(""When calling "" + reachableMethod);
            } catch (InvocationTargetException e) {
                //assume this is an IOexception about un readability
                Throwable nested = e.getTargetException();
                log(ERROR_ON_NETWORK + target + "": "" + nested.toString());
                //any kind of fault: not reachable.
                reachable = false;
            }
        } catch (NoSuchMethodException e) {
            //java1.4
            log(""Not found: InetAddress."" + METHOD_NAME, Project.MSG_VERBOSE);
            log(MSG_NO_REACHABLE_TEST);
            reachable = true;

        }

        log(""host is"" + (reachable ? """" : "" not"") + "" reachable"", Project.MSG_VERBOSE);
        return reachable;
    }"
203,9733,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.ResourceCount,,eval,,Integer,"Integer,count,rc,when,compareTo,evaluate,size",96,96,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/ResourceCount.java#L96,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/ResourceCount.java,,close,"public boolean eval() {
        if (rc == null) {
            throw new BuildException(ONE_NESTED_MESSAGE);
        }
        if (count == null) {
            throw new BuildException(COUNT_REQUIRED);
        }
        return when.evaluate(new Integer(rc.size()).compareTo(count));
    }"
204,9738,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.util,org.apache.tools.ant.util.LayoutPreservingProperties,,innerSetProperty,,"keyedPairLines.put(key, new Integer(logicalLines.size()));",,182,182,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/util/LayoutPreservingProperties.java#L182,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/util/LayoutPreservingProperties.java,,close,"private void innerSetProperty(String key, String value) {
        value = escapeValue(value);

        if (keyedPairLines.containsKey(key)) {
            Integer i = (Integer) keyedPairLines.get(key);
            Pair p = (Pair) logicalLines.get(i.intValue());
            p.setValue(value);
        } else {
            key = escapeName(key);
            Pair p = new Pair(key, value);
            p.setNew(true);
            keyedPairLines.put(key, new Integer(logicalLines.size()));
            logicalLines.add(p);
        }
    }"
205,9791,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional,org.apache.tools.ant.taskdefs.optional.PropertyFile$Unit,,<init>,,MILLISECOND,"MILLISECOND,calendarFields,put",679,679,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java#L679,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/PropertyFile.java,,close,
206,9800,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.depend.constantpool,org.apache.tools.ant.taskdefs.optional.depend.constantpool.LongCPInfo,,read,,Long,"Long,cpStream,setValue,readLong",43,43,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/LongCPInfo.java#L43,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/depend/constantpool/LongCPInfo.java,,close,"public void read(DataInputStream cpStream) throws IOException {
        setValue(new Long(cpStream.readLong()));
    }"
207,9832,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Length,,setLength,,Long,"Long,ell,length",111,111,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Length.java#L111,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Length.java,,close,"public synchronized void setLength(long ell) {
        length = new Long(ell);
    }"
208,9859,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Nice,,setNewPriority,,Integer,"Integer,newPriority,newPriority",96,96,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Nice.java#L96,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Nice.java,,close,"public void setNewPriority(int newPriority) {
        if (newPriority < Thread.MIN_PRIORITY || newPriority > Thread.MAX_PRIORITY) {
            throw new BuildException(""The thread priority is out of the range 1-10"");
        }
        this.newPriority = new Integer(newPriority);
    }"
209,9887,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.WaitFor$Unit,,<init>,,Long,"Long,MILLISECOND,timeTable,put",250,250,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/WaitFor.java#L250,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/WaitFor.java,,close,
210,9893,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.XSLTProcess$Factory$Attribute,,setDynamicAttribute,,Integer,"Integer,value,value",1555,1555,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java#L1555,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java,,close,"public void setDynamicAttribute(String name, String value) throws BuildException {
                // only 'name' and 'value' exist.
                if (""name"".equalsIgnoreCase(name)) {
                    this.name = value;
                } else if (""value"".equalsIgnoreCase(name)) {
                    // a value must be of a given type
                    // say boolean|integer|string that are mostly used.
                    if (""true"".equalsIgnoreCase(value)) {
                        this.value = Boolean.TRUE;
                    } else if (""false"".equalsIgnoreCase(value)) {
                        this.value = Boolean.FALSE;
                    } else {
                        try {
                            this.value = new Integer(value);
                        } catch (NumberFormatException e) {
                            this.value = value;
                        }
                    }
                } else {
                    throw new BuildException(""Unsupported attribute: "" + name);
                }
            }"
211,9902,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.ResourceCount,,setCount,,Integer,"Integer,c,count",104,104,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/ResourceCount.java#L104,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/ResourceCount.java,,close,"public void setCount(int c) {
        count = new Integer(c);
    }"
212,9903,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Length,,eval,,Long,"Long,ell,getLength,getTrim,string",197,197,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Length.java#L197,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Length.java,,close,"public boolean eval() {
        validate();
        if (length == null) {
            throw new BuildException(LENGTH_REQUIRED);
        }
        Long ell;
        if (STRING.equals(mode)) {
            ell = new Long(getLength(string, getTrim()));
        } else {
            AccumHandler h = new AccumHandler();
            handleResources(h);
            ell = new Long(h.getAccum());
        }
        return when.evaluate(ell.compareTo(length));
    }"
213,9936,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Javac,,lookForPackageInfos,,Long,"Long,f,packageInfos,pkg,lastModified,put",1212,1212,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Javac.java#L1212,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Javac.java,,close,"private void lookForPackageInfos(File srcDir, File[] newFiles) {
        for (int i = 0; i < newFiles.length; i++) {
            File f = newFiles[i];
            if (!f.getName().equals(""package-info.java"")) {
                continue;
            }
            String path = FILE_UTILS.removeLeadingPath(srcDir, f).
                    replace(File.separatorChar, '/');
            String suffix = ""/package-info.java"";
            if (!path.endsWith(suffix)) {
                log(""anomalous package-info.java path: "" + path, Project.MSG_WARN);
                continue;
            }
            String pkg = path.substring(0, path.length() - suffix.length());
            packageInfos.put(pkg, new Long(f.lastModified()));
        }
    }"
214,9953,ant,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.ExecTask,,setTimeout,,setTimeout,setTimeout,126,126,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/ExecTask.java#L126,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/ExecTask.java,,close,"public void setTimeout(Long value) {
        timeout = value;
        incompatibleWithSpawn |= timeout != null;
    }"
215,9713,ant,DM_NUMBER_CTOR,B,last,,PERFORMANCE,org.apache.tools.ant.taskdefs.optional.junit,org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,,startTest,,Long,"Long,System,t,testStarts,currentTimeMillis,put",196,196,close,https://github.com/apache/ant/tree/995856afcb7f8168e970e39849bdfc9264f98c84//src/main/org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java#L196,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/optional/junit/XMLJUnitResultFormatter.java,,close,"public void startTest(Test t) {
        testStarts.put(t, new Long(System.currentTimeMillis()));
    }"
216,1002,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util,org.apache.tomcat.util.IntrospectionUtils,,convert,,Integer,"Integer,object,result",414,414,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/IntrospectionUtils.java#L414,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/IntrospectionUtils.java,,close,"public static Object convert(String object, Class<?> paramType) {
        Object result = null;
        if (""java.lang.String"".equals(paramType.getName())) {
            result = object;
        } else if (""java.lang.Integer"".equals(paramType.getName())
                || ""int"".equals(paramType.getName())) {
            try {
                result = new Integer(object);
            } catch (NumberFormatException ex) {
            }
            // Try a setFoo ( boolean )
        } else if (""java.lang.Boolean"".equals(paramType.getName())
                || ""boolean"".equals(paramType.getName())) {
            result = Boolean.valueOf(object);

            // Try a setFoo ( InetAddress )
        } else if (""java.net.InetAddress"".equals(paramType
                .getName())) {
            try {
                result = InetAddress.getByName(object);
            } catch (UnknownHostException exc) {
                if (log.isDebugEnabled())
                    log.debug(""IntrospectionUtils: Unable to resolve host name:"" +
                            object);
            }

            // Unknown type
        } else {
            if (log.isDebugEnabled())
                log.debug(""IntrospectionUtils: Unknown type "" +
                        paramType.getName());
        }
        if (result == null) {
            throw new IllegalArgumentException(""Can't convert argument: "" + object);
        }
        return result;
    }"
217,1049,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util.net,org.apache.tomcat.util.net.AprEndpoint$Sendfile,,remove,,sendfileData.remove(new Long(data.socket));,,2170,2170,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/net/AprEndpoint.java#L2170,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/net/AprEndpoint.java,,close,"public long remove(long socket) {
            long result = 0;
            for (int i = 0; i < size; i++) {
                if (sockets[i] == socket) {
                    result = timeouts[i];
                    sockets[i] = sockets[size - 1];
                    timeouts[i] = timeouts[size - 1];
                    size--;
                    break;
                }
            }
            return result;
        }"
218,1055,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.naming.factory,org.apache.naming.factory.BeanFactory,,getObjectInstance,,Long,"Long,value,valueArray",186,186,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/naming/factory/BeanFactory.java#L186,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/naming/factory/BeanFactory.java,,close,"@Override
    public Object getObjectInstance(Object obj, Name name, Context nameCtx,
                                    Hashtable<?,?> environment)
        throws NamingException {

        if (obj instanceof ResourceRef) {

            try {

                Reference ref = (Reference) obj;
                String beanClassName = ref.getClassName();
                Class<?> beanClass = null;
                ClassLoader tcl =
                    Thread.currentThread().getContextClassLoader();
                if (tcl != null) {
                    try {
                        beanClass = tcl.loadClass(beanClassName);
                    } catch(ClassNotFoundException e) {
                    }
                } else {
                    try {
                        beanClass = Class.forName(beanClassName);
                    } catch(ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
                if (beanClass == null) {
                    throw new NamingException
                        (""Class not found: "" + beanClassName);
                }

                BeanInfo bi = Introspector.getBeanInfo(beanClass);
                PropertyDescriptor[] pda = bi.getPropertyDescriptors();

                Object bean = beanClass.newInstance();

                Enumeration<RefAddr> e = ref.getAll();
                while (e.hasMoreElements()) {

                    RefAddr ra = e.nextElement();
                    String propName = ra.getType();

                    if (propName.equals(Constants.FACTORY) ||
                        propName.equals(""scope"") || propName.equals(""auth"") ||
                        propName.equals(""singleton"")) {
                        continue;
                    }

                    String value = (String)ra.getContent();

                    Object[] valueArray = new Object[1];

                    int i = 0;
                    for (i = 0; i<pda.length; i++) {

                        if (pda[i].getName().equals(propName)) {

                            Class<?> propType = pda[i].getPropertyType();

                            if (propType.equals(String.class)) {
                                valueArray[0] = value;
                            } else if (propType.equals(Character.class)
                                       || propType.equals(char.class)) {
                                valueArray[0] =
                                    Character.valueOf(value.charAt(0));
                            } else if (propType.equals(Byte.class)
                                       || propType.equals(byte.class)) {
                                valueArray[0] = new Byte(value);
                            } else if (propType.equals(Short.class)
                                       || propType.equals(short.class)) {
                                valueArray[0] = new Short(value);
                            } else if (propType.equals(Integer.class)
                                       || propType.equals(int.class)) {
                                valueArray[0] = new Integer(value);
                            } else if (propType.equals(Long.class)
                                       || propType.equals(long.class)) {
                                valueArray[0] = new Long(value);
                            } else if (propType.equals(Float.class)
                                       || propType.equals(float.class)) {
                                valueArray[0] = new Float(value);
                            } else if (propType.equals(Double.class)
                                       || propType.equals(double.class)) {
                                valueArray[0] = new Double(value);
                            } else if (propType.equals(Boolean.class)
                                       || propType.equals(boolean.class)) {
                                valueArray[0] = Boolean.valueOf(value);
                            } else {
                                throw new NamingException
                                    (""String conversion for property type '""
                                     + propType.getName() + ""' not available"");
                            }

                            Method setProp = pda[i].getWriteMethod();
                            if (setProp != null) {
                                setProp.invoke(bean, valueArray);
                            } else {
                                throw new NamingException
                                    (""Write not allowed for property: ""
                                     + propName);
                            }

                            break;

                        }

                    }

                    if (i == pda.length) {
                        throw new NamingException
                            (""No set method found for property: "" + propName);
                    }

                }

                return bean;

            } catch (java.beans.IntrospectionException ie) {
                NamingException ne = new NamingException(ie.getMessage());
                ne.setRootCause(ie);
                throw ne;
            } catch (java.lang.IllegalAccessException iae) {
                NamingException ne = new NamingException(iae.getMessage());
                ne.setRootCause(iae);
                throw ne;
            } catch (java.lang.InstantiationException ie2) {
                NamingException ne = new NamingException(ie2.getMessage());
                ne.setRootCause(ie2);
                throw ne;
            } catch (java.lang.reflect.InvocationTargetException ite) {
                Throwable cause = ite.getCause();
                if (cause instanceof ThreadDeath) {
                    throw (ThreadDeath) cause;
                }
                if (cause instanceof VirtualMachineError) {
                    throw (VirtualMachineError) cause;
                }
                NamingException ne = new NamingException(ite.getMessage());
                ne.setRootCause(ite);
                throw ne;
            }

        } else {
            return null;
        }

    }"
219,1061,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.websocket,org.apache.tomcat.websocket.AsyncChannelWrapperSecure$LongToIntegerFuture,,get,,Integer,"Integer,result,intValue",552,552,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java#L552,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/websocket/AsyncChannelWrapperSecure.java,,close,"@Override
        public T get() throws InterruptedException, ExecutionException {
            completionLatch.await();
            if (throwable != null) {
                throw new ExecutionException(throwable);
            }
            return result;
        }"
220,1078,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.membership,org.apache.catalina.tribes.membership.McastService,,getRecoveryCounter,,Integer,"Integer,p,intValue",203,203,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/membership/McastService.java#L203,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/membership/McastService.java,,close,"public int getRecoveryCounter(){
        String p = properties.getProperty(""recoveryCounter"");
        if(p != null){
            return new Integer(p).intValue();
        }
        return -1;
    }"
221,1106,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.tipis,org.apache.catalina.tribes.tipis.AbstractReplicatedMap,,memberAlive,,"mapMembers.put(member, new Long(System.currentTimeMillis()));",,297,297,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java#L297,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java,,close,"protected void memberAlive(Member member) {
        synchronized (mapMembers) {
            if (!mapMembers.containsKey(member)) {
                mapMemberAdded(member);
            } //end if
            mapMembers.put(member, new Long(System.currentTimeMillis()));
        }
    }"
222,1114,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.jasper.runtime,org.apache.jasper.runtime.JspRuntimeLibrary,,createTypedArray,,Byte,"Byte,i,i,tmpval,values",452,452,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/runtime/JspRuntimeLibrary.java#L452,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/runtime/JspRuntimeLibrary.java,,close,"public static void createTypedArray(String propertyName,
                                        Object bean,
                                        Method method,
                                        String[] values,
                                        Class<?> t,
                                        Class<?> propertyEditorClass)
                throws JasperException {

        try {
            if (propertyEditorClass != null) {
                Object[] tmpval = new Integer[values.length];
                for (int i=0; i<values.length; i++) {
                    tmpval[i] = getValueFromBeanInfoPropertyEditor(
                            t, propertyName, values[i], propertyEditorClass);
                }
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Integer.class)) {
                Integer []tmpval = new Integer[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] =  new Integer (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Byte.class)) {
                Byte[] tmpval = new Byte[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = new Byte (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Boolean.class)) {
                Boolean[] tmpval = new Boolean[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Boolean.valueOf(values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Short.class)) {
                Short[] tmpval = new Short[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = new Short (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Long.class)) {
                Long[] tmpval = new Long[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = new Long (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Double.class)) {
                Double[] tmpval = new Double[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = new Double (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Float.class)) {
                Float[] tmpval = new Float[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = new Float (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(Character.class)) {
                Character[] tmpval = new Character[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Character.valueOf(values[i].charAt(0));
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(int.class)) {
                int []tmpval = new int[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Integer.parseInt (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(byte.class)) {
                byte[] tmpval = new byte[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Byte.parseByte (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(boolean.class)) {
                boolean[] tmpval = new boolean[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = (Boolean.valueOf(values[i])).booleanValue();
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(short.class)) {
                short[] tmpval = new short[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Short.parseShort (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(long.class)) {
                long[] tmpval = new long[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Long.parseLong (values[i]);
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(double.class)) {
                double[] tmpval = new double[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Double.valueOf(values[i]).doubleValue();
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(float.class)) {
                float[] tmpval = new float[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = Float.valueOf(values[i]).floatValue();
                method.invoke (bean, new Object[] {tmpval});
            } else if (t.equals(char.class)) {
                char[] tmpval = new char[values.length];
                for (int i = 0 ; i < values.length; i++)
                    tmpval[i] = values[i].charAt(0);
                method.invoke (bean, new Object[] {tmpval});
            } else {
                Object[] tmpval = new Integer[values.length];
                for (int i=0; i<values.length; i++) {
                    tmpval[i] =
                        getValueFromPropertyEditorManager(
                                            t, propertyName, values[i]);
                }
                method.invoke (bean, new Object[] {tmpval});
            }
        } catch (Exception ex) {
            Throwable thr = ExceptionUtils.unwrapInvocationTargetException(ex);
            ExceptionUtils.handleThrowable(thr);
            throw new JasperException (""error in invoking method"", ex);
        }
    }"
223,1140,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.transport.bio,org.apache.catalina.tribes.transport.bio.BioSender,,disconnect,,Integer,"Integer,Long,getAddress,getPort,log,sm,debug,getHostAddress,getString",95,95,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/transport/bio/BioSender.java#L95,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/transport/bio/BioSender.java,,close,"@Override
    public  void disconnect() {
        boolean connect = isConnected();
        closeSocket();
        if (connect) {
            if (log.isDebugEnabled())
                log.debug(sm.getString(""IDataSender.disconnect"", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));
        }

    }"
224,1162,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.el.parser,org.apache.el.parser.AstInteger,,getInteger,,Long,"Long,image,number",42,42,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/el/parser/AstInteger.java#L42,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/el/parser/AstInteger.java,,close,"protected Number getInteger() {
        if (this.number == null) {
            try {
                this.number = new Long(this.image);
            } catch (ArithmeticException e1) {
                this.number = new BigInteger(this.image);
            }
        }
        return number;
    }"
225,1163,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.transport.bio,org.apache.catalina.tribes.transport.bio.BioSender,,closeSocket,,Integer,"Integer,Long,getAddress,getPort,log,sm,debug,getHostAddress,getString",201,201,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/transport/bio/BioSender.java#L201,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/transport/bio/BioSender.java,,close,"protected void closeSocket() {
        if(isConnected()) {
             if (socket != null) {
                try {
                    socket.close();
                } catch (IOException x) {
                    // Ignore
                } finally {
                    socket = null;
                    soOut = null;
                    soIn = null;
                }
            }
            setRequestCount(0);
            setConnected(false);
            if (log.isDebugEnabled())
                log.debug(sm.getString(""IDataSender.closeSocket"",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)));
       }
    }"
226,1164,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util,org.apache.tomcat.util.IntrospectionUtils,,setProperty,,Long,"Long,params,value",91,91,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/IntrospectionUtils.java#L91,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/IntrospectionUtils.java,,close,"public static boolean setProperty(Object o, String name, String value) {
        return setProperty(o,name,value,true);
    }"
227,1172,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.Node$TemplateText,,addSmap,,Integer,"Integer,extraSmap,srcLine,add",2067,2067,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/Node.java#L2067,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/Node.java,,close,"public void addSmap(int srcLine) {
            if (extraSmap == null) {
                extraSmap = new ArrayList<>();
            }
            extraSmap.add(new Integer(srcLine));
        }"
228,1189,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.transport.bio,org.apache.catalina.tribes.transport.bio.BioSender,,waitForAck,,Integer,"Integer,Long,getAddress,getTimeout,sm,socket,getLocalPort,getString",267,267,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/transport/bio/BioSender.java#L267,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/transport/bio/BioSender.java,,close,"protected void waitForAck() throws java.io.IOException {
        try {
            boolean ackReceived = false;
            boolean failAckReceived = false;
            ackbuf.clear();
            int bytesRead = 0;
            int i = soIn.read();
            while ((i != -1) && (bytesRead < Constants.ACK_COMMAND.length)) {
                bytesRead++;
                byte d = (byte)i;
                ackbuf.append(d);
                if (ackbuf.doesPackageExist() ) {
                    byte[] ackcmd = ackbuf.extractDataPackage(true).getBytes();
                    ackReceived = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.ACK_DATA);
                    failAckReceived = Arrays.equals(ackcmd,org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA);
                    ackReceived = ackReceived || failAckReceived;
                    break;
                }
                i = soIn.read();
            }
            if (!ackReceived) {
                if (i == -1) throw new IOException(sm.getString(""IDataSender.ack.eof"",getAddress(), new Integer(socket.getLocalPort())));
                else throw new IOException(sm.getString(""IDataSender.ack.wrong"",getAddress(), new Integer(socket.getLocalPort())));
            } else if ( failAckReceived && getThrowOnFailedAck()) {
                throw new RemoteProcessException(""Received a failed ack:org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA"");
            }
        } catch (IOException x) {
            String errmsg = sm.getString(""IDataSender.ack.missing"", getAddress(),new Integer(socket.getLocalPort()), new Long(getTimeout()));
            if ( SenderState.getSenderState(getDestination()).isReady() ) {
                SenderState.getSenderState(getDestination()).setSuspect();
                if ( log.isWarnEnabled() ) log.warn(errmsg, x);
            } else {
                if ( log.isDebugEnabled() )log.debug(errmsg, x);
            }
            throw x;
        } finally {
            ackbuf.clear();
        }
    }"
229,1190,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.transport.bio,org.apache.catalina.tribes.transport.bio.BioSender,,openSocket,,Integer,"Integer,Long,getAddress,getPort,log,sm,debug,getHostAddress,getString",170,170,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/transport/bio/BioSender.java#L170,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/transport/bio/BioSender.java,,close,"protected void openSocket() throws IOException {
       if(isConnected()) return ;
       try {
           socket = new Socket();
           InetSocketAddress sockaddr = new InetSocketAddress(getAddress(), getPort());
           socket.connect(sockaddr,(int)getTimeout());
           socket.setSendBufferSize(getTxBufSize());
           socket.setReceiveBufferSize(getRxBufSize());
           socket.setSoTimeout( (int) getTimeout());
           socket.setTcpNoDelay(getTcpNoDelay());
           socket.setKeepAlive(getSoKeepAlive());
           socket.setReuseAddress(getSoReuseAddress());
           socket.setOOBInline(getOoBInline());
           socket.setSoLinger(getSoLingerOn(),getSoLingerTime());
           socket.setTrafficClass(getSoTrafficClass());
           setConnected(true);
           soOut = socket.getOutputStream();
           soIn  = socket.getInputStream();
           setRequestCount(0);
           setConnectTime(System.currentTimeMillis());
           if (log.isDebugEnabled())
               log.debug(sm.getString(""IDataSender.openSocket"", getAddress().getHostAddress(), new Integer(getPort()), new Long(0)));
      } catch (IOException ex1) {
          SenderState.getSenderState(getDestination()).setSuspect();
          if (log.isDebugEnabled())
              log.debug(sm.getString(""IDataSender.openSocket.failure"",getAddress().getHostAddress(), new Integer(getPort()),new Long(0)), ex1);
          throw (ex1);
        }

     }"
230,1267,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util.modeler,org.apache.tomcat.util.modeler.Registry,,convertValue,,Integer,"Integer,objValue,value",523,523,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/modeler/Registry.java#L523,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/modeler/Registry.java,,close,"public Object convertValue(String type, String value)
    {
        Object objValue=value;

        if( type==null || ""java.lang.String"".equals( type )) {
            // string is default
            objValue=value;
        } else if( ""javax.management.ObjectName"".equals( type ) ||
                ""ObjectName"".equals( type )) {
            try {
                objValue=new ObjectName( value );
            } catch (MalformedObjectNameException e) {
                return null;
            }
        } else if( ""java.lang.Integer"".equals( type ) ||
                ""int"".equals( type )) {
            objValue=new Integer( value );
        } else if( ""java.lang.Long"".equals( type ) ||
                ""long"".equals( type )) {
            objValue=new Long( value );
        } else if( ""java.lang.Boolean"".equals( type ) ||
                ""boolean"".equals( type )) {
            objValue=Boolean.valueOf( value );
        }
        return objValue;
    }"
231,1307,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.ScriptingVariabler$CustomTagCounter,,visit,,Integer,"Integer,count,n,setNumCount",57,57,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/ScriptingVariabler.java#L57,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/ScriptingVariabler.java,,close,"@Override
        public void visit(Node.CustomTag n) throws JasperException {
            n.setCustomTagParent(parent);
            Node.CustomTag tmpParent = parent;
            parent = n;
            visitBody(n);
            parent = tmpParent;
            n.setNumCount(new Integer(count++));
        }"
232,1336,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util.modeler,org.apache.tomcat.util.modeler.Registry,,getId,,Integer,"Integer,code,domainTable,name,put",320,320,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/modeler/Registry.java#L320,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/modeler/Registry.java,,close,"@Override
    public synchronized int getId( String domain, String name) {
        if( domain==null) {
            domain="""";
        }
        Hashtable<String,Integer> domainTable = idDomains.get(domain);
        if( domainTable == null ) {
            domainTable = new Hashtable<>();
            idDomains.put( domain, domainTable);
        }
        if( name==null ) {
            name="""";
        }
        Integer i = domainTable.get(name);

        if( i!= null ) {
            return i.intValue();
        }

        int id[] = ids.get(domain);
        if( id == null ) {
            id=new int[1];
            ids.put( domain, id);
        }
        int code=id[0]++;
        domainTable.put( name, new Integer( code ));
        return code;
    }"
233,1411,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.tipis,org.apache.catalina.tribes.tipis.AbstractReplicatedMap,,mapMemberAdded,,"mapMembers.put(member, new Long(System.currentTimeMillis()));",,712,712,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java#L712,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java,,close,"public void mapMemberAdded(Member member) {
        if ( member.equals(getChannel().getLocalMember(false)) ) return;
        boolean memberAdded = false;
        //select a backup node if we don't have one
        synchronized (mapMembers) {
            if (!mapMembers.containsKey(member) ) {
                mapMembers.put(member, new Long(System.currentTimeMillis()));
                memberAdded = true;
            }
        }
        if ( memberAdded ) {
            synchronized (stateMutex) {
                Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();
                while (i.hasNext()) {
                    Map.Entry<K,MapEntry<K,V>> e = i.next();
                    MapEntry<K,V> entry = innerMap.get(e.getKey());
                    if ( entry == null ) continue;
                    if (entry.isPrimary() && (entry.getBackupNodes() == null || entry.getBackupNodes().length == 0)) {
                        try {
                            Member[] backup = publishEntryInfo(entry.getKey(), entry.getValue());
                            entry.setBackupNodes(backup);
                            entry.setPrimary(channel.getLocalMember(false));
                        } catch (ChannelException x) {
                            log.error(""Unable to select backup node."", x);
                        } //catch
                    } //end if
                } //while
            } //synchronized
        }//end if
    }"
234,1439,tomcat,DM_BOOLEAN_CTOR,C,last,,PERFORMANCE,org.apache.el.stream,org.apache.el.stream.Stream,,noneMatch,,Boolean,"Boolean,Optional,match,booleanValue",394,394,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/el/stream/Stream.java#L394,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/el/stream/Stream.java,,close,"public Optional noneMatch(LambdaExpression le) {
        if (!iterator.hasNext()) {
            return Optional.EMPTY;
        }

        Boolean match = Boolean.FALSE;

        while (!match.booleanValue() && iterator.hasNext()) {
            match = (Boolean) le.invoke(iterator.next());
        }

        return new Optional(new Boolean(!match.booleanValue()));
    }"
235,1555,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.jasper.compiler,org.apache.jasper.compiler.PageInfo,,setBufferValue,,Integer,"Integer,value,value,length,substring",467,467,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/PageInfo.java#L467,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/PageInfo.java,,close,"public void setBufferValue(String value, Node n, ErrorDispatcher err)
        throws JasperException {

        if (""none"".equalsIgnoreCase(value))
            buffer = 0;
        else {
            if (value == null || !value.endsWith(""kb"")) {
                if (n == null) {
                    err.jspError(""jsp.error.page.invalid.buffer"");
                } else {
                    err.jspError(n, ""jsp.error.page.invalid.buffer"");
                }
            }
            try {
                @SuppressWarnings(""null"") // value can't be null here
                Integer k = new Integer(value.substring(0, value.length()-2));
                buffer = k.intValue() * 1024;
            } catch (NumberFormatException e) {
                if (n == null) {
                    err.jspError(""jsp.error.page.invalid.buffer"");
                } else {
                    err.jspError(n, ""jsp.error.page.invalid.buffer"");
                }
            }
        }

        bufferValue = value;
    }"
236,1564,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.session,org.apache.catalina.session.StandardManager,,doUnload,,oos.writeObject(new Integer(sessions.size()));,,407,407,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/session/StandardManager.java#L407,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/session/StandardManager.java,,close,"@SuppressWarnings(""null"")
    protected void doUnload() throws IOException {

        if (log.isDebugEnabled())
            log.debug(sm.getString(""standardManager.unloading.debug""));

        if (sessions.isEmpty()) {
            log.debug(sm.getString(""standardManager.unloading.nosessions""));
            return; // nothing to do
        }

        // Open an output stream to the specified pathname, if any
        File file = file();
        if (file == null)
            return;
        if (log.isDebugEnabled())
            log.debug(sm.getString(""standardManager.unloading"", pathname));
        FileOutputStream fos = null;
        BufferedOutputStream bos = null;
        ObjectOutputStream oos = null;
        boolean error = false;
        try {
            fos = new FileOutputStream(file.getAbsolutePath());
            bos = new BufferedOutputStream(fos);
            oos = new ObjectOutputStream(bos);
        } catch (IOException e) {
            error = true;
            log.error(sm.getString(""standardManager.unloading.ioe"", e), e);
            throw e;
        } finally {
            if (error) {
                if (oos != null) {
                    try {
                        oos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
                if (bos != null) {
                    try {
                        bos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
                if (fos != null) {
                    try {
                        fos.close();
                    } catch (IOException ioe) {
                        // Ignore
                    }
                }
            }
        }

        // Write the number of active sessions, followed by the details
        ArrayList<StandardSession> list = new ArrayList<>();
        synchronized (sessions) {
            if (log.isDebugEnabled())
                log.debug(""Unloading "" + sessions.size() + "" sessions"");
            try {
                // oos can't be null here
                oos.writeObject(new Integer(sessions.size()));
                Iterator<Session> elements = sessions.values().iterator();
                while (elements.hasNext()) {
                    StandardSession session =
                        (StandardSession) elements.next();
                    list.add(session);
                    session.passivate();
                    session.writeObjectData(oos);
                }
            } catch (IOException e) {
                log.error(sm.getString(""standardManager.unloading.ioe"", e), e);
                try {
                    oos.close();
                } catch (IOException f) {
                    // Ignore
                }
                throw e;
            }
        }

        // Flush and close the output stream
        try {
            oos.flush();
        } finally {
            try {
                oos.close();
            } catch (IOException f) {
                // Ignore
            }
        }

        // Expire all the sessions we just wrote
        if (log.isDebugEnabled())
            log.debug(""Expiring "" + list.size() + "" persisted sessions"");
        Iterator<StandardSession> expires = list.iterator();
        while (expires.hasNext()) {
            StandardSession session = expires.next();
            try {
                session.expire(false);
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
            } finally {
                session.recycle();
            }
        }

        if (log.isDebugEnabled())
            log.debug(""Unloading complete"");

    }"
237,1567,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.ant.jmx,org.apache.catalina.ant.jmx.JMXAccessorTask,,convertStringToType,,Long,"Long,convertValue,value",514,514,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/ant/jmx/JMXAccessorTask.java#L514,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/ant/jmx/JMXAccessorTask.java,,close,"protected Object convertStringToType(String value, String valueType) {
        if (""java.lang.String"".equals(valueType))
            return value;

        Object convertValue = value;
        if (""java.lang.Integer"".equals(valueType) || ""int"".equals(valueType)) {
            try {
                convertValue = new Integer(value);
            } catch (NumberFormatException ex) {
                if (isEcho())
                    handleErrorOutput(""Unable to convert to integer:"" + value);
            }
        } else if (""java.lang.Long"".equals(valueType)
                || ""long"".equals(valueType)) {
            try {
                convertValue = new Long(value);
            } catch (NumberFormatException ex) {
                if (isEcho())
                    handleErrorOutput(""Unable to convert to long:"" + value);
            }
        } else if (""java.lang.Boolean"".equals(valueType)
                || ""boolean"".equals(valueType)) {
            convertValue = Boolean.valueOf(value);
        } else if (""java.lang.Float"".equals(valueType)
                || ""float"".equals(valueType)) {
            try {
                convertValue = new Float(value);
            } catch (NumberFormatException ex) {
                if (isEcho())
                    handleErrorOutput(""Unable to convert to float:"" + value);
            }
        } else if (""java.lang.Double"".equals(valueType)
                || ""double"".equals(valueType)) {
            try {
                convertValue = new Double(value);
            } catch (NumberFormatException ex) {
                if (isEcho())
                    handleErrorOutput(""Unable to convert to double:"" + value);
            }
        } else if (""javax.management.ObjectName"".equals(valueType)
                || ""name"".equals(valueType)) {
            try {
                convertValue = new ObjectName(value);
            } catch (MalformedObjectNameException e) {
                if (isEcho())
                    handleErrorOutput(""Unable to convert to ObjectName:""
                            + value);
            }
        } else if (""java.net.InetAddress"".equals(valueType)) {
            try {
                convertValue = InetAddress.getByName(value);
            } catch (UnknownHostException exc) {
                if (isEcho())
                    handleErrorOutput(""Unable to resolve host name:"" + value);
            }
        }
        return convertValue;
    }"
238,1576,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util.http,org.apache.tomcat.util.http.FastHttpDateFormat,,internalParseDate,,return new Long(date.getTime());,,197,197,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/http/FastHttpDateFormat.java#L197,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/http/FastHttpDateFormat.java,,close,"private static final Long internalParseDate
        (String value, DateFormat[] formats) {
        Date date = null;
        for (int i = 0; (date == null) && (i < formats.length); i++) {
            try {
                date = formats[i].parse(value);
            } catch (ParseException e) {
                // Ignore
            }
        }
        if (date == null) {
            return null;
        }
        return new Long(date.getTime());
    }"
239,1584,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.jdbc.naming,org.apache.tomcat.jdbc.naming.GenericNamingResourcesFactory,,setProperty,,Integer,"Integer,params,value",116,116,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/naming/GenericNamingResourcesFactory.java#L116,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/naming/GenericNamingResourcesFactory.java,,close,"@SuppressWarnings(""null"") // setPropertyMethodVoid can't be null when used
    private static boolean setProperty(Object o, String name, String value) {
        if (log.isDebugEnabled())
            log.debug(""IntrospectionUtils: setProperty("" +
                    o.getClass() + "" "" + name + ""="" + value + "")"");

        String setter = ""set"" + capitalize(name);

        try {
            Method methods[] = o.getClass().getMethods();
            Method setPropertyMethodVoid = null;
            Method setPropertyMethodBool = null;

            // First, the ideal case - a setFoo( String ) method
            for (int i = 0; i < methods.length; i++) {
                Class<?> paramT[] = methods[i].getParameterTypes();
                if (setter.equals(methods[i].getName()) && paramT.length == 1
                        && ""java.lang.String"".equals(paramT[0].getName())) {

                    methods[i].invoke(o, new Object[] { value });
                    return true;
                }
            }

            // Try a setFoo ( int ) or ( boolean )
            for (int i = 0; i < methods.length; i++) {
                boolean ok = true;
                if (setter.equals(methods[i].getName())
                        && methods[i].getParameterTypes().length == 1) {

                    // match - find the type and invoke it
                    Class<?> paramType = methods[i].getParameterTypes()[0];
                    Object params[] = new Object[1];

                    // Try a setFoo ( int )
                    if (""java.lang.Integer"".equals(paramType.getName())
                            || ""int"".equals(paramType.getName())) {
                        try {
                            params[0] = new Integer(value);
                        } catch (NumberFormatException ex) {
                            ok = false;
                        }
                    // Try a setFoo ( long )
                    }else if (""java.lang.Long"".equals(paramType.getName())
                                || ""long"".equals(paramType.getName())) {
                            try {
                                params[0] = new Long(value);
                            } catch (NumberFormatException ex) {
                                ok = false;
                            }

                        // Try a setFoo ( boolean )
                    } else if (""java.lang.Boolean"".equals(paramType.getName())
                            || ""boolean"".equals(paramType.getName())) {
                        params[0] = Boolean.valueOf(value);

                        // Try a setFoo ( InetAddress )
                    } else if (""java.net.InetAddress"".equals(paramType
                            .getName())) {
                        try {
                            params[0] = InetAddress.getByName(value);
                        } catch (UnknownHostException exc) {
                            if (log.isDebugEnabled())
                                log.debug(""IntrospectionUtils: Unable to resolve host name:"" + value);
                            ok = false;
                        }

                        // Unknown type
                    } else {
                        if (log.isDebugEnabled())
                            log.debug(""IntrospectionUtils: Unknown type "" +
                                    paramType.getName());
                    }

                    if (ok) {
                        methods[i].invoke(o, params);
                        return true;
                    }
                }

                // save ""setProperty"" for later
                if (""setProperty"".equals(methods[i].getName())) {
                    if (methods[i].getReturnType()==Boolean.TYPE){
                        setPropertyMethodBool = methods[i];
                    }else {
                        setPropertyMethodVoid = methods[i];
                    }

                }
            }

            // Ok, no setXXX found, try a setProperty(""name"", ""value"")
            if (setPropertyMethodBool != null || setPropertyMethodVoid != null) {
                Object params[] = new Object[2];
                params[0] = name;
                params[1] = value;
                if (setPropertyMethodBool != null) {
                    try {
                        return ((Boolean) setPropertyMethodBool.invoke(o, params)).booleanValue();
                    }catch (IllegalArgumentException biae) {
                        //the boolean method had the wrong
                        //parameter types. lets try the other
                        if (setPropertyMethodVoid!=null) {
                            setPropertyMethodVoid.invoke(o, params);
                            return true;
                        }else {
                            throw biae;
                        }
                    }
                } else {
                    setPropertyMethodVoid.invoke(o, params);
                    return true;
                }
            }

        } catch (IllegalArgumentException ex2) {
            log.warn(""IAE "" + o + "" "" + name + "" "" + value, ex2);
        } catch (SecurityException ex1) {
            if (log.isDebugEnabled())
                log.debug(""IntrospectionUtils: SecurityException for "" +
                        o.getClass() + "" "" + name + ""="" + value + "")"", ex1);
        } catch (IllegalAccessException iae) {
            if (log.isDebugEnabled())
                log.debug(""IntrospectionUtils: IllegalAccessException for "" +
                        o.getClass() + "" "" + name + ""="" + value + "")"", iae);
        } catch (InvocationTargetException ie) {
            Throwable cause = ie.getCause();
            if (cause instanceof ThreadDeath) {
                throw (ThreadDeath) cause;
            }
            if (cause instanceof VirtualMachineError) {
                throw (VirtualMachineError) cause;
            }
            if (log.isDebugEnabled())
                log.debug(""IntrospectionUtils: InvocationTargetException for "" +
                        o.getClass() + "" "" + name + ""="" + value + "")"", ie);
        }
        return false;
    }"
240,1604,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.tomcat.util.http,org.apache.tomcat.util.http.FastHttpDateFormat,,formatDate,,Long longValue = new Long(value);,,133,133,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/http/FastHttpDateFormat.java#L133,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/http/FastHttpDateFormat.java,,close,"public static final String formatDate
        (long value, DateFormat threadLocalformat) {

        Long longValue = new Long(value);
        String cachedDate = formatCache.get(longValue);
        if (cachedDate != null) {
            return cachedDate;
        }

        String newDate = null;
        Date dateValue = new Date(value);
        if (threadLocalformat != null) {
            newDate = threadLocalformat.format(dateValue);
            updateFormatCache(longValue, newDate);
        } else {
            synchronized (format) {
                newDate = format.format(dateValue);
            }
            updateFormatCache(longValue, newDate);
        }
        return newDate;
    }"
241,1606,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.membership,org.apache.catalina.tribes.membership.McastService,,getDropTime,,Long,"Long,p,longValue",267,267,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/membership/McastService.java#L267,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/membership/McastService.java,,close,"public long getDropTime() {
        String p = properties.getProperty(""memberDropTime"");
        return new Long(p).longValue();
    }"
242,1693,tomcat,DM_NUMBER_CTOR,C,last,,PERFORMANCE,org.apache.catalina.tribes.transport.bio,org.apache.catalina.tribes.transport.bio.BioSender,,sendMessage,,Integer,"Integer,getAddress,getPort,log,log,sm,x,getHostAddress,getString,isTraceEnabled,trace",112,112,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/transport/bio/BioSender.java#L112,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/transport/bio/BioSender.java,,close,"public  void sendMessage(byte[] data, boolean waitForAck) throws IOException {
        IOException exception = null;
        setAttempt(0);
        try {
             // first try with existing connection
             pushMessage(data,false,waitForAck);
        } catch (IOException x) {
            SenderState.getSenderState(getDestination()).setSuspect();
            exception = x;
            if (log.isTraceEnabled()) log.trace(sm.getString(""IDataSender.send.again"", getAddress().getHostAddress(),new Integer(getPort())),x);
            while ( getAttempt()<getMaxRetryAttempts() ) {
                try {
                    setAttempt(getAttempt()+1);
                    // second try with fresh connection
                    pushMessage(data, true,waitForAck);
                    exception = null;
                } catch (IOException xx) {
                    exception = xx;
                    closeSocket();
                }
            }
        } finally {
            setRequestCount(getRequestCount()+1);
            keepalive();
            if ( exception != null ) throw exception;
        }
    }"
243,3202,cassandra,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.cassandra.thrift,org.apache.cassandra.thrift.SliceRange,,getFieldValue,,Integer,"Integer,getCount",378,378,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//interface/thrift/gen-java/org/apache/cassandra/thrift/SliceRange.java#L378,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//interface/thrift/gen-java/org/apache/cassandra/thrift/SliceRange.java,,close,"public Object getFieldValue(_Fields field) {
    switch (field) {
    case START:
      return getStart();

    case FINISH:
      return getFinish();

    case REVERSED:
      return new Boolean(isReversed());

    case COUNT:
      return new Integer(getCount());

    }
    throw new IllegalStateException();
  }"
244,4542,cassandra,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.cassandra.thrift,org.apache.cassandra.thrift.CounterColumn,,getFieldValue,,Long,"Long,getValue",251,251,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//interface/thrift/gen-java/org/apache/cassandra/thrift/CounterColumn.java#L251,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//interface/thrift/gen-java/org/apache/cassandra/thrift/CounterColumn.java,,close,"public Object getFieldValue(_Fields field) {
    switch (field) {
    case NAME:
      return getName();

    case VALUE:
      return new Long(getValue());

    }
    throw new IllegalStateException();
  }"
245,8578,cassandra,DM_NUMBER_CTOR,A,last,,PERFORMANCE,org.apache.cassandra.thrift,org.apache.cassandra.thrift.KsDef,,getFieldValue,,Integer,"Integer,getReplication_factor",477,477,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java#L477,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java,,close,"public Object getFieldValue(_Fields field) {
    switch (field) {
    case NAME:
      return getName();

    case STRATEGY_CLASS:
      return getStrategy_class();

    case STRATEGY_OPTIONS:
      return getStrategy_options();

    case REPLICATION_FACTOR:
      return new Integer(getReplication_factor());

    case CF_DEFS:
      return getCf_defs();

    case DURABLE_WRITES:
      return new Boolean(isDurable_writes());

    }
    throw new IllegalStateException();
  }"
246,8999,cassandra,DM_NUMBER_CTOR,B,last,,PERFORMANCE,org.apache.cassandra.streaming,org.apache.cassandra.streaming.SerializationsTest,,makePendingFile,,Long,"Long,Long,Pair,i,i,i,sections,add,create",156,156,close,https://github.com/apache/cassandra/tree/69337a43670f71ae1fc55e23d6a9031230423900//test/unit/org/apache/cassandra/streaming/SerializationsTest.java#L156,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//test/unit/org/apache/cassandra/streaming/SerializationsTest.java,,unknown,"private static PendingFile makePendingFile(boolean sst, int numSecs, OperationType op)
    {
        Descriptor desc = new Descriptor(""z"", new File(""path/doesn't/matter""), ""Keyspace1"", ""Standard1"", 23, false);
        List<Pair<Long, Long>> sections = new ArrayList<Pair<Long, Long>>();
        for (int i = 0; i < numSecs; i++)
            sections.add(Pair.create(new Long(i), new Long(i * i)));
        return new PendingFile(sst ? makeSSTable() : null, desc, SSTable.COMPONENT_DATA, sections, op);
    }"
