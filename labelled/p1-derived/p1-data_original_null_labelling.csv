,warning id,project,bug_pattern,commit,last_commit_checked,?,bug pattern category,package,class,field,method,type,expr,idents,start_line,end_line,label (automatically determined),commit url,"commit url (of the version compared to, if closed)",code (if open),label,method_content
0,83,derby,NP_NULL_ON_SOME_PATH,B,last,,CORRECTNESS,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.CharConstantNode,,init,,newLen,"newLen,val,length",94,94,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/compile/CharConstantNode.java#L94,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/compile/CharConstantNode.java,,unknown,"public void init(
					Object arg1)
		throws StandardException
	{
		if (arg1 instanceof TypeId)
		{
			super.init(
						arg1,
						Boolean.TRUE,
						ReuseFactory.getInteger(0));
		}
		else
		{
			String val = (String) arg1;

			super.init(
				TypeId.CHAR_ID,
				(val == null) ? Boolean.TRUE : Boolean.FALSE,
				(val != null) ?
					ReuseFactory.getInteger(val.length()) :
					ReuseFactory.getInteger(0));

			setValue(getDataValueFactory().getCharDataValue(val));
		}
	}"
1,95,derby,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,B,last,,STYLE,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.CreateTriggerConstantAction,,executeConstantAction,,TriggerDescriptor triggerd =,,299,299,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/execute/CreateTriggerConstantAction.java#L299,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/CreateTriggerConstantAction.java,,close,"public void	executeConstantAction(Activation activation)
						throws StandardException
	{
		SPSDescriptor				whenspsd = null;
		SPSDescriptor				actionspsd;

		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
		DataDictionary dd = lcc.getDataDictionary();
		DependencyManager dm = dd.getDependencyManager();
		TransactionController tc = lcc.getTransactionExecute();

		/*
		** Indicate that we are about to modify the data dictionary.
		** 
		** We tell the data dictionary we're done writing at the end of
		** the transaction.
		*/
		dd.startWriting(lcc);

		SchemaDescriptor triggerSd = getSchemaDescriptorForCreate(dd, activation, triggerSchemaName);

		if (spsCompSchemaId == null) {
			SchemaDescriptor def = lcc.getDefaultSchema();
			if (def.getUUID() == null) {
				// Descriptor for default schema is stale,
				// look it up in the dictionary
				def = dd.getSchemaDescriptor(def.getDescriptorName(), tc, 
											 false);
			}
			
			/* 
			** It is possible for spsCompSchemaId to be null.  For instance, 
			** the current schema may not have been physically created yet but 
			** it exists ""virtually"".  In this case, its UUID will have the 
			** value of null meaning that it is not persistent.  e.g.:   
			**
			** CONNECT 'db;create=true' user 'ernie';
			** CREATE TABLE bert.t1 (i INT);
			** CREATE TRIGGER bert.tr1 AFTER INSERT ON bert.t1 
			**    FOR EACH STATEMENT MODE DB2SQL 
			**    SELECT * FROM SYS.SYSTABLES;
			**
			** Note that in the above case, the trigger action statement have a 
			** null compilation schema.  A compilation schema with null value 
			** indicates that the trigger action statement text does not have 
			** any dependencies with the CURRENT SCHEMA.  This means:
			**
			** o  It is safe to compile this statement in any schema since 
			**    there is no dependency with the CURRENT SCHEMA. i.e.: All 
			**    relevent identifiers are qualified with a specific schema.
			**
			** o  The statement cache mechanism can utilize this piece of 
			**    information to enable better statement plan sharing across 
			**    connections in different schemas; thus, avoiding unnecessary 
			**    statement compilation.
			*/ 
			if (def != null)
				spsCompSchemaId = def.getUUID();
		}

		String tabName;
		if (triggerTable != null)
		{
			triggerTableId = triggerTable.getUUID();
			tabName = triggerTable.getName();
		}
		else
			tabName = ""with UUID "" + triggerTableId;

		/* We need to get table descriptor again.  We simply can't trust the
		 * one we got at compile time, the lock on system table was released
		 * when compile was done, and the table might well have been dropped.
		 */
		triggerTable = dd.getTableDescriptor(triggerTableId);
		if (triggerTable == null)
		{
			throw StandardException.newException(
								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
								tabName);
		}
		/* Lock the table for DDL.  Otherwise during our execution, the table
		 * might be changed, even dropped.  Beetle 4269
		 */
		lockTableForDDL(tc, triggerTable.getHeapConglomerateId(), true);
		/* get triggerTable again for correctness, in case it's changed before
		 * the lock is aquired
		 */
		triggerTable = dd.getTableDescriptor(triggerTableId);
		if (triggerTable == null)
		{
			throw StandardException.newException(
								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
								tabName);
		}

		/*
		** Send an invalidate on the table from which
		** the triggering event emanates.  This it
		** to make sure that DML statements on this table
		** will be recompiled.  Do this before we create
		** our trigger spses lest we invalidate them just
		** after creating them.
		*/
		dm.invalidateFor(triggerTable, DependencyManager.CREATE_TRIGGER, lcc);

		/*
		** Lets get our trigger id up front, we'll use it when
	 	** we create our spses.
		*/
		UUID tmpTriggerId = dd.getUUIDFactory().createUUID();

		actionSPSId = (actionSPSId == null) ? 
			dd.getUUIDFactory().createUUID() : actionSPSId;
 
		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();

		/*
		** Create the trigger descriptor first so the trigger action
		** compilation can pick up the relevant trigger especially in 
		** the case of self triggering.
		*/
		TriggerDescriptor triggerd =
				ddg.newTriggerDescriptor(
									triggerSd,
									tmpTriggerId,
									triggerName,
									eventMask,
									isBefore,
									isRow,
									isEnabled,
									triggerTable,
									whenspsd == null ? null : whenspsd.getUUID(),
									actionSPSId,
									creationTimestamp == null ? new Timestamp(System.currentTimeMillis()) : creationTimestamp,
									referencedCols,
									referencedColsInTriggerAction,
									originalActionText,
									referencingOld,
									referencingNew,
									oldReferencingName,
									newReferencingName);


		dd.addDescriptor(triggerd, triggerSd,
								DataDictionary.SYSTRIGGERS_CATALOG_NUM, false,
								tc);


		/*	
		** If we have a WHEN action we create it now.
		*/
		if (whenText != null)
		{
			whenspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
						whenSPSId, spsCompSchemaId, whenText, true, triggerTable);
		}

		/*
		** Create the trigger action
		*/
		actionspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
						actionSPSId, spsCompSchemaId, actionText, false, triggerTable);
		
		/*
		** Make underlying spses dependent on the trigger.
		*/
		if (whenspsd != null)
		{
			dm.addDependency(triggerd, whenspsd, lcc.getContextManager());
		}
		dm.addDependency(triggerd, actionspsd, lcc.getContextManager());
		dm.addDependency(triggerd, triggerTable, lcc.getContextManager());
		//store trigger's dependency on various privileges in the dependeny system
		storeViewTriggerDependenciesOnPrivileges(activation, triggerd);		
	}"
2,302,derby,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,B,last,,STYLE,org.apache.derby.iapi.types,org.apache.derby.iapi.types.WorkHorseForCollatorDatatypes,collationElementsForString,getCollationElementsForString,,collationElementsForString,"collationElementsForString,null",241,241,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/iapi/types/WorkHorseForCollatorDatatypes.java#L241,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/WorkHorseForCollatorDatatypes.java,,unknown,"int[] getCollationElementsForString()
		throws StandardException
	{
		if (stringData.isNull())
		{
			return (int[]) null;
		}



        // Caching of collationElementsForString is not working properly, in 
        // order to cache it needs to get invalidated everytime the container
        // type's value is changed - through any interface, eg: readExternal, 
        // setValue, ...  To get proper behavior, disabling caching, and will
        // file a performance enhancement to implement correct caching.
        collationElementsForString = null;
        countOfCollationElements   = 0;


		if (collationElementsForString != null)
		{
			return collationElementsForString;
		}

		// countOfCollationElements should always be 0 when 
        // collationElementsForString is null
		if (SanityManager.DEBUG)
		{
			if (countOfCollationElements != 0)
			{
				SanityManager.THROWASSERT(
					""countOfCollationElements expected to be 0, not "" + 
                    countOfCollationElements);
			}
		}
        

		collationElementsForString = new int[stringData.getLength()];

		CollationElementIterator cei = 
            collatorForCharacterDatatypes.getCollationElementIterator(
                stringData.getString());

		int nextInt;
		while ((nextInt = cei.next()) != CollationElementIterator.NULLORDER)
		{
			/* Believe it or not, a String might have more
			 * collation elements than characters.
			 * So, we handle that case by increasing the int array
			 * by 5 and copying array elements.
			 */
			if (countOfCollationElements == collationElementsForString.length)
			{
				int[] expandedArray = new int[countOfCollationElements + 5];
				System.arraycopy(collationElementsForString, 0, expandedArray, 
						0, collationElementsForString.length);
				collationElementsForString = expandedArray;
			}
			collationElementsForString[countOfCollationElements++] = nextInt;
		}

		return collationElementsForString;
	}"
3,526,derby,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,B,last,,CORRECTNESS,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.CastNode,,bindExpression,,opndType,"opndType,getTypeId",213,213,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/compile/CastNode.java#L213,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/compile/CastNode.java,,close,"public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
									Vector aggregateVector)
				throws StandardException
	{
		castOperand = castOperand.bindExpression(
								fromList, subqueryList,
								aggregateVector);

		if (getTypeServices() == null)   //CHAR or VARCHAR function without specifying target length
		{
			DataTypeDescriptor opndType = castOperand.getTypeServices();
			int length = -1;
			TypeId srcTypeId = opndType.getTypeId();
			if (opndType != null)
			{
				if (srcTypeId.isNumericTypeId())
				{
					length = opndType.getPrecision() + 1; // 1 for the sign
					if (opndType.getScale() > 0)
						length += 1;               // 1 for the decimal .
				 
				}
				/*
				 * Derby-1132 : The length for the target type was calculated
				 * incorrectly while Char & Varchar functions were used. Thus
				 * adding the check for Char & Varchar and calculating the
				 * length based on the operand type.
				 */
				else if(srcTypeId.isStringTypeId())
				{
					length = opndType.getMaximumWidth();
			
					// Truncate the target type width to the max width of the
					// data type
					if (this.targetCharType == Types.CHAR)
						length = Math.min(length, Limits.DB2_CHAR_MAXWIDTH);
					else if (this.targetCharType == Types.VARCHAR)
						length = Math.min(length, Limits.DB2_VARCHAR_MAXWIDTH);
				}
				else 
				{
					TypeId typeid = opndType.getTypeId();
					if (length < 0)
						length = DataTypeUtilities.getColumnDisplaySize(typeid.getJDBCTypeId(),-1);

				}
			}
			if (length < 0)
				length = 1;  // same default as in parser
			setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(targetCharType, length));
			
		}

		/* 
		** If castOperand is an untyped null, 
		** then we must set the type.
		*/
		if (castOperand instanceof UntypedNullConstantNode)
		{
			castOperand.setType(getTypeServices());
		}

		bindCastNodeOnly();
		
		/* We can't chop out cast above an untyped null because
		 * the store can't handle it.
		 */
		if ((castOperand instanceof ConstantNode) &&
			!(castOperand instanceof UntypedNullConstantNode))
		{
			/* If the castOperand is a typed constant then we do the cast at
			 * bind time and return a constant of the correct type.
			 * NOTE: This could return an exception, but we're prepared to 
			 * deal with that. (NumberFormatException, etc.)
			 * We only worry about the easy (and useful)
			 * converions at bind time.
			 * Here's what we support:
			 *			source					destination
			 *			------					-----------
			 *			boolean					boolean
			 *			boolean					char
			 *			char					boolean
			 *			char					date/time/ts
			 *			char					non-decimal numeric
			 *			date/time/ts			char
			 *			numeric					char
			 *			numeric					non-decimal numeric
			 */
			/* RESOLVE - to be filled in. */
			ValueNode retNode = this;
			int		  sourceJDBCTypeId = sourceCTI.getJDBCTypeId();
			int		  destJDBCTypeId = getTypeId().getJDBCTypeId();

			switch (sourceJDBCTypeId)
			{
				case Types.BIT:
				case Types.BOOLEAN:
					// (BIT is boolean)
					if (destJDBCTypeId == Types.BIT || destJDBCTypeId == Types.BOOLEAN)
					{
						retNode = castOperand;
					}
					else if (destJDBCTypeId == Types.CHAR)
					{
						BooleanConstantNode bcn = (BooleanConstantNode) castOperand;
						String booleanString = bcn.getValueAsString();
						retNode = (ValueNode) getNodeFactory().getNode(
											C_NodeTypes.CHAR_CONSTANT_NODE,
											booleanString,
											ReuseFactory.getInteger(
                                                    getTypeServices().getMaximumWidth()),
											getContextManager());
					}
					break;

					case Types.CHAR:
						retNode = getCastFromCharConstant(destJDBCTypeId);
						break;

					case Types.DATE:
					case Types.TIME:
					case Types.TIMESTAMP:
						if (destJDBCTypeId == Types.CHAR)
						{
							String castValue =  
								((UserTypeConstantNode) castOperand).
											getObjectValue().
												toString();
							retNode = (ValueNode) getNodeFactory().getNode(
												C_NodeTypes.CHAR_CONSTANT_NODE,
												castValue, 
												ReuseFactory.getInteger(
                                                        getTypeServices().getMaximumWidth()),
												getContextManager());
						}
						break;

					case Types.DECIMAL:
						// ignore decimal -> decimal casts for now
						if (destJDBCTypeId == Types.DECIMAL ||
							destJDBCTypeId == Types.NUMERIC)
							break;
						// fall through
					case Types.TINYINT:
					case Types.SMALLINT:
					case Types.INTEGER:
					case Types.BIGINT:
					case Types.DOUBLE:
					case Types.REAL:
						retNode = getCastFromNumericType(
											((ConstantNode) castOperand).getValue(), 
											destJDBCTypeId);
						break;

			}

			// Return the new constant if the cast was performed
			return retNode;
		}

		return this;
	}"
4,633,derby,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,B,last,,CORRECTNESS,org.apache.derby.impl.sql.execute,org.apache.derby.impl.sql.execute.DependentResultSet,,<init>,,activation,"activation,resultRowTemplate,resultSetNumber,super",145,145,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/execute/DependentResultSet.java#L145,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/execute/DependentResultSet.java,,open,
5,696,derby,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,B,last,,STYLE,org.apache.derby.impl.io,org.apache.derby.impl.io.DirFile,,deleteAll,,childList,"childList,i,i,length",290,290,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/io/DirFile.java#L290,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/io/DirFile.java,,close,"public boolean deleteAll()
    {
        if( !exists())
            return false;
        if( isDirectory())
        {
            String[] childList = super.list();
            String parentName = getPath();
            for( int i = 0; i < childList.length; i++)
            {
                if( childList[i].equals( ""."") || childList[i].equals( ""..""))
                    continue;
                DirFile child = new DirFile( parentName, childList[i]);
                if( ! child.deleteAll())
                    return false;
            }
        }
        return delete();
    }"
6,937,derby,UWF_NULL_FIELD,B,last,,CORRECTNESS,org.apache.derby.client.net,org.apache.derby.client.net.NetConnection,cnntkn_,,,,,-2,-2,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/client/org/apache/derby/client/net/NetConnection.java#L-2,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/client/org/apache/derby/client/net/NetConnection.java,,close,
7,958,derby,NP_LOAD_OF_KNOWN_NULL_VALUE,B,last,,STYLE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.FromBaseTable,,mapTableAsVTI,,vtiNode = (QueryTreeNode) getNodeFactory().getNode(,,2444,2444,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java#L2444,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java,,close,"private ResultSetNode mapTableAsVTI(
            TableDescriptor td,
            String correlationName,
            ResultColumnList resultColumns,
            Properties tableProperties,
            ContextManager cm)
        throws StandardException {


        // The fact that we pass a non-null table descriptor to the following
        // call is an indication that we are mapping to a no-argument VTI. Since
        // we have the table descriptor we do not need to pass in a TableName.
        // See NewInvocationNode for more.
        QueryTreeNode newNode = (QueryTreeNode) getNodeFactory().getNode(
                C_NodeTypes.NEW_INVOCATION_NODE,
                null, // TableName
                td, // TableDescriptor
                Collections.EMPTY_LIST,
                Boolean.FALSE,
                cm);

        QueryTreeNode vtiNode;

        if (correlationName != null) {
            vtiNode = (QueryTreeNode) getNodeFactory().getNode(
                    C_NodeTypes.FROM_VTI,
                    newNode,
                    correlationName,
                    resultColumns,
                    tableProperties,
                    cm);
        } else {
            TableName exposedName = newNode.makeTableName(td.getSchemaName(),
                    td.getDescriptorName());

            vtiNode = (QueryTreeNode) getNodeFactory().getNode(
                    C_NodeTypes.FROM_VTI,
                    newNode,
                    correlationName,
                    resultColumns,
                    tableProperties,
                    exposedName,
                    cm);
        }

        return (ResultSetNode) vtiNode;
    }"
8,965,derby,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.derby.impl.sql.catalog,org.apache.derby.impl.sql.catalog.DataDictionaryImpl,,makePasswordHasher,,if (algorithm != null && algorithm.length() > 0) {,,1496,1496,close,https://github.com/apache/derby/tree/eea0d50c8d732cad9ba563ddfa786b7028eb092f//java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java#L1496,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java,,close,"public  PasswordHasher  makePasswordHasher( Dictionary props )
        throws StandardException
    {
        // Support for configurable hash algorithm was added in Derby 10.6, so
        // we don't want to store a hash using the new scheme if the database
        // is running in soft upgrade and may be used with an older version
        // later.
        boolean supportConfigurableHash = checkVersion(DataDictionary.DD_VERSION_DERBY_10_6, null);

        // Support for key stretching was added in Derby 10.9, so don't use it
        // if the database may still be used with an older version.
        boolean supportKeyStretching = checkVersion(DataDictionary.DD_VERSION_DERBY_10_9, null);

        if ( !supportConfigurableHash ) { return null; }
        else
        {
            String algorithm = (String)
                    PropertyUtil.getPropertyFromSet(
                        props,
                        Property.AUTHENTICATION_BUILTIN_ALGORITHM);

            if ( algorithm == null ) { return null; }

            byte[] salt = null;
            int iterations = 1;
            
            if (algorithm != null && algorithm.length() > 0) {

                if (supportKeyStretching) {
                    salt = generateRandomSalt(props);
                    iterations = getIntProperty(
                            props,
                            Property.AUTHENTICATION_BUILTIN_ITERATIONS,
                            Property.AUTHENTICATION_BUILTIN_ITERATIONS_DEFAULT,
                            1, Integer.MAX_VALUE);
                }
            }

            return new PasswordHasher( algorithm, salt, iterations );
        }
    }"
9,256,derby,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.derby.impl.sql.compile,org.apache.derby.impl.sql.compile.SQLParser,,tableFactor,,fromTable = (FromTable) nodeFactory.getNode(,,9016,9016,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java#L9016,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//generated/java/org/apache/derby/impl/sql/compile/SQLParser.java,,unknown,
10,437,derby,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.derby.impl.drda,org.apache.derby.impl.drda.DDMWriter,,writeScalarBytes,,buf,"buf,length,length",705,705,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/drda/org/apache/derby/impl/drda/DDMWriter.java#L705,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/drda/org/apache/derby/impl/drda/DDMWriter.java,,unknown,"protected void writeScalarBytes (int codePoint, byte[] buf, int length)
	{
		if (SanityManager.DEBUG)
		{
			if (buf == null && length > 0)
		    	SanityManager.THROWASSERT(""Buf is null"");
			if (length > buf.length)
		    	SanityManager.THROWASSERT(""Not enough bytes in buffer"");
		}
		ensureLength (length + 4);
		buffer.putShort((short) length);
		buffer.putShort((short) codePoint);
		buffer.put(buf, 0, length);
	}"
11,542,derby,NP_NULL_ON_SOME_PATH_EXCEPTION,A,last,,CORRECTNESS,org.apache.derby.impl.jdbc.authentication,org.apache.derby.impl.jdbc.authentication.AuthenticationServiceBase,,encryptPasswordSHA1Scheme,,algorithm,"algorithm,reset",480,480,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/engine/org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java#L480,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/jdbc/authentication/AuthenticationServiceBase.java,,unknown,"protected String encryptPasswordSHA1Scheme(String plainTxtUserPassword)
	{
		if (plainTxtUserPassword == null)
			return null;

		MessageDigest algorithm = null;
		try
		{
			algorithm = MessageDigest.getInstance(""SHA-1"");
		} catch (NoSuchAlgorithmException nsae)
		{
					// Ignore as we checked already during service boot-up
		}

		algorithm.reset();
		byte[] bytePasswd = null;
        bytePasswd = toHexByte(plainTxtUserPassword);
		algorithm.update(bytePasswd);
		byte[] encryptVal = algorithm.digest();
        String hexString = ID_PATTERN_SHA1_SCHEME +
                StringUtil.toHexString(encryptVal,0,encryptVal.length);
		return (hexString);

	}"
12,573,derby,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.derby.impl.store.access,org.apache.derby.impl.store.access.RAMTransaction,tempCongloms,addColumnToConglomerate,,Long,"Long,conglom,conglomId,tempCongloms,put",627,627,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java#L627,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/access/RAMTransaction.java,,unknown,"public void addColumnToConglomerate(
    long        conglomId,
    int         column_id,
    Storable    template_column,
    int         collation_id)
		throws StandardException
    {
        boolean is_temporary = (conglomId < 0);

		Conglomerate conglom = findConglomerate(conglomId);
		if (conglom == null)
        {
			throw StandardException.newException(
                SQLState.AM_NO_SUCH_CONGLOMERATE_DROP, new Long(conglomId));
        }

        // Get exclusive lock on the table being altered.
		ConglomerateController cc =
            conglom.open(
                this, rawtran, false, OPENMODE_FORUPDATE,
                MODE_TABLE,
                accessmanager.table_level_policy[
                    TransactionController.ISOLATION_SERIALIZABLE],
                (StaticCompiledOpenConglomInfo) null,
                (DynamicCompiledOpenConglomInfo) null);

		conglom.addColumn(this, column_id, template_column, collation_id);

        // remove the old entry in the Conglomerate directory, and add the
        // new one.
		if (is_temporary)
		{
            // remove old entry in the Conglomerate directory, and add new one
			if (tempCongloms != null)
				tempCongloms.remove(new Long(conglomId));
			tempCongloms.put(new Long(conglomId), conglom);
		}
		else
        {
            alterTableCallMade = true;

            // have access manager update the conglom to this new one.
			accessmanager.conglomCacheUpdateEntry(conglomId, conglom);
        }

        cc.close();

        return;
    }"
13,593,derby,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.derby.impl.drda,org.apache.derby.impl.drda.DDMReader,buffer,toDebugString,,"s += indent + ""Reader buffer length = "" + buffer.length + ""\n"";",,1987,1987,close,https://github.com/apache/derby/tree/9495437c8b640d689c8a67563097b86cb0cd6fca//java/drda/org/apache/derby/impl/drda/DDMReader.java#L1987,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/drda/org/apache/derby/impl/drda/DDMReader.java,,unknown,"protected String toDebugString(String indent)
	{
		String s = indent + ""***** DDMReader toDebugString ******\n"";
		int buflen = 0;
		if (buffer != null)
			buflen = buffer.length;
	   s += indent + ""Reader buffer length = "" + buffer.length + ""\n"";
	   return s;
	}"
14,110,derby,NP_NULL_ON_SOME_PATH,C,last,,CORRECTNESS,org.apache.derby.iapi.types,org.apache.derby.iapi.types.SqlXmlUtil,,evalXQExpression,,instanceof,"instanceof,itemRefs,size",648,648,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java#L648,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java,,open,"protected List evalXQExpression(XMLDataValue xmlContext,
        boolean returnResults, int [] resultXType) throws Exception
    {
        // if this object is in an SPS, we need to recompile the query
        if (recompileQuery)
        {
        	compileXQExpr(queryExpr, opName);
        }

        // Make sure we have a compiled query.
        if (SanityManager.DEBUG) {
            SanityManager.ASSERT(
                (query != null),
                ""Failed to locate compiled XML query expression."");
        }

        /* Create a DOM node from the xmlContext, since that's how
         * we feed the context to Xalan.  We do this by creating
         * a Document node using DocumentBuilder, which means that
         * the serialized form of the context node must be a string
         * value that is parse-able by DocumentBuilder--i.e. it must
         * constitute a valid XML document.  If that's true then
         * the context item's qualified type will be DOC_ANY.
         */
        if (xmlContext.getXType() != XML.XML_DOC_ANY)
        {
            throw StandardException.newException(
                SQLState.LANG_INVALID_XML_CONTEXT_ITEM,
                (returnResults ? ""XMLQUERY"" : ""XMLEXISTS""));
        } 

        Document docNode = null;
        docNode = dBuilder.parse(
            new InputSource(
                new StringReader(xmlContext.getString())));

        // Evaluate the expresion using Xalan.
        XPathResult result = (XPathResult)
                query.evaluate(docNode, XPathResult.ANY_TYPE, null);

        if (!returnResults)
        {
            // We don't want to return the actual results, we just
            // want to know if there was at least one item in the
            // result sequence.
            switch (result.getResultType()) {
                case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
                case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
                    if (result.iterateNext() == null) {
                        // We have an empty sequence, so return null.
                        return null;
                    } else {
                        // We have a non-empty sequence, so return a non-null
                        // list to indicate that we found at least one item.
                        return Collections.EMPTY_LIST;
                    }
                default:
                    // We have a single atomic value, which means the result is
                    // non-empty. So return a non-null list.
                    return Collections.EMPTY_LIST;
            }
        }

        // Else process the results.
        List itemRefs;
        switch (result.getResultType()) {
            case XPathResult.NUMBER_TYPE:
                // Single atomic number. Get its string value.
                String val = numberToString(result.getNumberValue());
                itemRefs = Collections.singletonList(val);
                break;
            case XPathResult.STRING_TYPE:
                // Single atomic string value.
                itemRefs = Collections.singletonList(result.getStringValue());
                break;
            case XPathResult.BOOLEAN_TYPE:
                // Single atomic boolean. Get its string value.
                itemRefs = Collections.singletonList(
                        String.valueOf(result.getBooleanValue()));
                break;
            case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
            case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
                // We have a sequence. Get all nodes.
                ArrayList<Node> nodes = new ArrayList<Node>();
                Node node;
                while ((node = result.iterateNext()) != null) {
                    nodes.add(node);
                }
                itemRefs = nodes;
                break;
            default:
                if (SanityManager.DEBUG) {
                    SanityManager.THROWASSERT(
                            ""Don't know how to handle XPath result type "" +
                            result.getResultType());
                }
                itemRefs = null;
        }

        /* Indicate what kind of XML result value we have.  If
         * we have a sequence of exactly one Document then it
         * is XMLPARSE-able and so we consider it to be of type
         * XML_DOC_ANY (which means we can store it in a Derby
         * XML column).
         */
        if ((itemRefs.size() == 1) && (itemRefs.get(0) instanceof Document))
            resultXType[0] = XML.XML_DOC_ANY;
        else
            resultXType[0] = XML.XML_SEQUENCE;

        return itemRefs;
    }"
15,127,derby,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.derby.impl.store.raw.xact,org.apache.derby.impl.store.raw.xact.Xact,postCommitWorks,postTermination,,if (postCommitWorks != null),,2132,2132,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/engine/org/apache/derby/impl/store/raw/xact/Xact.java#L2132,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/engine/org/apache/derby/impl/store/raw/xact/Xact.java,,unknown,"private final void postTermination() throws StandardException
	{
		// move all the postTermination work to the postCommit queue
		int count = (postTerminationWorks == null) ? 
			0 : postTerminationWorks.size(); 

		for (int i = 0; i < count; i++)
			addPostCommitWork(postTerminationWorks.get(i));

		if (count > 0)
			postTerminationWorks.clear();


		// if there are post commit work to be done, transfer them to the
		// daemon.  The log is flushed, all locks released and the
		// transaction has ended at this point.
		if (postCommitWorks != null && !postCommitWorks.isEmpty())
		{
			int pcsize = postCommitWorks.size();
			
			// do we want to do post commit work with this transaction object?
			if (doPostCommitWorkInTran())
			{
				try
				{
					inPostCommitProcessing = true;

					// to avoid confusion, copy the post commit work to an array if this
					// is going to do some work now
					Serviceable[] work = new Serviceable[pcsize];
					work = (Serviceable[])postCommitWorks.toArray(work);

					// clear this for post commit processing to queue its own post
					// commit works - when it commits, it will send all its post
					// commit request to the daemon instead of dealing with it here.
					postCommitWorks.clear();

					//All the post commit work that is part  of the database creation
					//should be done on this thread immediately.
					boolean doWorkInThisThread = xactFactory.inDatabaseCreation();

					for (int i = 0; i < pcsize; i++)
					{

						//process work that should be done immediately or
						//when we  are in still in database creattion.
						//All the other work should be submitted 
						//to the post commit thread to be processed asynchronously
						if (doWorkInThisThread || work[i].serviceImmediately())
						{
							try
							{
								// this may cause other post commit work to be
								// added.  when that transaction commits, those
								// work will be transfered to the daemon
								if (work[i].performWork(xc.getContextManager()) == Serviceable.DONE)
									work[i] = null;

								// if REQUEUE, leave it on for the postcommit
								// daemon to handle
							}
							catch (StandardException se)
							{
								// don't try to service this again
								work[i] = null;

								// try to handle it here.  If we fail, then let the error percolate.
								xc.cleanupOnError(se);
							}
						}

						// either it need not be serviedASAP or it needs
						// requeueing, send it off.   Note that this is one case
						// where a REQUEUE ends up in the high priority queue.
						// Unfortunately, there is no easy way to tell.  If the
						// Servicable is well mannered, it can change itself from
						// serviceASAP to not serviceASAP if it returns REQUEUE.
						if (work[i] != null)
						{
							boolean needHelp = xactFactory.submitPostCommitWork(work[i]);
							work[i] = null;
							if (needHelp)
								doWorkInThisThread = true;
						}
					}
				}
				finally
				{
					inPostCommitProcessing = false;

					// if something untoward happends, clear the queue.
					if (postCommitWorks != null)
						postCommitWorks.clear();
				}

			}
			else
			{
				// this is for non-user transaction or post commit work that is
				// submitted in PostCommitProcessing.  (i.e., a post commit
				// work submitting other post commit work)
				for (int i = 0; i < pcsize; i++)
				{
					// SanityManager.DEBUG_PRINT(""PostTermination"",postCommitWorks.elementAt((i)).toString());
					xactFactory.submitPostCommitWork((Serviceable)postCommitWorks.get((i)));
				}
			}

			postCommitWorks.clear();

		}

        // any backup blocking operations (like unlogged ops) in this 
        // transaction are done with post commit/abort work that needs be
        // done in the same trasaction,  unblock the backup.
        unblockBackup();
	}"
16,389,derby,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.derby.client.net,org.apache.derby.client.net.NetStatementReply,,parseSQLDXGRP,,column,"column,columnMetaData,columnMetaData,null,sqlxrdbnam,sqlxrdbnam,sqldRdbnam_,sqlxRdbnam_",2196,2196,close,https://github.com/apache/derby/tree/acbecbb96a5ae0a3b6bc5948b03f061dfea91662//java/client/org/apache/derby/client/net/NetStatementReply.java#L2196,https://github.com/apache/derby/tree/33427bdb982a7dd5b9e629ccec9c40f2b96412b4//java/client/org/apache/derby/client/net/NetStatementReply.java,,open,"private void parseSQLDXGRP(ColumnMetaData columnMetaData,
                               int column) throws DisconnectException {
        if (readFastUnsignedByte() == CodePoint.NULLDATA) {
            return;
        }


        //   SQLXKEYMEM; PROTOCOL TYPE I2; ENVLID 0x04; Length Override 2
        short sqlxkeymem = readFastShort();

        //   SQLXUPDATEABLE; PROTOCOL TYPE I2; ENVLID 0x04; Length Override 2
        short sqlxupdateable = readFastShort();

        //   SQLXGENERATED; PROTOCOL TYPE I2; ENVLID 0x04; Length Override 2
        short sqlxgenerated = readFastShort();

        //   SQLXPARMMODE; PROTOCOL TYPE I2; ENVLID 0x04; Length Override 2
        short sqlxparmmode = readFastShort();

        //   SQLXRDBNAM; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255
        String sqlxrdbnam = parseFastVCS();

        //   SQLXCORNAME_m; PROTOCOL TYPE VCM; ENVLID 0x3E; Length Override 255
        //   SQLXCORNAME_s; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255
        String sqlxcorname = parseFastVCMorVCS();

        //   SQLXBASENAME_m; PROTOCOL TYPE VCM; ENVLID 0x3E; Length Override 255
        //   SQLXBASENAME_s; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255
        String sqlxbasename = parseFastVCMorVCS();

        //   SQLXSCHEMA_m; PROTOCOL TYPE VCM; ENVLID 0x3E; Length Override 255
        //   SQLXSCHEMA_s; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255
        String sqlxschema = parseFastVCMorVCS();

        //   SQLXNAME_m; PROTOCOL TYPE VCM; ENVLID 0x3E; Length Override 255
        //   SQLXNAME_s; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255
        String sqlxname = parseFastVCMorVCS();

        if (columnMetaData.sqlxKeymem_ == null) {
            columnMetaData.sqlxKeymem_ = new short[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxGenerated_ == null) {
            columnMetaData.sqlxGenerated_ = new short[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxParmmode_ == null) {
            columnMetaData.sqlxParmmode_ = new short[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxCorname_ == null) {
            columnMetaData.sqlxCorname_ = new String[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxName_ == null) {
            columnMetaData.sqlxName_ = new String[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxBasename_ == null) {
            columnMetaData.sqlxBasename_ = new String[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxUpdatable_ == null) {
            columnMetaData.sqlxUpdatable_ = new int[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxSchema_ == null) {
            columnMetaData.sqlxSchema_ = new String[columnMetaData.columns_];
        }
        if (columnMetaData.sqlxRdbnam_ == null) {
            columnMetaData.sqlxRdbnam_ = new String[columnMetaData.columns_];
        }

        columnMetaData.sqlxKeymem_[column] = sqlxkeymem;
        columnMetaData.sqlxGenerated_[column] = sqlxgenerated;
        columnMetaData.sqlxParmmode_[column] = sqlxparmmode;
        columnMetaData.sqlxCorname_[column] = sqlxcorname;
        columnMetaData.sqlxName_[column] = sqlxname;
        columnMetaData.sqlxBasename_[column] = sqlxbasename;
        columnMetaData.sqlxUpdatable_[column] = sqlxupdateable;
        columnMetaData.sqlxSchema_[column] = (sqlxschema == null) ? columnMetaData.sqldSchema_ : sqlxschema;
        columnMetaData.sqlxRdbnam_[column] = (sqlxrdbnam == null) ? columnMetaData.sqldRdbnam_ : sqlxrdbnam;
    }"
17,1904,lucene-solr,NP_NULL_ON_SOME_PATH_EXCEPTION,A,last,,CORRECTNESS,org.apache.solr.uima.processor,org.apache.solr.uima.processor.UIMAUpdateRequestProcessor,,processAdd,,Math,"Math,text,length,min",101,101,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//solr/contrib/uima/src/java/org/apache/solr/uima/processor/UIMAUpdateRequestProcessor.java#L101,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/contrib/uima/src/java/org/apache/solr/uima/processor/UIMAUpdateRequestProcessor.java,,close,"@Override
  public void processAdd(AddUpdateCommand cmd) throws IOException {
    String text = null;
    try {
      /* get Solr document */
      SolrInputDocument solrInputDocument = cmd.getSolrInputDocument();

      /* get the fields to analyze */
      String[] texts = getTextsToAnalyze(solrInputDocument);
      for (int i = 0; i < texts.length; i++) {
        text = texts[i];
        if (text != null && text.length()>0) {
          /* process the text value */
          JCas jcas = processText(text);

          UIMAToSolrMapper uimaToSolrMapper = new UIMAToSolrMapper(solrInputDocument, jcas);
          /* get field mapping from config */
          Map<String, Map<String, MapField>> typesAndFeaturesFieldsMap = solrUIMAConfiguration
                  .getTypesFeaturesFieldsMapping();
          /* map type features on fields */
          for (String typeFQN : typesAndFeaturesFieldsMap.keySet()) {
            uimaToSolrMapper.map(typeFQN, typesAndFeaturesFieldsMap.get(typeFQN));
          }
        }
      }
    } catch (Exception e) {
      String logField = solrUIMAConfiguration.getLogField();
      if(logField == null){
        SchemaField uniqueKeyField = solrCore.getSchema().getUniqueKeyField();
        if(uniqueKeyField != null){
          logField = uniqueKeyField.getName();
        }
      }
      String optionalFieldInfo = logField == null ? ""."" :
        new StringBuilder("". "").append(logField).append(""="")
        .append((String)cmd.getSolrInputDocument().getField(logField).getValue())
        .append("", "").toString();
      int len = Math.min(text.length(), 100);
      if (solrUIMAConfiguration.isIgnoreErrors()) {
        log.warn(new StringBuilder(""skip the text processing due to "")
          .append(e.getLocalizedMessage()).append(optionalFieldInfo)
          .append("" text=\"""").append(text.substring(0, len)).append(""...\"""").toString());
      } else {
        throw new SolrException(ErrorCode.SERVER_ERROR,
            new StringBuilder(""processing error: "")
              .append(e.getLocalizedMessage()).append(optionalFieldInfo)
              .append("" text=\"""").append(text.substring(0, len)).append(""...\"""").toString(), e);
      }
    }
    super.processAdd(cmd);
  }"
18,2002,lucene-solr,NP_NULL_PARAM_DEREF,A,last,,CORRECTNESS,org.apache.solr.schema,org.apache.solr.schema.TextField,,parseFieldQuery,,Term,"Term,TermQuery,field,term",265,265,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//solr/core/src/java/org/apache/solr/schema/TextField.java#L265,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/schema/TextField.java,,unknown,"static Query parseFieldQuery(QParser parser, Analyzer analyzer, String field, String queryText) {
    int phraseSlop = 0;
    boolean enablePositionIncrements = true;

    // most of the following code is taken from the Lucene QueryParser

    // Use the analyzer to get all the tokens, and then build a TermQuery,
    // PhraseQuery, or nothing based on the term count

    TokenStream source;
    try {
      source = analyzer.tokenStream(field, new StringReader(queryText));
      source.reset();
    } catch (IOException e) {
      throw new RuntimeException(""Unable to initialize TokenStream to analyze query text"", e);
    }
    CachingTokenFilter buffer = new CachingTokenFilter(source);
    CharTermAttribute termAtt = null;
    PositionIncrementAttribute posIncrAtt = null;
    int numTokens = 0;

    try {
      buffer.reset();
    } catch (IOException e) {
      throw new RuntimeException(""Unable to initialize TokenStream to analyze query text"", e);
    }

    if (buffer.hasAttribute(CharTermAttribute.class)) {
      termAtt = buffer.getAttribute(CharTermAttribute.class);
    }
    if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
      posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
    }

    int positionCount = 0;
    boolean severalTokensAtSamePosition = false;

    boolean hasMoreTokens = false;
    if (termAtt != null) {
      try {
        hasMoreTokens = buffer.incrementToken();
        while (hasMoreTokens) {
          numTokens++;
          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
          if (positionIncrement != 0) {
            positionCount += positionIncrement;
          } else {
            severalTokensAtSamePosition = true;
          }
          hasMoreTokens = buffer.incrementToken();
        }
      } catch (IOException e) {
        // ignore
      }
    }
    try {
      // rewind the buffer stream
      buffer.reset();

      // close original stream - all tokens buffered
      source.close();
    }
    catch (IOException e) {
      // ignore
    }

    if (numTokens == 0)
      return null;
    else if (numTokens == 1) {
      String term = null;
      try {
        boolean hasNext = buffer.incrementToken();
        assert hasNext == true;
        term = termAtt.toString();
      } catch (IOException e) {
        // safe to ignore, because we know the number of tokens
      }
      // return newTermQuery(new Term(field, term));
      return new TermQuery(new Term(field, term));
    } else {
      if (severalTokensAtSamePosition) {
        if (positionCount == 1) {
          // no phrase query:
          // BooleanQuery q = newBooleanQuery(true);
          BooleanQuery q = new BooleanQuery(true);
          for (int i = 0; i < numTokens; i++) {
            String term = null;
            try {
              boolean hasNext = buffer.incrementToken();
              assert hasNext == true;
              term = termAtt.toString();
            } catch (IOException e) {
              // safe to ignore, because we know the number of tokens
            }

            // Query currentQuery = newTermQuery(new Term(field, term));
            Query currentQuery = new TermQuery(new Term(field, term));
            q.add(currentQuery, BooleanClause.Occur.SHOULD);
          }
          return q;
        }
        else {
          // phrase query:
          // MultiPhraseQuery mpq = newMultiPhraseQuery();
          MultiPhraseQuery mpq = new MultiPhraseQuery();
          mpq.setSlop(phraseSlop);
          List multiTerms = new ArrayList();
          int position = -1;
          for (int i = 0; i < numTokens; i++) {
            String term = null;
            int positionIncrement = 1;
            try {
              boolean hasNext = buffer.incrementToken();
              assert hasNext == true;
              term = termAtt.toString();
              if (posIncrAtt != null) {
                positionIncrement = posIncrAtt.getPositionIncrement();
              }
            } catch (IOException e) {
              // safe to ignore, because we know the number of tokens
            }

            if (positionIncrement > 0 && multiTerms.size() > 0) {
              if (enablePositionIncrements) {
                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
              } else {
                mpq.add((Term[])multiTerms.toArray(new Term[0]));
              }
              multiTerms.clear();
            }
            position += positionIncrement;
            multiTerms.add(new Term(field, term));
          }
          if (enablePositionIncrements) {
            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
          } else {
            mpq.add((Term[])multiTerms.toArray(new Term[0]));
          }
          return mpq;
        }
      }
      else {
        // PhraseQuery pq = newPhraseQuery();
        PhraseQuery pq = new PhraseQuery();
        pq.setSlop(phraseSlop);
        int position = -1;


        for (int i = 0; i < numTokens; i++) {
          String term = null;
          int positionIncrement = 1;

          try {
            boolean hasNext = buffer.incrementToken();
            assert hasNext == true;
            term = termAtt.toString();
            if (posIncrAtt != null) {
              positionIncrement = posIncrAtt.getPositionIncrement();
            }
          } catch (IOException e) {
            // safe to ignore, because we know the number of tokens
          }

          if (enablePositionIncrements) {
            position += positionIncrement;
            pq.add(new Term(field, term),position);
          } else {
            pq.add(new Term(field, term));
          }
        }
        return pq;
      }
    }

  }"
19,2045,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.lucene.queryparser.flexible.messages,org.apache.lucene.queryparser.flexible.messages.NLS,,validateMessage,,,"null,obj",177,177,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/messages/NLS.java#L177,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/messages/NLS.java,,unknown,"private static void validateMessage(String key, Class<? extends NLS> clazz) {
    // Test if the message is present in the resource bundle
    try {
      ResourceBundle resourceBundle = ResourceBundle.getBundle(clazz.getName(),
          Locale.getDefault());
      if (resourceBundle != null) {
        Object obj = resourceBundle.getObject(key);
        if (obj == null)
          System.err.println(""WARN: Message with key:"" + key + "" and locale: ""
              + Locale.getDefault() + "" not found."");
      }
    } catch (MissingResourceException e) {
      System.err.println(""WARN: Message with key:"" + key + "" and locale: ""
          + Locale.getDefault() + "" not found."");
    } catch (Throwable e) {
      // ignore all other errors and exceptions
      // since this code is just a test to see if the message is present on the
      // system
    }
  }"
20,2083,lucene-solr,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,A,last,,BAD_PRACTICE,org.apache.lucene.codecs,org.apache.lucene.codecs.BlockTermsReader$FieldAndTerm,,equals,,,,-2,-2,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/java/org/apache/lucene/codecs/BlockTermsReader.java#L-2,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/java/org/apache/lucene/codecs/BlockTermsReader.java,,unknown,"@Override
    public boolean equals(Object _other) {
      FieldAndTerm other = (FieldAndTerm) _other;
      return other.field.equals(field) && term.bytesEquals(other.term);
    }"
21,2246,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.lucene.store,org.apache.lucene.store.TestRAMDirectory,,rmDir,,files,"files,i,i,length",163,163,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/store/TestRAMDirectory.java#L163,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/store/TestRAMDirectory.java,,unknown,"private void rmDir(File dir) {
    File[] files = dir.listFiles();
    for (int i = 0; i < files.length; i++) {
      files[i].delete();
    }
    dir.delete();
  }"
22,2326,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.lucene.benchmark.utils,org.apache.lucene.benchmark.utils.ExtractWikipedia,,<init>,,files,"files,i,i,length",47,47,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//modules/benchmark/src/java/org/apache/lucene/benchmark/utils/ExtractWikipedia.java#L47,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//modules/benchmark/src/java/org/apache/lucene/benchmark/utils/ExtractWikipedia.java,,unknown,
23,2330,lucene-solr,NP_LOAD_OF_KNOWN_NULL_VALUE,A,last,,STYLE,org.apache.solr.search,org.apache.solr.search.SolrQueryParser,,getReversedWildcardFilterFactory,,fac,"fac,fac,leadingWildcards,null,containsKey",82,82,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//solr/core/src/java/org/apache/solr/search/SolrQueryParser.java#L82,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/search/SolrQueryParser.java,,unknown,"protected ReversedWildcardFilterFactory getReversedWildcardFilterFactory(FieldType fieldType) {
    if (leadingWildcards == null) leadingWildcards = new HashMap<FieldType, ReversedWildcardFilterFactory>();
    ReversedWildcardFilterFactory fac = leadingWildcards.get(fieldType);
    if (fac == null && leadingWildcards.containsKey(fac)) {
      return fac;
    }

    Analyzer a = fieldType.getAnalyzer();
    if (a instanceof TokenizerChain) {
      // examine the indexing analysis chain if it supports leading wildcards
      TokenizerChain tc = (TokenizerChain)a;
      TokenFilterFactory[] factories = tc.getTokenFilterFactories();
      for (TokenFilterFactory factory : factories) {
        if (factory instanceof ReversedWildcardFilterFactory) {
          fac = (ReversedWildcardFilterFactory)factory;
          break;
        }
      }
    }

    leadingWildcards.put(fieldType, fac);
    return fac;
  }"
24,2376,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.solr.handler.admin,org.apache.solr.handler.admin.ShowFileRequestHandler,,handleRequestBody,,adminFile,"adminFile,listFiles",158,158,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java#L158,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java,,unknown,"@Override
  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException 
  {
    File adminFile = null;
    
    final SolrResourceLoader loader = req.getCore().getResourceLoader();
    File configdir = new File( loader.getConfigDir() );
    if (!configdir.exists()) {
      // TODO: maybe we should just open it this way to start with?
      try {
        configdir = new File( loader.getClassLoader().getResource(loader.getConfigDir()).toURI() );
      } catch (URISyntaxException e) {
        throw new SolrException( ErrorCode.FORBIDDEN, ""Can not access configuration directory!"");
      }
    }
    String fname = req.getParams().get(""file"", null);
    if( fname == null ) {
      adminFile = configdir;
    }
    else {
      fname = fname.replace( '\\', '/' ); // normalize slashes
      if( hiddenFiles.contains( fname.toUpperCase(Locale.ENGLISH) ) ) {
        throw new SolrException( ErrorCode.FORBIDDEN, ""Can not access: ""+fname );
      }
      if( fname.indexOf( "".."" ) >= 0 ) {
        throw new SolrException( ErrorCode.FORBIDDEN, ""Invalid path: ""+fname );  
      }
      adminFile = new File( configdir, fname );
    }
    
    // Make sure the file exists, is readable and is not a hidden file
    if( !adminFile.exists() ) {
      throw new SolrException( ErrorCode.BAD_REQUEST, ""Can not find: ""+adminFile.getName() 
          + "" [""+adminFile.getAbsolutePath()+""]"" );
    }
    if( !adminFile.canRead() || adminFile.isHidden() ) {
      throw new SolrException( ErrorCode.BAD_REQUEST, ""Can not show: ""+adminFile.getName() 
          + "" [""+adminFile.getAbsolutePath()+""]"" );
    }
    
    // Show a directory listing
    if( adminFile.isDirectory() ) {
      
      int basePath = configdir.getAbsolutePath().length() + 1;
      NamedList<SimpleOrderedMap<Object>> files = new SimpleOrderedMap<SimpleOrderedMap<Object>>();
      for( File f : adminFile.listFiles() ) {
        String path = f.getAbsolutePath().substring( basePath );
        path = path.replace( '\\', '/' ); // normalize slashes
        if( hiddenFiles.contains( path.toUpperCase(Locale.ENGLISH) ) ) {
          continue; // don't show 'hidden' files
        }
        if( f.isHidden() || f.getName().startsWith( ""."" ) ) {
          continue; // skip hidden system files...
        }
        
        SimpleOrderedMap<Object> fileInfo = new SimpleOrderedMap<Object>();
        files.add( path, fileInfo );
        if( f.isDirectory() ) {
          fileInfo.add( ""directory"", true ); 
        }
        else {
          // TODO? content type
          fileInfo.add( ""size"", f.length() );
        }
        fileInfo.add( ""modified"", new Date( f.lastModified() ) );
      }
      rsp.add( ""files"", files );
    }
    else {
      // Include the file contents
      //The file logic depends on RawResponseWriter, so force its use.
      ModifiableSolrParams params = new ModifiableSolrParams( req.getParams() );
      params.set( CommonParams.WT, ""raw"" );
      req.setParams(params);

      ContentStreamBase content = new ContentStreamBase.FileStream( adminFile );
      content.setContentType( req.getParams().get( USE_CONTENT_TYPE ) );

      rsp.add(RawResponseWriter.CONTENT, content);
    }
    rsp.setHttpCaching(false);
  }"
25,2392,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.TestIndexWriterOnJRECrash,,checkIndexes,,file,"file,listFiles",140,140,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash.java#L140,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash.java,,unknown,"public boolean checkIndexes(File file) throws IOException {
    if (file.isDirectory()) {
      MockDirectoryWrapper dir = newFSDirectory(file);
      dir.setCheckIndexOnClose(false); // don't double-checkindex
      if (IndexReader.indexExists(dir)) {
        if (VERBOSE) {
          System.err.println(""Checking index: "" + file);
        }
        _TestUtil.checkIndex(dir);
        dir.close();
        return true;
      }
      dir.close();
      for (File f : file.listFiles())
        if (checkIndexes(f))
          return true;
    }
    return false;
  }"
26,2413,lucene-solr,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.lucene.index,org.apache.lucene.index.ThreadedIndexingAndSearchingTestCase$1,,run,,doc,"doc,removeField",225,225,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java#L225,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java,,unknown,"@Override
          public void run() {
            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:
            final List<String> toDeleteIDs = new ArrayList<String>();
            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();
            while(System.currentTimeMillis() < stopTime && !failed.get()) {
              try {

                // Occasional longish pause if running
                // nightly
                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {
                  if (VERBOSE) {
                    System.out.println(Thread.currentThread().getName() + "": now long sleep"");
                  }
                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));
                }

                // Rate limit ingest rate:
                if (random.nextInt(7) == 5) {
                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));
                  if (VERBOSE) {
                    System.out.println(Thread.currentThread().getName() + "": done sleep"");
                  }
                }

                Document doc = docs.nextDoc();
                if (doc == null) {
                  break;
                }

                // Maybe add randomly named field
                final String addedField;
                if (random.nextBoolean()) {
                  addedField = ""extra"" + random.nextInt(40);
                  doc.add(newField(addedField, ""a random field"", TextField.TYPE_STORED));
                } else {
                  addedField = null;
                }

                if (random.nextBoolean()) {

                  if (random.nextBoolean()) {
                    // Add/update doc block:
                    final String packID;
                    final SubDocs delSubDocs;
                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {
                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));
                      assert !delSubDocs.deleted;
                      toDeleteSubDocs.remove(delSubDocs);
                      // Update doc block, replacing prior packID
                      packID = delSubDocs.packID;
                    } else {
                      delSubDocs = null;
                      // Add doc block, using new packID
                      packID = packCount.getAndIncrement() + """";
                    }

                    final Field packIDField = newField(""packID"", packID, StringField.TYPE_STORED);
                    final List<String> docIDs = new ArrayList<String>();
                    final SubDocs subDocs = new SubDocs(packID, docIDs);
                    final List<Document> docsList = new ArrayList<Document>();

                    allSubDocs.add(subDocs);
                    doc.add(packIDField);
                    docsList.add(_TestUtil.cloneDocument(doc));
                    docIDs.add(doc.get(""docid""));

                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);
                    while(docsList.size() < maxDocCount) {
                      doc = docs.nextDoc();
                      if (doc == null) {
                        break;
                      }
                      docsList.add(_TestUtil.cloneDocument(doc));
                      docIDs.add(doc.get(""docid""));
                    }
                    addCount.addAndGet(docsList.size());

                    final Term packIDTerm = new Term(""packID"", packID);

                    if (delSubDocs != null) {
                      delSubDocs.deleted = true;
                      delIDs.addAll(delSubDocs.subIDs);
                      delCount.addAndGet(delSubDocs.subIDs.size());
                      if (VERBOSE) {
                        System.out.println(Thread.currentThread().getName() + "": update pack packID="" + delSubDocs.packID + "" count="" + docsList.size() + "" docs="" + docIDs);
                      }
                      updateDocuments(packIDTerm, docsList);
                    } else {
                      if (VERBOSE) {
                        System.out.println(Thread.currentThread().getName() + "": add pack packID="" + packID + "" count="" + docsList.size() + "" docs="" + docIDs);
                      }
                      addDocuments(packIDTerm, docsList);
                    }
                    doc.removeField(""packID"");

                    if (random.nextInt(5) == 2) {
                      if (VERBOSE) {
                        System.out.println(Thread.currentThread().getName() + "": buffer del id:"" + packID);
                      }
                      toDeleteSubDocs.add(subDocs);
                    }

                  } else {
                    // Add single doc
                    final String docid = doc.get(""docid"");
                    if (VERBOSE) {
                      System.out.println(Thread.currentThread().getName() + "": add doc docid:"" + docid);
                    }
                    addDocument(new Term(""docid"", docid), doc);
                    addCount.getAndIncrement();

                    if (random.nextInt(5) == 3) {
                      if (VERBOSE) {
                        System.out.println(Thread.currentThread().getName() + "": buffer del id:"" + doc.get(""docid""));
                      }
                      toDeleteIDs.add(docid);
                    }
                  }
                } else {

                  // Update single doc, but we never re-use
                  // and ID so the delete will never
                  // actually happen:
                  if (VERBOSE) {
                    System.out.println(Thread.currentThread().getName() + "": update doc id:"" + doc.get(""docid""));
                  }
                  final String docid = doc.get(""docid"");
                  updateDocument(new Term(""docid"", docid), doc);
                  addCount.getAndIncrement();

                  if (random.nextInt(5) == 3) {
                    if (VERBOSE) {
                      System.out.println(Thread.currentThread().getName() + "": buffer del id:"" + doc.get(""docid""));
                    }
                    toDeleteIDs.add(docid);
                  }
                }

                if (random.nextInt(30) == 17) {
                  if (VERBOSE) {
                    System.out.println(Thread.currentThread().getName() + "": apply "" + toDeleteIDs.size() + "" deletes"");
                  }
                  for(String id : toDeleteIDs) {
                    if (VERBOSE) {
                      System.out.println(Thread.currentThread().getName() + "": del term=id:"" + id);
                    }
                    deleteDocuments(new Term(""docid"", id));
                  }
                  final int count = delCount.addAndGet(toDeleteIDs.size());
                  if (VERBOSE) {
                    System.out.println(Thread.currentThread().getName() + "": tot "" + count + "" deletes"");
                  }
                  delIDs.addAll(toDeleteIDs);
                  toDeleteIDs.clear();

                  for(SubDocs subDocs : toDeleteSubDocs) {
                    assert !subDocs.deleted;
                    delPackIDs.add(subDocs.packID);
                    deleteDocuments(new Term(""packID"", subDocs.packID));
                    subDocs.deleted = true;
                    if (VERBOSE) {
                      System.out.println(Thread.currentThread().getName() + "": del subs: "" + subDocs.subIDs + "" packID="" + subDocs.packID);
                    }
                    delIDs.addAll(subDocs.subIDs);
                    delCount.addAndGet(subDocs.subIDs.size());
                  }
                  toDeleteSubDocs.clear();
                }
                if (addedField != null) {
                  doc.removeField(addedField);
                }
              } catch (Throwable t) {
                System.out.println(Thread.currentThread().getName() + "": hit exc"");
                t.printStackTrace();
                failed.set(true);
                throw new RuntimeException(t);
              }
            }
            if (VERBOSE) {
              System.out.println(Thread.currentThread().getName() + "": indexing done"");
            }

            doAfterIndexingThreadDone();
          }"
27,2504,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.TestDocValuesIndexing,,indexValues,,bytesRef,"bytesRef,null",501,501,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing.java#L501,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing.java,,unknown,"private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,
      List<Type> valueVarList, boolean withDeletions, int bytesSize)
      throws CorruptIndexException, IOException {
    final boolean isNumeric = NUMERICS.contains(value);
    FixedBitSet deleted = new FixedBitSet(numValues);
    Document doc = new Document();
    DocValuesField valField = new DocValuesField(value.name());
    doc.add(valField);
    final BytesRef bytesRef = new BytesRef();

    final String idBase = value.name() + ""_"";
    final byte[] b = new byte[bytesSize];
    if (bytesRef != null) {
      bytesRef.bytes = b;
      bytesRef.length = b.length;
      bytesRef.offset = 0;
    }
    byte upto = 0;
    for (int i = 0; i < numValues; i++) {
      if (isNumeric) {
        switch (value) {
        case VAR_INTS:
          valField.setInt((long)i);
          break;
        case FIXED_INTS_16:
          valField.setInt((short)i, random.nextInt(10) != 0);
          break;
        case FIXED_INTS_32:
          valField.setInt(i, random.nextInt(10) != 0);
          break;
        case FIXED_INTS_64:
          valField.setInt((long)i, random.nextInt(10) != 0);
          break;
        case FIXED_INTS_8:
          valField.setInt((byte)(0xFF & (i % 128)), random.nextInt(10) != 0);
          break;
        case FLOAT_32:
          valField.setFloat(2.0f * i);
          break;
        case FLOAT_64:
          valField.setFloat(2.0d * i);
          break;
       
        default:
          fail(""unexpected value "" + value);
        }
      } else {
        for (int j = 0; j < b.length; j++) {
          b[j] = upto++;
        }
        if (bytesRef != null) {
          valField.setBytes(bytesRef, value);
        }
      }
      doc.removeFields(""id"");
      doc.add(new Field(""id"", idBase + i, StringField.TYPE_STORED));
      w.addDocument(doc);

      if (i % 7 == 0) {
        if (withDeletions && random.nextBoolean()) {
          Type val = valueVarList.get(random.nextInt(1 + valueVarList
              .indexOf(value)));
          final int randInt = val == value ? random.nextInt(1 + i) : random
              .nextInt(numValues);
          w.deleteDocuments(new Term(""id"", val.name() + ""_"" + randInt));
          if (val == value) {
            deleted.set(randInt);
          }
        }
        if (random.nextInt(10) == 0) {
          w.commit();
        }
      }
    }
    w.commit();

    // TODO test multi seg with deletions
    if (withDeletions || random.nextBoolean()) {
      w.forceMerge(1, true);
    }
    return deleted;
  }"
28,2690,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.TestIndexWriterLockRelease,,tearDown,,files,"files,i,length",62,62,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/test/org/apache/lucene/index/TestIndexWriterLockRelease.java#L62,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/test/org/apache/lucene/index/TestIndexWriterLockRelease.java,,unknown,"@Override
    public void tearDown() throws Exception {
        if (this.__test_dir != null) {
            File[] files = this.__test_dir.listFiles();

            for (int i = 0;
                i < files.length;
                ++i) {
                if (!files[i].delete()) {
                    throw new IOException(""unable to remove file in test directory \"""" + this.__test_dir.getPath() + ""\"" (please remove by hand)"");
                }
            }

            if (!this.__test_dir.delete()) {
                throw new IOException(""unable to remove test directory \"""" + this.__test_dir.getPath() + ""\"" (please remove by hand)"");
            }
        }
        super.tearDown();
    }"
29,2735,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.CheckIndex,,testTermIndex,,if (fieldTerms != null) {,,983,983,close,https://github.com/apache/lucene-solr/tree/c0600cc6dc84d20ab47cc321cd0e893a11c0f303//lucene/src/java/org/apache/lucene/index/CheckIndex.java#L983,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/src/java/org/apache/lucene/index/CheckIndex.java,,unknown,"private Status.TermIndexStatus testTermIndex(SegmentReader reader) {
    final Status.TermIndexStatus status = new Status.TermIndexStatus();

    final int maxDoc = reader.maxDoc();
    final Bits liveDocs = reader.getLiveDocs();

    final IndexSearcher is = new IndexSearcher(reader);

    try {

      if (infoStream != null) {
        infoStream.print(""    test: terms, freq, prox..."");
      }

      int computedFieldCount = 0;
      final Fields fields = reader.fields();
      if (fields == null) {
        msg(""OK [no fields/terms]"");
        return status;
      }
     
      DocsEnum docs = null;
      DocsEnum docsAndFreqs = null;
      DocsAndPositionsEnum postings = null;

      final FieldsEnum fieldsEnum = fields.iterator();
      while(true) {
        final String field = fieldsEnum.next();
        if (field == null) {
          break;
        }

        // TODO: really the codec should not return a field
        // from FieldsEnum if it has to Terms... but we do
        // this today:
        // assert fields.terms(field) != null;
        computedFieldCount++;
        
        final Terms terms = fieldsEnum.terms();
        if (terms == null) {
          continue;
        }

        final TermsEnum termsEnum = terms.iterator(null);

        boolean hasOrd = true;
        final long termCountStart = status.termCount;

        BytesRef lastTerm = null;

        Comparator<BytesRef> termComp = terms.getComparator();

        long sumTotalTermFreq = 0;
        long sumDocFreq = 0;
        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());
        while(true) {

          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }

          // make sure terms arrive in order according to
          // the comp
          if (lastTerm == null) {
            lastTerm = BytesRef.deepCopyOf(term);
          } else {
            if (termComp.compare(lastTerm, term) >= 0) {
              throw new RuntimeException(""terms out of order: lastTerm="" + lastTerm + "" term="" + term);
            }
            lastTerm.copyBytes(term);
          }

          final int docFreq = termsEnum.docFreq();
          if (docFreq <= 0) {
            throw new RuntimeException(""docfreq: "" + docFreq + "" is out of bounds"");
          }
          status.totFreq += docFreq;
          sumDocFreq += docFreq;

          docs = termsEnum.docs(liveDocs, docs, false);
          docsAndFreqs = termsEnum.docs(liveDocs, docsAndFreqs, true);
          postings = termsEnum.docsAndPositions(liveDocs, postings);

          if (hasOrd) {
            long ord = -1;
            try {
              ord = termsEnum.ord();
            } catch (UnsupportedOperationException uoe) {
              hasOrd = false;
            }

            if (hasOrd) {
              final long ordExpected = status.termCount - termCountStart;
              if (ord != ordExpected) {
                throw new RuntimeException(""ord mismatch: TermsEnum has ord="" + ord + "" vs actual="" + ordExpected);
              }
            }
          }

          status.termCount++;

          final DocsEnum docs2;
          final DocsEnum docsAndFreqs2;
          final boolean hasPositions;
          final boolean hasFreqs;
          if (postings != null) {
            docs2 = postings;
            docsAndFreqs2 = postings;
            hasPositions = true;
            hasFreqs = true;
          } else if (docsAndFreqs != null) {
            docs2 = docsAndFreqs;
            docsAndFreqs2 = docsAndFreqs;
            hasPositions = false;
            hasFreqs = true;
          } else {
            docs2 = docs;
            docsAndFreqs2 = null;
            hasPositions = false;
            hasFreqs = false;
          }

          int lastDoc = -1;
          int docCount = 0;
          long totalTermFreq = 0;
          while(true) {
            final int doc = docs2.nextDoc();
            if (doc == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            visitedDocs.set(doc);
            int freq = -1;
            if (hasFreqs) {
              freq = docsAndFreqs2.freq();
              if (freq <= 0) {
                throw new RuntimeException(""term "" + term + "": doc "" + doc + "": freq "" + freq + "" is out of bounds"");
              }
              status.totPos += freq;
              totalTermFreq += freq;
            }
            docCount++;

            if (doc <= lastDoc) {
              throw new RuntimeException(""term "" + term + "": doc "" + doc + "" <= lastDoc "" + lastDoc);
            }
            if (doc >= maxDoc) {
              throw new RuntimeException(""term "" + term + "": doc "" + doc + "" >= maxDoc "" + maxDoc);
            }

            lastDoc = doc;
            
            int lastPos = -1;
            if (hasPositions) {
              for(int j=0;j<freq;j++) {
                final int pos = postings.nextPosition();
                if (pos < -1) {
                  throw new RuntimeException(""term "" + term + "": doc "" + doc + "": pos "" + pos + "" is out of bounds"");
                }
                if (pos < lastPos) {
                  throw new RuntimeException(""term "" + term + "": doc "" + doc + "": pos "" + pos + "" < lastPos "" + lastPos);
                }
                lastPos = pos;
                if (postings.hasPayload()) {
                  postings.getPayload();
                }
              }
            }
          }
          
          final long totalTermFreq2 = termsEnum.totalTermFreq();
          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;

          // Re-count if there are deleted docs:
          if (reader.hasDeletions()) {
            if (hasFreqs) {
              final DocsEnum docsNoDel = termsEnum.docs(null, docsAndFreqs, true);
              docCount = 0;
              totalTermFreq = 0;
              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
                visitedDocs.set(docsNoDel.docID());
                docCount++;
                totalTermFreq += docsNoDel.freq();
              }
            } else {
              final DocsEnum docsNoDel = termsEnum.docs(null, docs, false);
              docCount = 0;
              totalTermFreq = -1;
              while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
                visitedDocs.set(docsNoDel.docID());
                docCount++;
              }
            }
          }

          if (docCount != docFreq) {
            throw new RuntimeException(""term "" + term + "" docFreq="" + docFreq + "" != tot docs w/o deletions "" + docCount);
          }
          if (hasTotalTermFreq) {
            if (totalTermFreq2 <= 0) {
              throw new RuntimeException(""totalTermFreq: "" + totalTermFreq2 + "" is out of bounds"");
            }
            sumTotalTermFreq += totalTermFreq;
            if (totalTermFreq != totalTermFreq2) {
              throw new RuntimeException(""term "" + term + "" totalTermFreq="" + totalTermFreq2 + "" != recomputed totalTermFreq="" + totalTermFreq);
            }
          }

          // Test skipping
          if (hasPositions) {
            for(int idx=0;idx<7;idx++) {
              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);
              postings = termsEnum.docsAndPositions(liveDocs, postings);
              final int docID = postings.advance(skipDocID);
              if (docID == DocsEnum.NO_MORE_DOCS) {
                break;
              } else {
                if (docID < skipDocID) {
                  throw new RuntimeException(""term "" + term + "": advance(docID="" + skipDocID + "") returned docID="" + docID);
                }
                final int freq = postings.freq();
                if (freq <= 0) {
                  throw new RuntimeException(""termFreq "" + freq + "" is out of bounds"");
                }
                int lastPosition = -1;
                for(int posUpto=0;posUpto<freq;posUpto++) {
                  final int pos = postings.nextPosition();
                  if (pos < 0) {
                    throw new RuntimeException(""position "" + pos + "" is out of bounds"");
                  }
                  if (pos < lastPosition) {
                    throw new RuntimeException(""position "" + pos + "" is < lastPosition "" + lastPosition);
                  }
                  lastPosition = pos;
                } 

                final int nextDocID = postings.nextDoc();
                if (nextDocID == DocsEnum.NO_MORE_DOCS) {
                  break;
                }
                if (nextDocID <= docID) {
                  throw new RuntimeException(""term "" + term + "": advance(docID="" + skipDocID + ""), then .next() returned docID="" + nextDocID + "" vs prev docID="" + docID);
                }
              }
            }
          } else {
            for(int idx=0;idx<7;idx++) {
              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);
              docs = termsEnum.docs(liveDocs, docs, false);
              final int docID = docs.advance(skipDocID);
              if (docID == DocsEnum.NO_MORE_DOCS) {
                break;
              } else {
                if (docID < skipDocID) {
                  throw new RuntimeException(""term "" + term + "": advance(docID="" + skipDocID + "") returned docID="" + docID);
                }
                final int nextDocID = docs.nextDoc();
                if (nextDocID == DocsEnum.NO_MORE_DOCS) {
                  break;
                }
                if (nextDocID <= docID) {
                  throw new RuntimeException(""term "" + term + "": advance(docID="" + skipDocID + ""), then .next() returned docID="" + nextDocID + "" vs prev docID="" + docID);
                }
              }
            }
          }
        }
        
        final Terms fieldTerms = fields.terms(field);
        if (fieldTerms == null) {
          // Unusual: the FieldsEnum returned a field but
          // the Terms for that field is null; this should
          // only happen if it's a ghost field (field with
          // no terms, eg there used to be terms but all
          // docs got deleted and then merged away):
          // make sure TermsEnum is empty:
          final Terms fieldTerms2 = fieldsEnum.terms();
          if (fieldTerms2 != null && fieldTerms2.iterator(null).next() != null) {
            throw new RuntimeException(""Fields.terms(field="" + field + "") returned null yet the field appears to have terms"");
          }
        } else {
          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {
            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();
            assert stats != null;
            if (status.blockTreeStats == null) {
              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();
            }
            status.blockTreeStats.put(field, stats);
          }

          if (sumTotalTermFreq != 0) {
            final long v = fields.terms(field).getSumTotalTermFreq();
            if (v != -1 && sumTotalTermFreq != v) {
              throw new RuntimeException(""sumTotalTermFreq for field "" + field + ""="" + v + "" != recomputed sumTotalTermFreq="" + sumTotalTermFreq);
            }
          }
        
          if (sumDocFreq != 0) {
            final long v = fields.terms(field).getSumDocFreq();
            if (v != -1 && sumDocFreq != v) {
              throw new RuntimeException(""sumDocFreq for field "" + field + ""="" + v + "" != recomputed sumDocFreq="" + sumDocFreq);
            }
          }
        
          if (fieldTerms != null) {
            final int v = fieldTerms.getDocCount();
            if (v != -1 && visitedDocs.cardinality() != v) {
              throw new RuntimeException(""docCount for field "" + field + ""="" + v + "" != recomputed docCount="" + visitedDocs.cardinality());
            }
          }

          // Test seek to last term:
          if (lastTerm != null) {
            if (termsEnum.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { 
              throw new RuntimeException(""seek to last term "" + lastTerm + "" failed"");
            }

            is.search(new TermQuery(new Term(field, lastTerm)), 1);
          }
          
          // check unique term count
          long termCount = -1;
          
          if (status.termCount-termCountStart > 0) {
            termCount = fields.terms(field).getUniqueTermCount();
            
            if (termCount != -1 && termCount != status.termCount - termCountStart) {
              throw new RuntimeException(""termCount mismatch "" + termCount + "" vs "" + (status.termCount - termCountStart));
            }
          }
          
          // Test seeking by ord
          if (hasOrd && status.termCount-termCountStart > 0) {
            int seekCount = (int) Math.min(10000L, termCount);
            if (seekCount > 0) {
              BytesRef[] seekTerms = new BytesRef[seekCount];
            
              // Seek by ord
              for(int i=seekCount-1;i>=0;i--) {
                long ord = i*(termCount/seekCount);
                termsEnum.seekExact(ord);
                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());
              }

              // Seek by term
              long totDocCount = 0;
              for(int i=seekCount-1;i>=0;i--) {
                if (termsEnum.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {
                  throw new RuntimeException(""seek to existing term "" + seekTerms[i] + "" failed"");
                }
              
                docs = termsEnum.docs(liveDocs, docs, false);
                if (docs == null) {
                  throw new RuntimeException(""null DocsEnum from to existing term "" + seekTerms[i]);
                }

                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {
                  totDocCount++;
                }
              }

              // TermQuery
              long totDocCount2 = 0;
              for(int i=0;i<seekCount;i++) {
                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;
              }

              if (totDocCount != totDocCount2) {
                throw new RuntimeException(""search to seek terms produced wrong number of hits: "" + totDocCount + "" vs "" + totDocCount2);
              }
            }
          }
        }
      }
      
      int fieldCount = fields.getUniqueFieldCount();
      
      if (fieldCount != -1) {
        if (fieldCount < 0) {
          throw new RuntimeException(""invalid fieldCount: "" + fieldCount);
        }
        if (fieldCount != computedFieldCount) {
          throw new RuntimeException(""fieldCount mismatch "" + fieldCount + "" vs recomputed field count "" + computedFieldCount);
        }
      }

      // for most implementations, this is boring (just the sum across all fields)
      // but codecs that don't work per-field like preflex actually implement this,
      // but don't implement it on Terms, so the check isn't redundant.
      long uniqueTermCountAllFields = reader.getUniqueTermCount();
      
      // this means something is seriously screwed, e.g. we are somehow getting enclosed in PFCW!!!!!!
      
      if (uniqueTermCountAllFields == -1) {
        throw new RuntimeException(""invalid termCount: -1"");
     }

      if (status.termCount != uniqueTermCountAllFields) {
        throw new RuntimeException(""termCount mismatch "" + uniqueTermCountAllFields + "" vs "" + (status.termCount));
      }

      msg(""OK ["" + status.termCount + "" terms; "" + status.totFreq + "" terms/docs pairs; "" + status.totPos + "" tokens]"");

      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {
        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {
          infoStream.println(""      field \"""" + ent.getKey() + ""\"":"");
          infoStream.println(""      "" + ent.getValue().toString().replace(""\n"", ""\n      ""));
        }
      }

    } catch (Throwable e) {
      msg(""ERROR: "" + e);
      status.error = e;
      if (infoStream != null) {
        e.printStackTrace(infoStream);
      }
    }

    return status;
  }"
30,1833,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.solr.update,org.apache.solr.update.DocumentBuilder,,addField,,copyFields,"copyFields,copyFields,null,null,sfield,size",146,146,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/update/DocumentBuilder.java#L146,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/update/DocumentBuilder.java,,unknown,"public void addField(SchemaField sfield, String val, float boost) {
    addSingleField(sfield,val,boost);
  }"
31,2191,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.DocumentsWriter,,finishFlush,,if (bufferedDeletes != null && bufferedDeletes.any()) {,,480,480,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java#L480,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java,,unknown,"void finishFlush(FlushedSegment newSegment, FrozenBufferedDeletes bufferedDeletes)
      throws IOException {
    // Finish the flushed segment and publish it to IndexWriter
    if (newSegment == null) {
      assert bufferedDeletes != null;
      if (bufferedDeletes != null && bufferedDeletes.any()) {
        indexWriter.publishFrozenDeletes(bufferedDeletes);
        if (infoStream.isEnabled(""DW"")) {
          infoStream.message(""DW"", ""flush: push buffered deletes: "" + bufferedDeletes);
        }
      }
    } else {
      publishFlushedSegment(newSegment, bufferedDeletes);  
    }
  }"
32,2375,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.solr.search,org.apache.solr.search.ReturnFields,,add,,if (key==null) {,,333,333,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/search/ReturnFields.java#L333,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/search/ReturnFields.java,,unknown,"private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {
    if( fl == null ) {
      return;
    }
    try {
      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);

      for(;;) {
        sp.opt(',');
        sp.eatws();
        if (sp.pos >= sp.end) break;

        int start = sp.pos;

        // short circuit test for a really simple field name
        String key = null;
        String field = getFieldName(sp);
        char ch = sp.ch();

        if (field != null) {
          if (sp.opt(':')) {
            // this was a key, not a field name
            key = field;
            field = null;
            sp.eatws();
            start = sp.pos;
          } else {
            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {
              addField( field, key, augmenters, req );
              continue;
            }
            // an invalid field name... reset the position pointer to retry
            sp.pos = start;
            field = null;
          }
        }

        if (key != null) {
          // we read ""key : ""
          field = sp.getId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            rename.add(field, key);
            addField( field, key, augmenters, req );
            continue;
          }
          // an invalid field name... reset the position pointer to retry
          sp.pos = start;
          field = null;
        }

        if (field == null) {
          // We didn't find a simple name, so let's see if it's a globbed field name.
          // Globbing only works with field names of the recommended form (roughly like java identifiers)

          field = sp.getGlobbedId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            // ""*"" looks and acts like a glob, but we give it special treatment
            if (""*"".equals(field)) {
              _wantsAllFields = true;
            } else {
              globs.add(field);
            }
            continue;
          }

          // an invalid glob
          sp.pos = start;
        }

        String funcStr = sp.val.substring(start);

        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?
        // This is identical to localParams syntax except it uses [] instead of {!}

        if (funcStr.startsWith(""["")) {
          Map<String,String> augmenterArgs = new HashMap<String,String>();
          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), ""["", ']');
          sp.pos += end;
          
          // [foo] is short for [type=foo] in localParams syntax
          String augmenterName = augmenterArgs.remove(""type""); 
          String disp = key;
          if( disp == null ) {
            disp = '['+augmenterName+']';
          }

          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );
          if( factory != null ) {
            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );
            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );
          }
          else {
            // unknown transformer?
          }
          addField(field, disp, augmenters, req);
          continue;
        }


        // let's try it as a function instead
        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);
        Query q = null;
        ValueSource vs = null;

        try {
          if (parser instanceof FunctionQParser) {
            FunctionQParser fparser = (FunctionQParser)parser;
            fparser.setParseMultipleSources(false);
            fparser.setParseToEnd(false);

            q = fparser.getQuery();

            if (fparser.localParams != null) {
              if (fparser.valFollowedParams) {
                // need to find the end of the function query via the string parser
                int leftOver = fparser.sp.end - fparser.sp.pos;
                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
              } else {
                // the value was via the ""v"" param in localParams, so we need to find
                // the end of the local params themselves to pick up where we left off
                sp.pos = start + fparser.localParamsEnd;
              }
            } else {
              // need to find the end of the function query via the string parser
              int leftOver = fparser.sp.end - fparser.sp.pos;
              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
            }
          } else {
            // A QParser that's not for function queries.
            // It must have been specified via local params.
            q = parser.getQuery();

            assert parser.getLocalParams() != null;
            sp.pos = start + parser.localParamsEnd;
          }


          if (q instanceof FunctionQuery) {
            vs = ((FunctionQuery)q).getValueSource();
          } else {
            vs = new QueryValueSource(q, 0.0f);
          }

          if (key==null) {
            SolrParams localParams = parser.getLocalParams();
            if (localParams != null) {
              key = localParams.get(""key"");
            }
            if (key == null) {
              // use the function name itself as the field name
              key = sp.val.substring(start, sp.pos);
            }
          }


          if (key==null) {
            key = funcStr;
          }
          okFieldNames.add( key );
          okFieldNames.add( funcStr );
          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );
        }
        catch (SyntaxError e) {
          // try again, simple rules for a field name with no whitespace
          sp.pos = start;
          field = sp.getSimpleString();

          if (req.getSchema().getFieldOrNull(field) != null) {
            // OK, it was an oddly named field
            fields.add(field);
            if( key != null ) {
              rename.add(field, key);
            }
          } else {
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname: "" + e.getMessage(), e);
          }
        }

       // end try as function

      } // end for(;;)
    } catch (SyntaxError e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname"", e);
    }
  }"
33,2547,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,B,last,,STYLE,org.apache.solr.update,org.apache.solr.update.UpdateLog,,getLogList,,Arrays.sort(names);,,330,330,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/update/UpdateLog.java#L330,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/update/UpdateLog.java,,close,"public static String[] getLogList(File directory) {
    final String prefix = TLOG_NAME+'.';
    String[] names = directory.list(new FilenameFilter() {
      @Override
      public boolean accept(File dir, String name) {
        return name.startsWith(prefix);
      }
    });
    Arrays.sort(names);
    return names;
  }"
34,2708,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.solr.schema,org.apache.solr.schema.CurrencyField,,init,,this.defaultCurrency,"defaultCurrency,java,null,Currency,getInstance,util",98,98,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/schema/CurrencyField.java#L98,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/schema/CurrencyField.java,,close,"@Override
  protected void init(IndexSchema schema, Map<String, String> args) {
    super.init(schema, args);
    if (this.isMultiValued()) { 
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, 
                              ""CurrencyField types can not be multiValued: "" + 
                              this.typeName);
    }
    this.schema = schema;
    this.exchangeRateProviderClass = args.get(PARAM_RATE_PROVIDER_CLASS);
    this.defaultCurrency = args.get(PARAM_DEFAULT_CURRENCY);

    if (this.defaultCurrency == null) {
      this.defaultCurrency = DEFAULT_DEFAULT_CURRENCY;
    }
    
    if (this.exchangeRateProviderClass == null) {
      this.exchangeRateProviderClass = DEFAULT_RATE_PROVIDER_CLASS;
    }

    if (java.util.Currency.getInstance(this.defaultCurrency) == null) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Invalid currency code "" + this.defaultCurrency);
    }

    String precisionStepString = args.get(PARAM_PRECISION_STEP);
    if (precisionStepString == null) {
      precisionStepString = DEFAULT_PRECISION_STEP;
    }

    // Initialize field type for amount
    fieldTypeAmountRaw = new TrieLongField();
    fieldTypeAmountRaw.setTypeName(""amount_raw_type_tlong"");
    Map<String,String> map = new HashMap<String,String>(1);
    map.put(""precisionStep"", precisionStepString);
    fieldTypeAmountRaw.init(schema, map);
    
    // Initialize field type for currency string
    fieldTypeCurrency = new StrField();
    fieldTypeCurrency.setTypeName(""currency_type_string"");
    fieldTypeCurrency.init(schema, new HashMap<String,String>());
    
    args.remove(PARAM_RATE_PROVIDER_CLASS);
    args.remove(PARAM_DEFAULT_CURRENCY);
    args.remove(PARAM_PRECISION_STEP);

    try {
      Class<? extends ExchangeRateProvider> c = schema.getResourceLoader().findClass(exchangeRateProviderClass, ExchangeRateProvider.class);
      provider = c.newInstance();
      provider.init(args);
    } catch (Exception e) {
      throw new SolrException(ErrorCode.BAD_REQUEST, ""Error instansiating exhange rate provider ""+exchangeRateProviderClass+"". Please check your FieldType configuration"", e);
    }
  }"
35,2731,lucene-solr,UWF_NULL_FIELD,B,last,,CORRECTNESS,org.apache.lucene.analysis.phonetic,org.apache.lucene.analysis.phonetic.PhoneticFilterFactory,name,,,,,-2,-2,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//lucene/analysis/phonetic/src/java/org/apache/lucene/analysis/phonetic/PhoneticFilterFactory.java#L-2,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/analysis/phonetic/src/java/org/apache/lucene/analysis/phonetic/PhoneticFilterFactory.java,,close,
36,2955,lucene-solr,NP_NULL_ON_SOME_PATH_EXCEPTION,B,last,,CORRECTNESS,org.apache.solr.update,org.apache.solr.update.SolrCmdDistributor$1,,call,,clonedRequest,"clonedRequest,e,exception",335,335,close,https://github.com/apache/lucene-solr/tree/9e82c2409d62e7be04dc4fae7c45c3712be639a2//solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.java#L335,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/update/SolrCmdDistributor.java,,unknown,"@Override
      public Request call() throws Exception {
        Request clonedRequest = null;
        try {
          clonedRequest = new Request();
          clonedRequest.node = sreq.node;
          clonedRequest.ureq = sreq.ureq;
          clonedRequest.retries = sreq.retries;
          
          String fullUrl;
          if (!url.startsWith(""http://"") && !url.startsWith(""https://"")) {
            fullUrl = ""http://"" + url;
          } else {
            fullUrl = url;
          }
  
          HttpSolrServer server = new HttpSolrServer(fullUrl,
              updateShardHandler.getHttpClient());
          
          if (Thread.currentThread().isInterrupted()) {
            clonedRequest.rspCode = 503;
            clonedRequest.exception = new SolrException(ErrorCode.SERVICE_UNAVAILABLE, ""Shutting down."");
            return clonedRequest;
          }
          
          clonedRequest.ursp = server.request(clonedRequest.ureq);
          
          // currently no way to get the request body.
        } catch (Exception e) {
          clonedRequest.exception = e;
          if (e instanceof SolrException) {
            clonedRequest.rspCode = ((SolrException) e).code();
          } else {
            clonedRequest.rspCode = -1;
          }
        } finally {
          semaphore.release();
        }
        return clonedRequest;
      }"
37,1710,lucene-solr,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,C,last,,CORRECTNESS,org.apache.solr.core,org.apache.solr.core.ZkContainer,,getSolrConfigFromZk,,SystemIdResolver,"SystemIdResolver,is,setSystemId",277,277,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/core/ZkContainer.java#L277,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/core/ZkContainer.java,,unknown,"public SolrConfig getSolrConfigFromZk(String zkConfigName, String solrConfigFileName,
      SolrResourceLoader resourceLoader) {
    SolrConfig cfg = null;
    try {
      byte[] config = zkController.getConfigFileData(zkConfigName,
          solrConfigFileName);
      InputSource is = new InputSource(new ByteArrayInputStream(config));
      is.setSystemId(SystemIdResolver
          .createSystemIdFromResourceName(solrConfigFileName));
      cfg = solrConfigFileName == null ? new SolrConfig(resourceLoader,
          SolrConfig.DEFAULT_CONF_FILE, is) : new SolrConfig(resourceLoader,
          solrConfigFileName, is);
    } catch (Exception e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
          ""getSolrConfigFromZK failed for "" + zkConfigName + "" ""
              + solrConfigFileName, e);
    }
    return cfg;
  }"
38,1808,lucene-solr,NP_NULL_ON_SOME_PATH,C,last,,CORRECTNESS,org.apache.lucene.search,org.apache.lucene.search.BooleanScorer,,<init>,,coordFactors,"coordFactors,float",231,231,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java#L231,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java,,unknown,
39,1815,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.lucene.benchmark.byTask.feeds,org.apache.lucene.benchmark.byTask.feeds.ContentItemsSource,,collectFiles,,Arrays,"Arrays,dirFiles,sort",90,90,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentItemsSource.java#L90,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentItemsSource.java,,unknown,"protected final void collectFiles(File dir, ArrayList<File> files) {
    if (!dir.canRead()) {
      return;
    }
    
    File[] dirFiles = dir.listFiles();
    Arrays.sort(dirFiles);
    for (int i = 0; i < dirFiles.length; i++) {
      File file = dirFiles[i];
      if (file.isDirectory()) {
        collectFiles(file, files);
      } else if (file.canRead()) {
        files.add(file);
      }
    }
  }"
40,1835,lucene-solr,NP_LOAD_OF_KNOWN_NULL_VALUE,C,last,,STYLE,org.apache.solr.parser,org.apache.solr.parser.SolrQueryParserBase,,getReversedWildcardFilterFactory,,fac,"fac,fac,leadingWildcards,null,containsKey",679,679,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java#L679,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java,,open,"protected ReversedWildcardFilterFactory getReversedWildcardFilterFactory(FieldType fieldType) {
    if (leadingWildcards == null) leadingWildcards = new HashMap<FieldType, ReversedWildcardFilterFactory>();
    ReversedWildcardFilterFactory fac = leadingWildcards.get(fieldType);
    if (fac != null || leadingWildcards.containsKey(fac)) {
      return fac;
    }

    Analyzer a = fieldType.getAnalyzer();
    if (a instanceof TokenizerChain) {
      // examine the indexing analysis chain if it supports leading wildcards
      TokenizerChain tc = (TokenizerChain)a;
      TokenFilterFactory[] factories = tc.getTokenFilterFactories();
      for (TokenFilterFactory factory : factories) {
        if (factory instanceof ReversedWildcardFilterFactory) {
          fac = (ReversedWildcardFilterFactory)factory;
          break;
        }
      }
    }

    leadingWildcards.put(fieldType, fac);
    return fac;
  }"
41,1859,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.solr.core,org.apache.solr.core.CorePropertiesLocator,,discoverUnder,,root,"root,listFiles",130,130,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/core/CorePropertiesLocator.java#L130,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/core/CorePropertiesLocator.java,,unknown,"private void discoverUnder(File root, List<CoreDescriptor> cds, CoreContainer cc) {
    if (!root.exists())
      return;
    for (File child : root.listFiles()) {
      File propertiesFile = new File(child, PROPERTIES_FILENAME);
      if (propertiesFile.exists()) {
        CoreDescriptor cd = buildCoreDescriptor(propertiesFile, cc);
        logger.info(""Found core {} in {}"", cd.getName(), cd.getInstanceDir());
        cds.add(cd);
        continue;
      }
      if (child.isDirectory())
        discoverUnder(child, cds, cc);
    }
  }"
42,1896,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.solr.util,org.apache.solr.util.AbstractSolrTestCase,,recurseDelete,,f,"f,listFiles",135,135,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java#L135,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java,,unknown,"public static boolean recurseDelete(File f) {
    if (f.isDirectory()) {
      for (File sub : f.listFiles()) {
        if (!recurseDelete(sub)) {
          System.err.println(""!!!! WARNING: best effort to remove "" + sub.getAbsolutePath() + "" FAILED !!!!!"");
          return false;
        }
      }
    }
    return f.delete();
  }"
43,1970,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.lucene.benchmark.byTask.feeds,org.apache.lucene.benchmark.byTask.feeds.DirContentSource$Iterator,,push,,push(f.listFiles(new FileFilter() {,,108,108,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DirContentSource.java#L108,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DirContentSource.java,,unknown,"void push(File f) {
      push(f.listFiles(new FileFilter() {

        @Override
        public boolean accept(File file) {
          return file.isDirectory();
        }
      }));
      push(f.listFiles(new FileFilter() {

        @Override
        public boolean accept(File file) {
          return file.getName().endsWith("".txt"");
        }
      }));
      find();
    }"
44,2082,lucene-solr,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.lucene.benchmark.utils,org.apache.lucene.benchmark.utils.ExtractReuters,,<init>,,outputDir,"outputDir,listFiles",47,47,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/benchmark/src/java/org/apache/lucene/benchmark/utils/ExtractReuters.java#L47,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/benchmark/src/java/org/apache/lucene/benchmark/utils/ExtractReuters.java,,close,
45,2133,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.solr.search,org.apache.solr.search.SolrReturnFields,,add,,if (key==null) {,,330,330,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/search/SolrReturnFields.java#L330,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/search/SolrReturnFields.java,,close,"private void add(String fl, NamedList<String> rename, DocTransformers augmenters, SolrQueryRequest req) {
    if( fl == null ) {
      return;
    }
    try {
      QueryParsing.StrParser sp = new QueryParsing.StrParser(fl);

      for(;;) {
        sp.opt(',');
        sp.eatws();
        if (sp.pos >= sp.end) break;

        int start = sp.pos;

        // short circuit test for a really simple field name
        String key = null;
        String field = getFieldName(sp);
        char ch = sp.ch();

        if (field != null) {
          if (sp.opt(':')) {
            // this was a key, not a field name
            key = field;
            field = null;
            sp.eatws();
            start = sp.pos;
          } else {
            if (Character.isWhitespace(ch) || ch == ',' || ch==0) {
              addField( field, key, augmenters, req );
              continue;
            }
            // an invalid field name... reset the position pointer to retry
            sp.pos = start;
            field = null;
          }
        }

        if (key != null) {
          // we read ""key : ""
          field = sp.getId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            rename.add(field, key);
            addField( field, key, augmenters, req );
            continue;
          }
          // an invalid field name... reset the position pointer to retry
          sp.pos = start;
          field = null;
        }

        if (field == null) {
          // We didn't find a simple name, so let's see if it's a globbed field name.
          // Globbing only works with field names of the recommended form (roughly like java identifiers)

          field = sp.getGlobbedId(null);
          ch = sp.ch();
          if (field != null && (Character.isWhitespace(ch) || ch == ',' || ch==0)) {
            // ""*"" looks and acts like a glob, but we give it special treatment
            if (""*"".equals(field)) {
              _wantsAllFields = true;
            } else {
              globs.add(field);
            }
            continue;
          }

          // an invalid glob
          sp.pos = start;
        }

        String funcStr = sp.val.substring(start);

        // Is it an augmenter of the form [augmenter_name foo=1 bar=myfield]?
        // This is identical to localParams syntax except it uses [] instead of {!}

        if (funcStr.startsWith(""["")) {
          Map<String,String> augmenterArgs = new HashMap<String,String>();
          int end = QueryParsing.parseLocalParams(funcStr, 0, augmenterArgs, req.getParams(), ""["", ']');
          sp.pos += end;

          // [foo] is short for [type=foo] in localParams syntax
          String augmenterName = augmenterArgs.remove(""type"");
          String disp = key;
          if( disp == null ) {
            disp = '['+augmenterName+']';
          }

          TransformerFactory factory = req.getCore().getTransformerFactory( augmenterName );
          if( factory != null ) {
            MapSolrParams augmenterParams = new MapSolrParams( augmenterArgs );
            augmenters.addTransformer( factory.create(disp, augmenterParams, req) );
          }
          else {
            // unknown transformer?
          }
          addField(field, disp, augmenters, req);
          continue;
        }


        // let's try it as a function instead
        QParser parser = QParser.getParser(funcStr, FunctionQParserPlugin.NAME, req);
        Query q = null;
        ValueSource vs = null;

        try {
          if (parser instanceof FunctionQParser) {
            FunctionQParser fparser = (FunctionQParser)parser;
            fparser.setParseMultipleSources(false);
            fparser.setParseToEnd(false);

            q = fparser.getQuery();

            if (fparser.localParams != null) {
              if (fparser.valFollowedParams) {
                // need to find the end of the function query via the string parser
                int leftOver = fparser.sp.end - fparser.sp.pos;
                sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
              } else {
                // the value was via the ""v"" param in localParams, so we need to find
                // the end of the local params themselves to pick up where we left off
                sp.pos = start + fparser.localParamsEnd;
              }
            } else {
              // need to find the end of the function query via the string parser
              int leftOver = fparser.sp.end - fparser.sp.pos;
              sp.pos = sp.end - leftOver;   // reset our parser to the same amount of leftover
            }
          } else {
            // A QParser that's not for function queries.
            // It must have been specified via local params.
            q = parser.getQuery();

            assert parser.getLocalParams() != null;
            sp.pos = start + parser.localParamsEnd;
          }


          if (q instanceof FunctionQuery) {
            vs = ((FunctionQuery)q).getValueSource();
          } else {
            vs = new QueryValueSource(q, 0.0f);
          }

          if (key==null) {
            SolrParams localParams = parser.getLocalParams();
            if (localParams != null) {
              key = localParams.get(""key"");
            }
            if (key == null) {
              // use the function name itself as the field name
              key = sp.val.substring(start, sp.pos);
            }
          }


          if (key==null) {
            key = funcStr;
          }
          okFieldNames.add( key );
          okFieldNames.add( funcStr );
          augmenters.addTransformer( new ValueSourceAugmenter( key, parser, vs ) );
        }
        catch (SyntaxError e) {
          // try again, simple rules for a field name with no whitespace
          sp.pos = start;
          field = sp.getSimpleString();

          if (req.getSchema().getFieldOrNull(field) != null) {
            // OK, it was an oddly named field
            fields.add(field);
            if( key != null ) {
              rename.add(field, key);
            }
          } else {
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname: "" + e.getMessage(), e);
          }
        }

        // end try as function

      } // end for(;;)
    } catch (SyntaxError e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, ""Error parsing fieldname"", e);
    }
  }"
46,2145,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.solr.handler.admin,org.apache.solr.handler.admin.CollectionsHandler,,handleCreateAction,,name,"name,null",301,301,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java#L301,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java,,unknown,"private void handleCreateAction(SolrQueryRequest req,
      SolrQueryResponse rsp) throws InterruptedException, KeeperException {
    log.info(""Creating Collection : "" + req.getParamString());
    String name = req.getParams().required().get(""name"");
    if (name == null) {
      log.error(""Collection name is required to create a new collection"");
      throw new SolrException(ErrorCode.BAD_REQUEST,
          ""Collection name is required to create a new collection"");
    }
    
    Map<String,Object> props = ZkNodeProps.makeMap(
        Overseer.QUEUE_OPERATION,
        OverseerCollectionProcessor.CREATECOLLECTION,
        ""fromApi"",""true"");
    copyIfNotNull(req.getParams(),props,
        ""name"",
        REPLICATION_FACTOR,
         COLL_CONF,
         NUM_SLICES,
         MAX_SHARDS_PER_NODE,
        CREATE_NODE_SET ,
        SHARDS_PROP,
        ""router."");

    copyPropertiesIfNotNull(req.getParams(), props);

    ZkNodeProps m = new ZkNodeProps(props);
    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);
  }"
47,2277,lucene-solr,NP_LOAD_OF_KNOWN_NULL_VALUE,C,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.MappedMultiFields$MappedMultiTermsEnum,,docsAndPositions,,flags,"flags,in,liveDocs,mappingDocsAndPositionsEnum,docsAndPositions,multiDocsAndPositionsEnum",131,131,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/index/MappedMultiFields.java#L131,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/index/MappedMultiFields.java,,unknown,"@Override
    public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) throws IOException {
      if (liveDocs != null) {
        throw new IllegalArgumentException(""liveDocs must be null"");
      }
      MappingMultiDocsAndPositionsEnum mappingDocsAndPositionsEnum;
      if (reuse instanceof MappingMultiDocsAndPositionsEnum) {
        mappingDocsAndPositionsEnum = (MappingMultiDocsAndPositionsEnum) reuse;
      } else {
        mappingDocsAndPositionsEnum = new MappingMultiDocsAndPositionsEnum(mergeState);
      }
      
      MultiDocsAndPositionsEnum docsAndPositionsEnum = (MultiDocsAndPositionsEnum) in.docsAndPositions(liveDocs, mappingDocsAndPositionsEnum.multiDocsAndPositionsEnum, flags);
      mappingDocsAndPositionsEnum.reset(docsAndPositionsEnum);
      return mappingDocsAndPositionsEnum;
    }"
48,2311,lucene-solr,NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT,C,last,,BAD_PRACTICE,org.apache.lucene.spatial.bbox,org.apache.lucene.spatial.bbox.BBoxSimilarityValueSource,,equals,,,,-2,-2,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource.java#L-2,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource.java,,unknown,"@Override
  public boolean equals(Object o) {
    if (o.getClass() != BBoxSimilarityValueSource.class) {
      return false;
    }

    BBoxSimilarityValueSource other = (BBoxSimilarityValueSource) o;
    return similarity.equals(other.similarity);
  }"
49,2430,lucene-solr,NP_LOAD_OF_KNOWN_NULL_VALUE,C,last,,STYLE,org.apache.lucene.util.fst,org.apache.lucene.util.fst.FST,,assertRootArcs,,asserting,"asserting,null,null,root",486,486,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/util/fst/FST.java#L486,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/util/fst/FST.java,,unknown,"private boolean assertRootArcs() {
    assert cachedRootArcs != null;
    assert assertingCachedRootArcs != null;
    for (int i = 0; i < cachedRootArcs.length; i++) {
      final Arc<T> root = cachedRootArcs[i];
      final Arc<T> asserting = assertingCachedRootArcs[i];
      if (root != null) { 
        assert root.arcIdx == asserting.arcIdx;
        assert root.bytesPerArc == asserting.bytesPerArc;
        assert root.flags == asserting.flags;
        assert root.label == asserting.label;
        assert root.nextArc == asserting.nextArc;
        assert root.nextFinalOutput.equals(asserting.nextFinalOutput);
        assert root.node == asserting.node;
        assert root.numArcs == asserting.numArcs;
        assert root.output.equals(asserting.output);
        assert root.posArcsStart == asserting.posArcsStart;
        assert root.target == asserting.target;
      } else {
        assert root == null && asserting == null;
      } 
    }
    return true;
  }"
50,2448,lucene-solr,NP_NULL_ON_SOME_PATH,C,last,,CORRECTNESS,org.apache.lucene.codecs,org.apache.lucene.codecs.BlockTreeTermsReader$FieldReader$IntersectEnum,index,<init>,,arcs,"arcs,index,getFirstArc",867,867,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java#L867,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java,,unknown,
51,2575,lucene-solr,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,C,last,,CORRECTNESS,org.apache.solr.handler.dataimport,org.apache.solr.handler.dataimport.DocBuilder,,<init>,,verboseDebug = reqParams.isDebug() && reqParams.getDebugInfo().verbose;,,93,93,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java#L93,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder.java,,open,
52,2733,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.lucene.index,org.apache.lucene.index.FieldInfos$FieldNumbers,,addOrGet,,currentDVType,"currentDVType,currentDVType,dvType,null",193,193,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//lucene/core/src/java/org/apache/lucene/index/FieldInfos.java#L193,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//lucene/core/src/java/org/apache/lucene/index/FieldInfos.java,,close,"synchronized int addOrGet(String fieldName, int preferredFieldNumber, DocValuesType dvType) {
      if (dvType != null) {
        DocValuesType currentDVType = docValuesType.get(fieldName);
        if (currentDVType == null) {
          docValuesType.put(fieldName, dvType);
        } else if (currentDVType != null && currentDVType != dvType) {
          throw new IllegalArgumentException(""cannot change DocValues type from "" + currentDVType + "" to "" + dvType + "" for field \"""" + fieldName + ""\"""");
        }
      }
      Integer fieldNumber = nameToNumber.get(fieldName);
      if (fieldNumber == null) {
        final Integer preferredBoxed = Integer.valueOf(preferredFieldNumber);

        if (preferredFieldNumber != -1 && !numberToName.containsKey(preferredBoxed)) {
          // cool - we can use this number globally
          fieldNumber = preferredBoxed;
        } else {
          // find a new FieldNumber
          while (numberToName.containsKey(++lowestUnassignedFieldNumber)) {
            // might not be up to date - lets do the work once needed
          }
          fieldNumber = lowestUnassignedFieldNumber;
        }
        
        numberToName.put(fieldNumber, fieldName);
        nameToNumber.put(fieldName, fieldNumber);
      }

      return fieldNumber.intValue();
    }"
53,2833,lucene-solr,RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE,C,last,,STYLE,org.apache.solr.core,org.apache.solr.core.SolrCores,,remove,,ret = (ret == null) ? tmp : ret;,,238,238,close,https://github.com/apache/lucene-solr/tree/43535fecb8455b3f9364f447e129ae05f79697e2//solr/core/src/java/org/apache/solr/core/SolrCores.java#L238,https://github.com/apache/lucene-solr/tree/3291ef884d26e3f8cb43707f2acdf674f3e51c01//solr/core/src/java/org/apache/solr/core/SolrCores.java,,open,"protected SolrCore remove(String name, boolean removeOrig) {

    synchronized (modifyLock) {
      SolrCore tmp = cores.remove(name);
      SolrCore ret = null;
      if (removeOrig && tmp != null) {
        coreToOrigName.remove(tmp);
      }
      ret = (ret == null) ? tmp : ret;
      // It could have been a newly-created core. It could have been a transient core. The newly-created cores
      // in particular should be checked. It could have been a dynamic core.
      tmp = transientCores.remove(name);
      ret = (ret == null) ? tmp : ret;
      tmp = createdCores.remove(name);
      ret = (ret == null) ? tmp : ret;
      dynamicDescriptors.remove(name);
      return ret;
    }
  }"
54,9679,ant,NP_NULL_ON_SOME_PATH,C,last,,CORRECTNESS,org.apache.tools.ant,org.apache.tools.ant.IntrospectionHelper,,setAttribute,,"as.setObject(p, element, value);",,411,411,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/IntrospectionHelper.java#L411,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/IntrospectionHelper.java,,close,"public void setAttribute(Project p, Object element, String attributeName,
            Object value) throws BuildException {
        AttributeSetter as = (AttributeSetter) attributeSetters.get(
                attributeName.toLowerCase(Locale.ENGLISH));
        if (as == null && value != null) {
            if (element instanceof DynamicAttributeNS) {
                DynamicAttributeNS dc = (DynamicAttributeNS) element;
                String uriPlusPrefix = ProjectHelper.extractUriFromComponentName(attributeName);
                String uri = ProjectHelper.extractUriFromComponentName(uriPlusPrefix);
                String localName = ProjectHelper.extractNameFromComponentName(attributeName);
                String qName = """".equals(uri) ? localName : uri + "":"" + localName;
                dc.setDynamicAttribute(uri, localName, qName, value.toString());
                return;
            }
            if (element instanceof DynamicObjectAttribute) {
                DynamicObjectAttribute dc = (DynamicObjectAttribute) element;
                dc.setDynamicAttribute(attributeName.toLowerCase(Locale.ENGLISH), value);
                return;
            }
            if (element instanceof DynamicAttribute) {
                DynamicAttribute dc = (DynamicAttribute) element;
                dc.setDynamicAttribute(attributeName.toLowerCase(Locale.ENGLISH), value.toString());
                return;
            }
            if (attributeName.indexOf(':') >= 0) {
                return; // Ignore attribute from unknown uri's
            }
            String msg = getElementName(p, element)
                    + "" doesn't support the \"""" + attributeName + ""\"" attribute."";
            throw new UnsupportedAttributeException(msg, attributeName);
        }
        try {
            as.setObject(p, element, value);
        } catch (IllegalAccessException ie) {
            // impossible as getMethods should only return public methods
            throw new BuildException(ie);
        } catch (InvocationTargetException ite) {
            throw extractBuildException(ite);
        }
    }"
55,9722,ant,NP_NULL_ON_SOME_PATH_EXCEPTION,C,last,,CORRECTNESS,org.apache.tools.ant,org.apache.tools.ant.ArgumentProcessorRegistry,,getProcessorByService,,isr,"isr,close",160,160,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/ArgumentProcessorRegistry.java#L160,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/ArgumentProcessorRegistry.java,,close,"private ArgumentProcessor getProcessorByService(InputStream is)
            throws IOException {
        InputStreamReader isr = null;
        try {
            try {
                isr = new InputStreamReader(is, ""UTF-8"");
            } catch (java.io.UnsupportedEncodingException e) {
                isr = new InputStreamReader(is);
            }
            BufferedReader rd = new BufferedReader(isr);
            String processorClassName = rd.readLine();
            if (processorClassName != null && !"""".equals(processorClassName)) {
                return getProcessor(processorClassName);
            }
        } finally {
            try {
                isr.close();
            } catch (IOException e) {
                // ignore
            }
        }
        return null;
    }"
56,9824,ant,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.tools.ant,org.apache.tools.ant.Diagnostics,,getXSLTProcessor,,,"null,transformerFactory",217,217,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/Diagnostics.java#L217,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/Diagnostics.java,,open,"private static Transformer getXSLTProcessor() {
        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        if (transformerFactory == null) {
            return null;
        }
        Transformer transformer = null;
        try {
            transformer = transformerFactory.newTransformer();
        } catch (Exception e) {
            // ignore
            ignoreThrowable(e);
        }
        return transformer;
    }"
57,9838,ant,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.XSLTProcess,,process,,,"null,outFileName,outFileName,length",830,830,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java#L830,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java,,close,"private void process(File baseDir, String xmlFile, File destDir, Resource stylesheet)
            throws BuildException {

        File   outF = null;
        File   inF = null;

        try {
            long styleSheetLastModified = stylesheet.getLastModified();
            inF = new File(baseDir, xmlFile);

            if (inF.isDirectory()) {
                log(""Skipping "" + inF + "" it is a directory."", Project.MSG_VERBOSE);
                return;
            }
            FileNameMapper mapper = null;
            if (mapperElement != null) {
                mapper = mapperElement.getImplementation();
            } else {
                mapper = new StyleMapper();
            }

            String[] outFileName = mapper.mapFileName(xmlFile);
            if (outFileName == null || outFileName.length == 0) {
                log(""Skipping "" + inFile + "" it cannot get mapped to output."", Project.MSG_VERBOSE);
                return;
            } else if (outFileName == null || outFileName.length > 1) {
                log(""Skipping "" + inFile + "" its mapping is ambiguos."", Project.MSG_VERBOSE);
                return;
            }
            outF = new File(destDir, outFileName[0]);

            if (force || inF.lastModified() > outF.lastModified()
                    || styleSheetLastModified > outF.lastModified()) {
                ensureDirectoryFor(outF);
                log(""Processing "" + inF + "" to "" + outF);
                configureLiaison(stylesheet);
                setLiaisonDynamicFileParameters(liaison, inF);
                liaison.transform(inF, outF);
            }
        } catch (Exception ex) {
            // If failed to process document, must delete target document,
            // or it will not attempt to process it the second time
            log(""Failed to process "" + inFile, Project.MSG_INFO);
            if (outF != null) {
                outF.delete();
            }
            handleTransformationError(ex);
        }

    }"
58,9847,ant,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.tools.ant.taskdefs.condition,org.apache.tools.ant.taskdefs.condition.IsLastModified,,getMillis,,,"null,pe",147,147,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/condition/IsLastModified.java#L147,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/condition/IsLastModified.java,,close,"protected long getMillis() throws BuildException {
        if (millis >= 0) {
            return millis;
        }
        if (""now"".equalsIgnoreCase(dateTime)) {
            return System.currentTimeMillis();
        }
        DateFormat df = dfFactory.getPrimaryFormat();
        ParseException pe = null;
        try {
            return df.parse(dateTime).getTime();
        } catch (ParseException peOne) {
            df = dfFactory.getFallbackFormat();
            if (df == null) {
                pe = peOne;
            } else {
                try {
                    return df.parse(dateTime).getTime();
                } catch (ParseException peTwo) {
                    pe = peTwo;
                }
            }
        }
        if (pe != null) {
            throw new BuildException(pe.getMessage(), pe, getLocation());
        }
        /* NOTREACHED */
        return 0;
    }"
59,9856,ant,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,C,last,,CORRECTNESS,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Jar,filesetManifestConfig,setFilesetmanifest,,config,"config,mergeManifestsMain,equals,getValue",416,416,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/main/org/apache/tools/ant/taskdefs/Jar.java#L416,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Jar.java,,close,"public void setFilesetmanifest(FilesetManifestConfig config) {
        filesetManifestConfig = config;
        mergeManifestsMain = ""merge"".equals(config.getValue());

        if (filesetManifestConfig != null
            && !filesetManifestConfig.getValue().equals(""skip"")) {

            doubleFilePass = true;
        }
    }"
60,9925,ant,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.tools.ant.types.selectors,org.apache.tools.ant.types.selectors.ContainsRegexpTest$TaskdefForRegexpTest,,test,,filecount,"filecount,files,length",75,75,close,https://github.com/apache/ant/tree/c92f8f160a3197e8f3df74ceb588f581d08404c0//src/tests/junit/org/apache/tools/ant/types/selectors/ContainsRegexpTest.java#L75,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/tests/junit/org/apache/tools/ant/types/selectors/ContainsRegexpTest.java,,unknown,"public void test() {
            File dir = null;
            File[] files = null;
            int filecount;

            executeTarget(""containsregexp"");
	
            dir = new File(getProjectDir() + ""/regexpseltestdest/"");
            files = dir.listFiles();
            filecount = files.length;
	
            if (filecount != 1)
                assertEquals(""ContainsRegexp test should have copied 1 file"",
                             1, files.length);
	
        }"
61,9678,ant,NP_LOAD_OF_KNOWN_NULL_VALUE,A,last,,STYLE,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Execute$WinNTCommandLauncher,,exec,,cmd,"cmd,env,exec,project",982,982,close,https://github.com/apache/ant/tree/02d9f46c2941a8ae665322e49d4d12ae7343ab3b//src/main/org/apache/tools/ant/taskdefs/Execute.java#L982,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Execute.java,,unknown,"public Process exec(Project project, String[] cmd, String[] env)
             throws IOException {
            if (project != null) {
                project.log(""Execute:CommandLauncher: ""
                    + Commandline.describeCommand(cmd), Project.MSG_DEBUG);
            }
            return Runtime.getRuntime().exec(cmd, env);
        }"
62,9837,ant,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.tools.ant.types,org.apache.tools.ant.types.Description,,concatDescriptions,,,"null,tasks",95,95,close,https://github.com/apache/ant/tree/02d9f46c2941a8ae665322e49d4d12ae7343ab3b//src/main/org/apache/tools/ant/types/Description.java#L95,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/types/Description.java,,close,"private static void concatDescriptions(Project project, Target t,
                                           StringBuffer description) {
        if (t == null) {
            return;
        }
        Vector tasks = findElementInTarget(project, t, ""description"");
        if (tasks == null) {
            return;
        }
        final int size = tasks.size();
        for (int i = 0; i < size; i++) {
            Task task = (Task) tasks.elementAt(i);
            if (!(task instanceof UnknownElement)) {
                continue;
            }
            UnknownElement ue = ((UnknownElement) task);
            String descComp = ue.getWrapper().getText().toString();
            if (descComp != null) {
                description.append(project.replaceProperties(descComp));
            }
        }
    }"
63,9896,ant,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,A,last,,CORRECTNESS,org.apache.tools.ant.taskdefs,org.apache.tools.ant.taskdefs.Available,loader,checkClass,,FALSE,"false,loader,setParentFirst",443,443,close,https://github.com/apache/ant/tree/02d9f46c2941a8ae665322e49d4d12ae7343ab3b//src/main/org/apache/tools/ant/taskdefs/Available.java#L443,https://github.com/apache/ant/tree/7a7307bc999be080c99412b1c67d111af1366ef7//src/main/org/apache/tools/ant/taskdefs/Available.java,,open,"private boolean checkClass(String classname) {
        try {
            if (ignoreSystemclasses) {
                loader = getProject().createClassLoader(classpath);
                loader.setParentFirst(false);
                loader.addJavaLibraries();
                if (loader != null) {
                    try {
                        loader.findClass(classname);
                    } catch (SecurityException se) {
                        // class found but restricted name; this is
                        // actually the case we're looking for in JDK 1.3+,
                        // so catch the exception and return
                        return true;
                    }
                } else {
                    return false;
                }
            } else if (loader != null) {
                loader.loadClass(classname);
            } else {
                ClassLoader l = this.getClass().getClassLoader();
                // Can return null to represent the bootstrap class loader.
                // see API docs of Class.getClassLoader.
                if (l != null) {
                    Class.forName(classname, true, l);
                } else {
                    Class.forName(classname);
                }
            }
            return true;
        } catch (ClassNotFoundException e) {
            log(""class \"""" + classname + ""\"" was not found"",
                Project.MSG_DEBUG);
            return false;
        } catch (NoClassDefFoundError e) {
            log(""Could not load dependent class \"""" + e.getMessage()
                + ""\"" for class \"""" + classname + ""\"""",
                Project.MSG_DEBUG);
            return false;
        }
    }"
64,9971,maven,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,C,last,,CORRECTNESS,org.apache.maven.plugin,org.apache.maven.plugin.PluginParameterExpressionEvaluator,,<init>,,this.properties,"properties,session,getExecutionProperties",95,95,close,https://github.com/apache/maven/tree/93d07bdf9967303e8ff41b8f8030c72ecf59ce1c//maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java#L95,https://github.com/apache/maven/tree/a7dddcb87626fec256f1b8ccbe957f94cdf401e4//maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java,,unknown,
65,9989,maven,NP_LOAD_OF_KNOWN_NULL_VALUE,C,last,,STYLE,org.apache.maven.project,org.apache.maven.project.DefaultProjectBuildingHelper,,createProjectRealm,,pluginArtifactsCache,"pluginArtifactsCache,project,recordArtifacts,register",247,247,close,https://github.com/apache/maven/tree/93d07bdf9967303e8ff41b8f8030c72ecf59ce1c//maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuildingHelper.java#L247,https://github.com/apache/maven/tree/a7dddcb87626fec256f1b8ccbe957f94cdf401e4//maven-core/src/main/java/org/apache/maven/project/DefaultProjectBuildingHelper.java,,unknown,"public synchronized ProjectRealmCache.CacheRecord createProjectRealm( MavenProject project, Model model,
                                                                          ProjectBuildingRequest request )
        throws PluginResolutionException, PluginVersionResolutionException
    {
        ClassRealm projectRealm = null;

        List<Plugin> extensionPlugins = new ArrayList<Plugin>();

        Build build = model.getBuild();

        if ( build != null )
        {
            for ( Extension extension : build.getExtensions() )
            {
                Plugin plugin = new Plugin();
                plugin.setGroupId( extension.getGroupId() );
                plugin.setArtifactId( extension.getArtifactId() );
                plugin.setVersion( extension.getVersion() );
                extensionPlugins.add( plugin );
            }

            for ( Plugin plugin : build.getPlugins() )
            {
                if ( plugin.isExtensions() )
                {
                    extensionPlugins.add( plugin );
                }
            }
        }

        if ( extensionPlugins.isEmpty() )
        {
            if ( logger.isDebugEnabled() )
            {
                logger.debug( ""Extension realms for project "" + model.getId() + "": (none)"" );
            }

            return new ProjectRealmCache.CacheRecord( null, null );
        }

        List<ClassRealm> extensionRealms = new ArrayList<ClassRealm>();

        Map<ClassRealm, List<String>> exportedPackages = new HashMap<ClassRealm, List<String>>();

        Map<ClassRealm, List<String>> exportedArtifacts = new HashMap<ClassRealm, List<String>>();

        List<Artifact> publicArtifacts = new ArrayList<Artifact>();

        for ( Plugin plugin : extensionPlugins )
        {
            if ( plugin.getVersion() == null )
            {
                PluginVersionRequest versionRequest =
                    new DefaultPluginVersionRequest( plugin, request.getRepositorySession(),
                                                     project.getRemotePluginRepositories() );
                plugin.setVersion( pluginVersionResolver.resolve( versionRequest ).getVersion() );
            }

            List<Artifact> artifacts;

            PluginArtifactsCache.Key cacheKey =
                pluginArtifactsCache.createKey( plugin, null, project.getRemotePluginRepositories(),
                                                request.getRepositorySession() );

            PluginArtifactsCache.CacheRecord recordArtifacts = pluginArtifactsCache.get( cacheKey );

            if ( recordArtifacts != null )
            {
                artifacts = recordArtifacts.artifacts;
            }
            else
            {
                try
                {
                    artifacts = resolveExtensionArtifacts( plugin, project.getRemotePluginRepositories(), request );

                    recordArtifacts = pluginArtifactsCache.put( cacheKey, artifacts );
                }
                catch ( PluginResolutionException e )
                {
                    pluginArtifactsCache.put( cacheKey, e );

                    pluginArtifactsCache.register( project, recordArtifacts );

                    throw e;
                }
            }

            pluginArtifactsCache.register( project, recordArtifacts );

            ClassRealm extensionRealm;
            ExtensionDescriptor extensionDescriptor = null;

            ExtensionRealmCache.CacheRecord recordRealm = extensionRealmCache.get( artifacts );

            if ( recordRealm != null )
            {
                extensionRealm = recordRealm.realm;
                extensionDescriptor = recordRealm.desciptor;
            }
            else
            {
                extensionRealm = classRealmManager.createExtensionRealm( plugin, artifacts );

                try
                {
                    ( (DefaultPlexusContainer) container ).discoverComponents( extensionRealm,
                                                                               MojoExecutionScope.getScopeModule( container ) );
                }
                catch ( Exception e )
                {
                    throw new IllegalStateException( ""Failed to discover components in extension realm ""
                        + extensionRealm.getId(), e );
                }

                Artifact extensionArtifact = artifacts.get( 0 );
                try
                {
                    extensionDescriptor = extensionDescriptorBuilder.build( extensionArtifact.getFile() );
                }
                catch ( IOException e )
                {
                    String message = ""Invalid extension descriptor for "" + plugin.getId() + "": "" + e.getMessage();
                    if ( logger.isDebugEnabled() )
                    {
                        logger.error( message, e );
                    }
                    else
                    {
                        logger.error( message );
                    }
                }

                recordRealm = extensionRealmCache.put( artifacts, extensionRealm, extensionDescriptor );
            }

            extensionRealmCache.register( project, recordRealm );

            extensionRealms.add( extensionRealm );
            if ( extensionDescriptor != null )
            {
                exportedPackages.put( extensionRealm, extensionDescriptor.getExportedPackages() );
                exportedArtifacts.put( extensionRealm, extensionDescriptor.getExportedArtifacts() );
            }

            if ( !plugin.isExtensions() && artifacts.size() == 2 && artifacts.get( 0 ).getFile() != null
                && ""plexus-utils"".equals( artifacts.get( 1 ).getArtifactId() ) )
            {
                /*
                 * This is purely for backward-compat with 2.x where <extensions> consisting of a single artifact where
                 * loaded into the core and hence available to plugins, in contrast to bigger extensions that were
                 * loaded into a dedicated realm which is invisible to plugins (MNG-2749).
                 */
                publicArtifacts.add( artifacts.get( 0 ) );
            }
        }

        if ( logger.isDebugEnabled() )
        {
            logger.debug( ""Extension realms for project "" + model.getId() + "": "" + extensionRealms );
        }

        ProjectRealmCache.CacheRecord record = projectRealmCache.get( extensionRealms );

        if ( record == null )
        {
            projectRealm = classRealmManager.createProjectRealm( model, publicArtifacts );

            Set<String> exclusions = new LinkedHashSet<String>();

            for ( ClassRealm extensionRealm : extensionRealms )
            {
                List<String> excludes = exportedArtifacts.get( extensionRealm );

                if ( excludes != null )
                {
                    exclusions.addAll( excludes );
                }

                List<String> exports = exportedPackages.get( extensionRealm );

                if ( exports == null || exports.isEmpty() )
                {
                    /*
                     * Most existing extensions don't define exported packages, i.e. no classes are to be exposed to
                     * plugins, yet the components provided by the extension (e.g. artifact handlers) must be
                     * accessible, i.e. we still must import the extension realm into the project realm.
                     */
                    exports = Arrays.asList( extensionRealm.getId() );
                }

                for ( String export : exports )
                {
                    projectRealm.importFrom( extensionRealm, export );
                }
            }

            DependencyFilter extensionArtifactFilter = null;
            if ( !exclusions.isEmpty() )
            {
                extensionArtifactFilter = new ExclusionsDependencyFilter( exclusions );
            }

            record = projectRealmCache.put( extensionRealms, projectRealm, extensionArtifactFilter );
        }

        projectRealmCache.register( project, record );

        return record;
    }"
66,9996,maven,NP_LOAD_OF_KNOWN_NULL_VALUE,C,last,,STYLE,org.apache.maven.plugin,org.apache.maven.plugin.PluginParameterExpressionEvaluator,,evaluate,,,"null,null,properties,value",379,379,close,https://github.com/apache/maven/tree/93d07bdf9967303e8ff41b8f8030c72ecf59ce1c//maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java#L379,https://github.com/apache/maven/tree/a7dddcb87626fec256f1b8ccbe957f94cdf401e4//maven-core/src/main/java/org/apache/maven/plugin/PluginParameterExpressionEvaluator.java,,close,"public Object evaluate( String expr )
        throws ExpressionEvaluationException
    {
        return evaluate( expr, null );
    }"
67,1023,tomcat,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,C,last,,CORRECTNESS,org.apache.tomcat.util.modeler.modules,org.apache.tomcat.util.modeler.modules.MbeansDescriptorsIntrospectionSource,,createManagedBean,,invokeAttMap,"invokeAttMap,name,get",337,337,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java#L337,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/modeler/modules/MbeansDescriptorsIntrospectionSource.java,,open,"public ManagedBean createManagedBean(Registry registry, String domain,
                                         Class<?> realClass, String type)
    {
        ManagedBean mbean= new ManagedBean();

        Method methods[]=null;

        Hashtable<String,Method> attMap = new Hashtable<>();
        // key: attribute val: getter method
        Hashtable<String,Method> getAttMap = new Hashtable<>();
        // key: attribute val: setter method
        Hashtable<String,Method> setAttMap = new Hashtable<>();
        // key: operation val: invoke method
        Hashtable<String,Method> invokeAttMap = new Hashtable<>();

        methods = realClass.getMethods();

        initMethods(realClass, methods, attMap, getAttMap, setAttMap, invokeAttMap );

        try {

            Enumeration<String> en = attMap.keys();
            while( en.hasMoreElements() ) {
                String name = en.nextElement();
                AttributeInfo ai=new AttributeInfo();
                ai.setName( name );
                Method gm = getAttMap.get(name);
                if( gm!=null ) {
                    //ai.setGetMethodObj( gm );
                    ai.setGetMethod( gm.getName());
                    Class<?> t=gm.getReturnType();
                    if( t!=null )
                        ai.setType( t.getName() );
                }
                Method sm = setAttMap.get(name);
                if( sm!=null ) {
                    //ai.setSetMethodObj(sm);
                    Class<?> t = sm.getParameterTypes()[0];
                    if( t!=null )
                        ai.setType( t.getName());
                    ai.setSetMethod( sm.getName());
                }
                ai.setDescription(""Introspected attribute "" + name);
                if( log.isDebugEnabled()) log.debug(""Introspected attribute "" +
                        name + "" "" + gm + "" "" + sm);
                if( gm==null )
                    ai.setReadable(false);
                if( sm==null )
                    ai.setWriteable(false);
                if( sm!=null || gm!=null )
                    mbean.addAttribute(ai);
            }

            en=invokeAttMap.keys();
            while( en.hasMoreElements() ) {
                String name = en.nextElement();
                Method m = invokeAttMap.get(name);
                if( m!=null && name != null ) {
                    OperationInfo op=new OperationInfo();
                    op.setName(name);
                    op.setReturnType(m.getReturnType().getName());
                    op.setDescription(""Introspected operation "" + name);
                    Class<?> parms[] = m.getParameterTypes();
                    for(int i=0; i<parms.length; i++ ) {
                        ParameterInfo pi=new ParameterInfo();
                        pi.setType(parms[i].getName());
                        pi.setName( ""param"" + i);
                        pi.setDescription(""Introspected parameter param"" + i);
                        op.addParameter(pi);
                    }
                    mbean.addOperation(op);
                } else {
                    log.error(""Null arg "" + name + "" "" + m );
                }
            }

            if( log.isDebugEnabled())
                log.debug(""Setting name: "" + type );
            mbean.setName( type );

            return mbean;
        } catch( Exception ex ) {
            ex.printStackTrace();
            return null;
        }
    }"
68,1090,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.catalina.startup,org.apache.catalina.startup.ClassLoaderFactory,,createClassLoader,,for (int j = 0; j < filenames.length; j++) {,,194,194,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/startup/ClassLoaderFactory.java#L194,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/startup/ClassLoaderFactory.java,,close,"public static ClassLoader createClassLoader(File unpacked[],
                                                File packed[],
                                                final ClassLoader parent)
        throws Exception {

        if (log.isDebugEnabled())
            log.debug(""Creating new class loader"");

        // Construct the ""class path"" for this class loader
        Set<URL> set = new LinkedHashSet<>();

        // Add unpacked directories
        if (unpacked != null) {
            for (int i = 0; i < unpacked.length; i++)  {
                File file = unpacked[i];
                if (!file.exists() || !file.canRead())
                    continue;
                file = new File(file.getCanonicalPath() + File.separator);
                URL url = file.toURI().toURL();
                if (log.isDebugEnabled())
                    log.debug(""  Including directory "" + url);
                set.add(url);
            }
        }

        // Add packed directory JAR files
        if (packed != null) {
            for (int i = 0; i < packed.length; i++) {
                File directory = packed[i];
                if (!directory.isDirectory() || !directory.exists() ||
                    !directory.canRead())
                    continue;
                String filenames[] = directory.list();
                for (int j = 0; j < filenames.length; j++) {
                    String filename = filenames[j].toLowerCase(Locale.ENGLISH);
                    if (!filename.endsWith("".jar""))
                        continue;
                    File file = new File(directory, filenames[j]);
                    if (log.isDebugEnabled())
                        log.debug(""  Including jar file "" + file.getAbsolutePath());
                    URL url = file.toURI().toURL();
                    set.add(url);
                }
            }
        }

        // Construct the class loader itself
        final URL[] array = set.toArray(new URL[set.size()]);
        return AccessController.doPrivileged(
                new PrivilegedAction<URLClassLoader>() {
                    @Override
                    public URLClassLoader run() {
                        if (parent == null)
                            return new URLClassLoader(array);
                        else
                            return new URLClassLoader(array, parent);
                    }
                });
    }"
69,1091,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.catalina.valves,org.apache.catalina.valves.AccessLogValve$RequestElement,,addElement,,if (method == null) {,,1608,1608,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/valves/AccessLogValve.java#L1608,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/valves/AccessLogValve.java,,unknown,"@Override
        public void addElement(CharArrayWriter buf, Date date, Request request,
                Response response, long time) {
            RequestInfo info = request.getCoyoteRequest().getRequestProcessor();
            if(info != null) {
                buf.append(info.getWorkerThreadName());
            } else {
                buf.append(""-"");
            }
        }"
70,1128,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.catalina.session,org.apache.catalina.session.FileStore,,getSize,,files,"files,i,i,length",154,154,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/session/FileStore.java#L154,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/session/FileStore.java,,close,"@Override
    public int getSize() throws IOException {

        // Acquire the list of files in our storage directory
        File file = directory();
        if (file == null) {
            return (0);
        }
        String files[] = file.list();

        // Figure out which files are sessions
        int keycount = 0;
        for (int i = 0; i < files.length; i++) {
            if (files[i].endsWith(FILE_EXT)) {
                keycount++;
            }
        }
        return (keycount);

    }"
71,1141,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.catalina.loader,org.apache.catalina.loader.WebappLoader,,getClasspath,,m,"m,null,null",647,647,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/loader/WebappLoader.java#L647,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/loader/WebappLoader.java,,unknown,"public String getClasspath() {
        return classpath;
    }"
72,1151,tomcat,FI_FINALIZER_NULLS_FIELDS,C,last,,BAD_PRACTICE,org.apache.catalina.tribes.tipis,org.apache.catalina.tribes.tipis.AbstractReplicatedMap,rpcChannel,finalize,,this.rpcChannel = null;,,345,345,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java#L345,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java,,unknown,"@Override
    public void finalize() {
        if (this.rpcChannel != null) {
            this.rpcChannel.breakdown();
        }
        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
        //cleanup
        if (this.channel != null) {
            this.channel.removeChannelListener(this);
            this.channel.removeMembershipListener(this);
        }
        this.rpcChannel = null;
        this.channel = null;
        this.mapMembers.clear();
        innerMap.clear();
        this.stateTransferred = false;
        this.externalLoaders = null;
    }"
73,1161,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.jasper.servlet,org.apache.jasper.servlet.JspCServletContext,,getResourcePaths,,i,"i,i,theFiles,length",406,406,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/servlet/JspCServletContext.java#L406,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/servlet/JspCServletContext.java,,close,"@Override
    public Set<String> getResourcePaths(String path) {

        Set<String> thePaths = new HashSet<>();
        if (!path.endsWith(""/""))
            path += ""/"";
        String basePath = getRealPath(path);
        if (basePath == null)
            return (thePaths);
        File theBaseDir = new File(basePath);
        if (!theBaseDir.exists() || !theBaseDir.isDirectory())
            return (thePaths);
        String theFiles[] = theBaseDir.list();
        for (int i = 0; i < theFiles.length; i++) {
            File testFile = new File(basePath + File.separator + theFiles[i]);
            if (testFile.isFile())
                thePaths.add(path + theFiles[i]);
            else if (testFile.isDirectory())
                thePaths.add(path + theFiles[i] + ""/"");
        }
        return (thePaths);

    }"
74,1171,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.jasper,org.apache.jasper.JspCompilationContext,,<init>,,if (baseURI == null) {,,117,117,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/JspCompilationContext.java#L117,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/JspCompilationContext.java,,close,
75,1176,tomcat,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,C,last,,CORRECTNESS,org.apache.jasper.compiler,org.apache.jasper.compiler.JspDocumentParser,,startElement,,attrs,"attrs,checkPrefixes,qName,uri",303,303,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/compiler/JspDocumentParser.java#L303,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/JspDocumentParser.java,,open,"@Override
    public void startElement(
        String uri,
        String localName,
        String qName,
        Attributes attrs)
        throws SAXException {

        AttributesImpl taglibAttrs = null;
        AttributesImpl nonTaglibAttrs = null;
        AttributesImpl nonTaglibXmlnsAttrs = null;

        processChars();

        checkPrefixes(uri, qName, attrs);

        if (directivesOnly &&
            !(JSP_URI.equals(uri) && localName.startsWith(DIRECTIVE_ACTION))) {
            return;
        }

        // jsp:text must not have any subelements
        if (current instanceof Node.JspText) {
            throw new SAXParseException(
                Localizer.getMessage(""jsp.error.text.has_subelement""),
                locator);
        }

        startMark = new Mark(ctxt, path, locator.getLineNumber(),
                             locator.getColumnNumber());

        if (attrs != null) {
            /*
             * Notice that due to a bug in the underlying SAX parser, the
             * attributes must be enumerated in descending order.
             */
            boolean isTaglib = false;
            for (int i = attrs.getLength() - 1; i >= 0; i--) {
                isTaglib = false;
                String attrQName = attrs.getQName(i);
                if (!attrQName.startsWith(""xmlns"")) {
                    if (nonTaglibAttrs == null) {
                        nonTaglibAttrs = new AttributesImpl();
                    }
                    nonTaglibAttrs.addAttribute(
                        attrs.getURI(i),
                        attrs.getLocalName(i),
                        attrs.getQName(i),
                        attrs.getType(i),
                        attrs.getValue(i));
                } else {
                    if (attrQName.startsWith(""xmlns:jsp"")) {
                        isTaglib = true;
                    } else {
                        String attrUri = attrs.getValue(i);
                        // TaglibInfo for this uri already established in
                        // startPrefixMapping
                        isTaglib = pageInfo.hasTaglib(attrUri);
                    }
                    if (isTaglib) {
                        if (taglibAttrs == null) {
                            taglibAttrs = new AttributesImpl();
                        }
                        taglibAttrs.addAttribute(
                            attrs.getURI(i),
                            attrs.getLocalName(i),
                            attrs.getQName(i),
                            attrs.getType(i),
                            attrs.getValue(i));
                    } else {
                        if (nonTaglibXmlnsAttrs == null) {
                            nonTaglibXmlnsAttrs = new AttributesImpl();
                        }
                        nonTaglibXmlnsAttrs.addAttribute(
                            attrs.getURI(i),
                            attrs.getLocalName(i),
                            attrs.getQName(i),
                            attrs.getType(i),
                            attrs.getValue(i));
                    }
                }
            }
        }

        Node node = null;

        if (tagDependentPending && JSP_URI.equals(uri) &&
                     localName.equals(BODY_ACTION)) {
            tagDependentPending = false;
            tagDependentNesting++;
            current =
                parseStandardAction(
                    qName,
                    localName,
                    nonTaglibAttrs,
                    nonTaglibXmlnsAttrs,
                    taglibAttrs,
                    startMark);
            return;
        }

        if (tagDependentPending && JSP_URI.equals(uri) &&
                     localName.equals(ATTRIBUTE_ACTION)) {
            current =
                parseStandardAction(
                    qName,
                    localName,
                    nonTaglibAttrs,
                    nonTaglibXmlnsAttrs,
                    taglibAttrs,
                    startMark);
            return;
        }

        if (tagDependentPending) {
            tagDependentPending = false;
            tagDependentNesting++;
        }

        if (tagDependentNesting > 0) {
            node =
                new Node.UninterpretedTag(
                    qName,
                    localName,
                    nonTaglibAttrs,
                    nonTaglibXmlnsAttrs,
                    taglibAttrs,
                    startMark,
                    current);
        } else if (JSP_URI.equals(uri)) {
            node =
                parseStandardAction(
                    qName,
                    localName,
                    nonTaglibAttrs,
                    nonTaglibXmlnsAttrs,
                    taglibAttrs,
                    startMark);
        } else {
            node =
                parseCustomAction(
                    qName,
                    localName,
                    uri,
                    nonTaglibAttrs,
                    nonTaglibXmlnsAttrs,
                    taglibAttrs,
                    startMark,
                    current);
            if (node == null) {
                node =
                    new Node.UninterpretedTag(
                        qName,
                        localName,
                        nonTaglibAttrs,
                        nonTaglibXmlnsAttrs,
                        taglibAttrs,
                        startMark,
                        current);
            } else {
                // custom action
                String bodyType = getBodyType((Node.CustomTag) node);

                if (scriptlessBodyNode == null
                        && bodyType.equalsIgnoreCase(TagInfo.BODY_CONTENT_SCRIPTLESS)) {
                    scriptlessBodyNode = node;
                }
                else if (TagInfo.BODY_CONTENT_TAG_DEPENDENT.equalsIgnoreCase(bodyType)) {
                    tagDependentPending = true;
                }
            }
        }

        current = node;
    }"
76,1200,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.jasper,org.apache.jasper.JspC,,initClassLoader,,i,"i,i,libs,length",1527,1527,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/JspC.java#L1527,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/JspC.java,,close,"protected ClassLoader initClassLoader() throws IOException {

        classPath = getClassPath();

        ClassLoader jspcLoader = getClass().getClassLoader();
        if (jspcLoader instanceof AntClassLoader) {
            classPath += File.pathSeparator
                + ((AntClassLoader) jspcLoader).getClasspath();
        }

        // Turn the classPath into URLs
        ArrayList<URL> urls = new ArrayList<>();
        StringTokenizer tokenizer = new StringTokenizer(classPath,
                                                        File.pathSeparator);
        while (tokenizer.hasMoreTokens()) {
            String path = tokenizer.nextToken();
            try {
                File libFile = new File(path);
                urls.add(libFile.toURI().toURL());
            } catch (IOException ioe) {
                // Failing a toCanonicalPath on a file that
                // exists() should be a JVM regression test,
                // therefore we have permission to freak uot
                throw new RuntimeException(ioe.toString());
            }
        }

        File webappBase = new File(uriRoot);
        if (webappBase.exists()) {
            File classes = new File(webappBase, ""/WEB-INF/classes"");
            try {
                if (classes.exists()) {
                    classPath = classPath + File.pathSeparator
                        + classes.getCanonicalPath();
                    urls.add(classes.getCanonicalFile().toURI().toURL());
                }
            } catch (IOException ioe) {
                // failing a toCanonicalPath on a file that
                // exists() should be a JVM regression test,
                // therefore we have permission to freak out
                throw new RuntimeException(ioe.toString());
            }
            File lib = new File(webappBase, ""/WEB-INF/lib"");
            if (lib.exists() && lib.isDirectory()) {
                String[] libs = lib.list();
                for (int i = 0; i < libs.length; i++) {
                    if( libs[i].length() <5 ) continue;
                    String ext=libs[i].substring( libs[i].length() - 4 );
                    if (! "".jar"".equalsIgnoreCase(ext)) {
                        if ("".tld"".equalsIgnoreCase(ext)) {
                            log.warn(""TLD files should not be placed in ""
                                     + ""/WEB-INF/lib"");
                        }
                        continue;
                    }
                    try {
                        File libFile = new File(lib, libs[i]);
                        classPath = classPath + File.pathSeparator
                            + libFile.getAbsolutePath();
                        urls.add(libFile.getAbsoluteFile().toURI().toURL());
                    } catch (IOException ioe) {
                        // failing a toCanonicalPath on a file that
                        // exists() should be a JVM regression test,
                        // therefore we have permission to freak out
                        throw new RuntimeException(ioe.toString());
                    }
                }
            }
        }

        URL urlsA[]=new URL[urls.size()];
        urls.toArray(urlsA);
        loader = new URLClassLoader(urlsA, this.getClass().getClassLoader());
        return loader;
    }"
77,1238,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.catalina.mbeans,org.apache.catalina.mbeans.GlobalResourcesLifecycleListener,,createMBeans,,MBeanUtils,"MBeanUtils,null,user,createMBean",220,220,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java#L220,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/mbeans/GlobalResourcesLifecycleListener.java,,close,"protected void createMBeans() {

        // Look up our global naming context
        Context context = null;
        try {
            context = (Context) (new InitialContext()).lookup(""java:/"");
        } catch (NamingException e) {
            log.error(""No global naming context defined for server"");
            return;
        }

        // Recurse through the defined global JNDI resources context
        try {
            createMBeans("""", context);
        } catch (NamingException e) {
            log.error(""Exception processing Global JNDI Resources"", e);
        }

    }"
78,1242,tomcat,NP_NULL_ON_SOME_PATH_EXCEPTION,C,last,,CORRECTNESS,org.apache.catalina.session,org.apache.catalina.session.JDBCStore,driver,open,,"dbConnection = driver.connect(connectionURL, props);",,950,950,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/session/JDBCStore.java#L950,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/session/JDBCStore.java,,open,"protected Connection open() throws SQLException {

        // Do nothing if there is a database connection already open
        if (dbConnection != null)
            return (dbConnection);

        if (dataSourceName != null && dataSource == null) {
            Context initCtx;
            try {
                initCtx = new InitialContext();
                Context envCtx = (Context) initCtx.lookup(""java:comp/env"");
                this.dataSource = (DataSource) envCtx.lookup(this.dataSourceName);
            } catch (NamingException e) {
                manager.getContext().getLogger().error(
                        sm.getString(getStoreName() + "".wrongDataSource"",
                                this.dataSourceName), e);
           }
        }

        if (dataSource != null) {
            return dataSource.getConnection();
        }

        // Instantiate our database driver if necessary
        if (driver == null) {
            try {
                Class<?> clazz = Class.forName(driverName);
                driver = (Driver) clazz.newInstance();
            } catch (ClassNotFoundException ex) {
                manager.getContext().getLogger().error(sm.getString(getStoreName() + "".checkConnectionClassNotFoundException"",
                        ex.toString()));
            } catch (InstantiationException ex) {
                manager.getContext().getLogger().error(sm.getString(getStoreName() + "".checkConnectionClassNotFoundException"",
                        ex.toString()));
            } catch (IllegalAccessException ex) {
                manager.getContext().getLogger().error(sm.getString(getStoreName() + "".checkConnectionClassNotFoundException"",
                        ex.toString()));
            }
        }

        // Open a new connection
        Properties props = new Properties();
        if (connectionName != null)
            props.put(""user"", connectionName);
        if (connectionPassword != null)
            props.put(""password"", connectionPassword);
        dbConnection = driver.connect(connectionURL, props);
        dbConnection.setAutoCommit(true);
        return (dbConnection);

    }"
79,1252,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.catalina.core,org.apache.catalina.core.StandardWrapper,,getAllDeclaredMethods,,if (thisMethods == null) {,,1694,1694,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/core/StandardWrapper.java#L1694,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/core/StandardWrapper.java,,close,"protected Method[] getAllDeclaredMethods(Class<?> c) {

        if (c.equals(javax.servlet.http.HttpServlet.class)) {
            return null;
        }

        Method[] parentMethods = getAllDeclaredMethods(c.getSuperclass());

        Method[] thisMethods = c.getDeclaredMethods();
        if (thisMethods == null) {
            return parentMethods;
        }

        if ((parentMethods != null) && (parentMethods.length > 0)) {
            Method[] allMethods =
                new Method[parentMethods.length + thisMethods.length];
            System.arraycopy(parentMethods, 0, allMethods, 0,
                             parentMethods.length);
            System.arraycopy(thisMethods, 0, allMethods, parentMethods.length,
                             thisMethods.length);

            thisMethods = allMethods;
        }

        return thisMethods;
    }"
80,1304,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.tomcat.util.modeler,org.apache.tomcat.util.modeler.BaseModelMBean,,getNotificationInfo,,current,"current,null",809,809,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/tomcat/util/modeler/BaseModelMBean.java#L809,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/modeler/BaseModelMBean.java,,close,"@Override
    public MBeanNotificationInfo[] getNotificationInfo() {

        // Acquire the set of application notifications
        MBeanNotificationInfo current[] = getMBeanInfo().getNotifications();
        if (current == null)
            current = new MBeanNotificationInfo[0];
        MBeanNotificationInfo response[] =
            new MBeanNotificationInfo[current.length + 2];
 //       Descriptor descriptor = null;

        // Fill in entry for general notifications
//        descriptor = new DescriptorSupport
//            (new String[] { ""name=GENERIC"",
//                            ""descriptorType=notification"",
//                            ""log=T"",
//                            ""severity=5"",
//                            ""displayName=jmx.modelmbean.generic"" });
        response[0] = new MBeanNotificationInfo
            (new String[] { ""jmx.modelmbean.generic"" },
             ""GENERIC"",
             ""Text message notification from the managed resource"");
             //descriptor);

        // Fill in entry for attribute change notifications
//        descriptor = new DescriptorSupport
//            (new String[] { ""name=ATTRIBUTE_CHANGE"",
//                            ""descriptorType=notification"",
//                            ""log=T"",
//                            ""severity=5"",
//                            ""displayName=jmx.attribute.change"" });
        response[1] = new MBeanNotificationInfo
            (new String[] { ""jmx.attribute.change"" },
             ""ATTRIBUTE_CHANGE"",
             ""Observed MBean attribute value has changed"");
             //descriptor);

        // Copy remaining notifications as reported by the application
        System.arraycopy(current, 0, response, 2, current.length);
        return (response);

    }"
81,1320,tomcat,FI_FINALIZER_NULLS_FIELDS,C,last,,BAD_PRACTICE,org.apache.catalina.tribes.tipis,org.apache.catalina.tribes.tipis.AbstractReplicatedMap,channel,finalize,,this.channel = null;,,346,346,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java#L346,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java,,unknown,"@Override
    public void finalize() {
        if (this.rpcChannel != null) {
            this.rpcChannel.breakdown();
        }
        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
        //cleanup
        if (this.channel != null) {
            this.channel.removeChannelListener(this);
            this.channel.removeMembershipListener(this);
        }
        this.rpcChannel = null;
        this.channel = null;
        this.mapMembers.clear();
        innerMap.clear();
        this.stateTransferred = false;
        this.externalLoaders = null;
    }"
82,1346,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.catalina.startup,org.apache.catalina.startup.ContextConfig,,processAnnotationsFile,,for (String dir : dirs) {,,2003,2003,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/startup/ContextConfig.java#L2003,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/startup/ContextConfig.java,,close,"protected void processAnnotationsFile(File file, WebXml fragment,
            boolean handlesTypesOnly) {

        if (file.isDirectory()) {
            String[] dirs = file.list();
            for (String dir : dirs) {
                processAnnotationsFile(
                        new File(file,dir), fragment, handlesTypesOnly);
            }
        } else if (file.canRead() && file.getName().endsWith("".class"")) {
            FileInputStream fis = null;
            try {
                fis = new FileInputStream(file);
                processAnnotationsStream(fis, fragment, handlesTypesOnly);
            } catch (IOException e) {
                log.error(sm.getString(""contextConfig.inputStreamFile"",
                        file.getAbsolutePath()),e);
            } catch (ClassFormatException e) {
                log.error(sm.getString(""contextConfig.inputStreamFile"",
                        file.getAbsolutePath()),e);
            } finally {
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (Throwable t) {
                        ExceptionUtils.handleThrowable(t);
                    }
                }
            }
        }
    }"
83,1388,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.catalina.connector,org.apache.catalina.connector.Request,context,doGetSession,,if (context != null) {,,2768,2768,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/connector/Request.java#L2768,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/connector/Request.java,,close,"protected Session doGetSession(boolean create) {

        // There cannot be a session if no context has been assigned yet
        if (context == null) {
            return (null);
        }

        // Return the current session if it exists and is valid
        if ((session != null) && !session.isValid()) {
            session = null;
        }
        if (session != null) {
            return (session);
        }

        // Return the requested session if it exists and is valid
        Manager manager = null;
        if (context != null) {
            manager = context.getManager();
        }
        if (manager == null)
         {
            return (null);      // Sessions are not supported
        }
        if (requestedSessionId != null) {
            try {
                session = manager.findSession(requestedSessionId);
            } catch (IOException e) {
                session = null;
            }
            if ((session != null) && !session.isValid()) {
                session = null;
            }
            if (session != null) {
                session.access();
                return (session);
            }
        }

        // Create a new session if requested and the response is not committed
        if (!create) {
            return (null);
        }
        if ((context != null) && (response != null) &&
            context.getServletContext().getEffectiveSessionTrackingModes().
                    contains(SessionTrackingMode.COOKIE) &&
            response.getResponse().isCommitted()) {
            throw new IllegalStateException
              (sm.getString(""coyoteRequest.sessionCreateCommitted""));
        }

        // Attempt to reuse session id if one was submitted in a cookie
        // Do not reuse the session id if it is from a URL, to prevent possible
        // phishing attacks
        // Use the SSL session ID if one is present.
        if ((""/"".equals(context.getSessionCookiePath())
                && isRequestedSessionIdFromCookie()) || requestedSessionSSL ) {
            session = manager.createSession(getRequestedSessionId());
        } else {
            session = manager.createSession(null);
        }

        // Creating a new session cookie based on that session
        if ((session != null) && (getContext() != null)
               && getContext().getServletContext().
                       getEffectiveSessionTrackingModes().contains(
                               SessionTrackingMode.COOKIE)) {
            Cookie cookie =
                ApplicationSessionCookieConfig.createSessionCookie(
                        context, session.getIdInternal(), isSecure());

            response.addSessionCookieInternal(cookie);
        }

        if (session == null) {
            return null;
        }

        session.access();
        return session;
    }"
84,1473,tomcat,FI_FINALIZER_NULLS_FIELDS,C,last,,BAD_PRACTICE,org.apache.catalina.tribes.tipis,org.apache.catalina.tribes.tipis.AbstractReplicatedMap,externalLoaders,finalize,,this.externalLoaders = null;,,350,350,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java#L350,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java,,unknown,"@Override
    public void finalize() {
        if (this.rpcChannel != null) {
            this.rpcChannel.breakdown();
        }
        try {broadcast(MapMessage.MSG_STOP,false); }catch ( Exception ignore){}
        //cleanup
        if (this.channel != null) {
            this.channel.removeChannelListener(this);
            this.channel.removeMembershipListener(this);
        }
        this.rpcChannel = null;
        this.channel = null;
        this.mapMembers.clear();
        innerMap.clear();
        this.stateTransferred = false;
        this.externalLoaders = null;
    }"
85,1480,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.jasper.servlet,org.apache.jasper.servlet.TldScanner$TldScannerCallback$1,,visitFile,,file,"file,getFileName,toString",330,330,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/jasper/servlet/TldScanner.java#L330,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/servlet/TldScanner.java,,close,"@Override
                public FileVisitResult visitFile(Path file,
                                                 BasicFileAttributes attrs)
                        throws IOException {
                    if (!file.getFileName().toString()
                            .toLowerCase(Locale.ENGLISH).endsWith(TLD_EXT)) {
                        return FileVisitResult.CONTINUE;
                    }

                    String subPath = file.subpath(
                            filePath.getNameCount(), file.getNameCount()).toString();
                    if ('/' != File.separatorChar) {
                        subPath = subPath.replace(File.separatorChar, '/');
                    }
                    String resourcePath = webappPath + ""/"" + subPath;

                    try {
                        URL url = file.toUri().toURL();
                        TldResourcePath path = new TldResourcePath(url, resourcePath);
                        parseTld(path);
                        tldFound = true;
                    } catch (SAXException e) {
                        throw new IOException(e);
                    }
                    return FileVisitResult.CONTINUE;
                }"
86,1579,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.el.util,org.apache.el.util.MessageFactory,,get,,,"null,value",41,41,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/el/util/MessageFactory.java#L41,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/el/util/MessageFactory.java,,close,"public static String get(final String key) {
        return bundle.getString(key);
    }"
87,1580,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.catalina.startup,org.apache.catalina.startup.HomesUserDatabase,,init,,homeBaseFiles,"homeBaseFiles,i,i,length",137,137,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/startup/HomesUserDatabase.java#L137,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/startup/HomesUserDatabase.java,,close,"private void init() {

        String homeBase = userConfig.getHomeBase();
        File homeBaseDir = new File(homeBase);
        if (!homeBaseDir.exists() || !homeBaseDir.isDirectory())
            return;
        String homeBaseFiles[] = homeBaseDir.list();

        for (int i = 0; i < homeBaseFiles.length; i++) {
            File homeDir = new File(homeBaseDir, homeBaseFiles[i]);
            if (!homeDir.isDirectory() || !homeDir.canRead())
                continue;
            homes.put(homeBaseFiles[i], homeDir.toString());
        }


    }"
88,1643,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.catalina.util,org.apache.catalina.util.ExtensionValidator,,addFolderList,,files,"files,i,i,length",390,390,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/util/ExtensionValidator.java#L390,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/util/ExtensionValidator.java,,close,"private static void addFolderList(String property) {

        // get the files in the extensions directory
        String extensionsDir = System.getProperty(property);
        if (extensionsDir != null) {
            StringTokenizer extensionsTok
                = new StringTokenizer(extensionsDir, File.pathSeparator);
            while (extensionsTok.hasMoreTokens()) {
                File targetDir = new File(extensionsTok.nextToken());
                if (!targetDir.isDirectory()) {
                    continue;
                }
                File[] files = targetDir.listFiles();
                for (int i = 0; i < files.length; i++) {
                    if (files[i].getName().toLowerCase(Locale.ENGLISH).endsWith("".jar"") &&
                            files[i].isFile()) {
                        try {
                            addSystemResource(files[i]);
                        } catch (IOException e) {
                            log.error
                                (sm.getString
                                 (""extensionValidator.failload"", files[i]), e);
                        }
                    }
                }
            }
        }

    }"
89,1657,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.catalina.mbeans,org.apache.catalina.mbeans.ContainerMBean,,addValve,,,"null,valve",157,157,close,https://github.com/apache/tomcat/tree/411e4cc9b12bb4fd5aadfbb585db9b40afc90d3d//java/org/apache/catalina/mbeans/ContainerMBean.java#L157,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/mbeans/ContainerMBean.java,,unknown,"public String addValve(String valveType) throws MBeanException{
        Valve valve = null;
        try {
            valve = (Valve)Class.forName(valveType).newInstance();
        } catch (InstantiationException e) {
            throw new MBeanException(e);
        } catch (IllegalAccessException e) {
            throw new MBeanException(e);
        } catch (ClassNotFoundException e) {
            throw new MBeanException(e);
        }

        if (valve == null) {
            return null;
        }

        try {
            Container container = (Container)getManagedResource();
            container.getPipeline().addValve(valve);
        } catch (InstanceNotFoundException e) {
            throw new MBeanException(e);
        } catch (RuntimeOperationsException e) {
            throw new MBeanException(e);
        } catch (InvalidTargetObjectTypeException e) {
            throw new MBeanException(e);
        }

        if (valve instanceof JmxEnabled) {
            return ((JmxEnabled)valve).getObjectName().toString();
        } else {
            return null;
        }
    }"
90,1051,tomcat,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.tomcat.util,org.apache.tomcat.util.IntrospectionUtils,,callMethod1,,findMethod,"findMethod,methodN,params,target,getClass",455,455,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/tomcat/util/IntrospectionUtils.java#L455,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/IntrospectionUtils.java,,close,"public static Object callMethod1(Object target, String methodN,
            Object param1, String typeParam1, ClassLoader cl) throws Exception {
        if (target == null || param1 == null) {
            if (log.isDebugEnabled())
                log.debug(""IntrospectionUtils: Assert: Illegal params "" +
                        target + "" "" + param1);
        }
        if (log.isDebugEnabled())
            log.debug(""IntrospectionUtils: callMethod1 "" +
                    target.getClass().getName() + "" "" +
                    param1.getClass().getName() + "" "" + typeParam1);

        Class<?> params[] = new Class[1];
        if (typeParam1 == null)
            params[0] = param1.getClass();
        else
            params[0] = cl.loadClass(typeParam1);
        Method m = findMethod(target.getClass(), methodN, params);
        if (m == null)
            throw new NoSuchMethodException(target.getClass().getName() + "" ""
                    + methodN);
        try {
            return m.invoke(target, new Object[] { param1 });
        } catch (InvocationTargetException ie) {
            ExceptionUtils.handleThrowable(ie.getCause());
            throw ie;
        }
    }"
91,1089,tomcat,NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS,A,last,,CORRECTNESS,org.apache.catalina.tribes.tipis,org.apache.catalina.tribes.tipis.AbstractReplicatedMap,,containsValue,,return innerMap.containsValue(value);,,1026,1026,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java#L1026,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/tipis/AbstractReplicatedMap.java,,close,"@Override
    public boolean containsValue(Object value) {
        if ( value == null ) {
            return innerMap.containsValue(value);
        } else {
            Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry<K,MapEntry<K,V>> e = i.next();
                MapEntry<K,V> entry = innerMap.get(e.getKey());
                if (entry!=null && entry.isActive() && value.equals(entry.getValue())) return true;
            }//while
            return false;
        }//end if
    }"
92,1100,tomcat,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.catalina.tribes.io,org.apache.catalina.tribes.io.ReplicationStream,classLoaders,resolveProxyClass,,classLoaders,"classLoaders,classLoaders,classLoaders,null,null,length",107,107,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/catalina/tribes/io/ReplicationStream.java#L107,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/io/ReplicationStream.java,,close,"@Override
    protected Class<?> resolveProxyClass(String[] interfaces)
            throws IOException, ClassNotFoundException {

        ClassLoader latestLoader = (classLoaders!=null && classLoaders.length==0)?null:classLoaders[0];
        ClassLoader nonPublicLoader = null;
        boolean hasNonPublicInterface = false;

        // define proxy in class loader of non-public interface(s), if any
        Class<?>[] classObjs = new Class[interfaces.length];
        for (int i = 0; i < interfaces.length; i++) {
            Class<?> cl = this.resolveClass(interfaces[i]);
            if (latestLoader==null) latestLoader = cl.getClassLoader();
            if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {
                if (hasNonPublicInterface) {
                    if (nonPublicLoader != cl.getClassLoader()) {
                        throw new IllegalAccessError(
                                ""conflicting non-public interface class loaders"");
                    }
                } else {
                    nonPublicLoader = cl.getClassLoader();
                    hasNonPublicInterface = true;
                }
            }
            classObjs[i] = cl;
        }
        try {
            return Proxy.getProxyClass(hasNonPublicInterface ? nonPublicLoader
                    : latestLoader, classObjs);
        } catch (IllegalArgumentException e) {
            throw new ClassNotFoundException(null, e);
        }
    }"
93,1235,tomcat,NP_NULL_ON_SOME_PATH,A,last,,CORRECTNESS,org.apache.jasper.compiler,org.apache.jasper.compiler.PageInfo,,popPrefixMapping,,stack,"stack,removeFirst",343,343,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/jasper/compiler/PageInfo.java#L343,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/PageInfo.java,,open,"public void popPrefixMapping(String prefix) {
        LinkedList<String> stack = xmlPrefixMapper.get(prefix);
        if (stack == null || stack.size() == 0) {
            // XXX throw new Exception(""XXX"");
        }
        stack.removeFirst();
    }"
94,1258,tomcat,NP_NULL_PARAM_DEREF,A,last,,CORRECTNESS,org.apache.tomcat.util.digester,org.apache.tomcat.util.digester.SetNextRule,,end,,IntrospectionUtils,"IntrospectionUtils,methodName,parent,callMethod1",201,201,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/tomcat/util/digester/SetNextRule.java#L201,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/digester/SetNextRule.java,,open,"@Override
    public void end(String namespace, String name) throws Exception {

        // Identify the objects to be used
        Object child = digester.peek(0);
        Object parent = digester.peek(1);
        if (digester.log.isDebugEnabled()) {
            if (parent == null) {
                digester.log.debug(""[SetNextRule]{"" + digester.match +
                        ""} Call [NULL PARENT]."" +
                        methodName + ""("" + child + "")"");
            } else {
                digester.log.debug(""[SetNextRule]{"" + digester.match +
                        ""} Call "" + parent.getClass().getName() + ""."" +
                        methodName + ""("" + child + "")"");
            }
        }

        // Call the specified method
        IntrospectionUtils.callMethod1(parent, methodName,
                child, paramType, digester.getClassLoader());

    }"
95,1360,tomcat,NP_LOAD_OF_KNOWN_NULL_VALUE,A,last,,STYLE,org.apache.tomcat.util,org.apache.tomcat.util.IntrospectionUtils,,callMethod0,,log,"log,debug",475,475,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/tomcat/util/IntrospectionUtils.java#L475,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/IntrospectionUtils.java,,unknown,"@Deprecated
    public static Object callMethod0(Object target, String methodN)
            throws Exception {
        if (target == null) {
            if (log.isDebugEnabled())
                log.debug(""IntrospectionUtils: Assert: Illegal params "" +
                        target);
            return null;
        }
        if (log.isDebugEnabled())
            log.debug(""IntrospectionUtils: callMethod0 "" +
                    target.getClass().getName() + ""."" + methodN);

        Class<?> params[] = new Class[0];
        Method m = findMethod(target.getClass(), methodN, params);
        if (m == null)
            throw new NoSuchMethodException(target.getClass().getName() + "" ""
                    + methodN);
        try {
            return m.invoke(target, emptyArray);
        } catch (InvocationTargetException ie) {
            ExceptionUtils.handleThrowable(ie.getCause());
            throw ie;
        }
    }"
96,1524,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jasper,org.apache.jasper.JspCompilationContext,baseURI,<init>,,if (baseURI == null) {,,112,112,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/jasper/JspCompilationContext.java#L112,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/JspCompilationContext.java,,close,
97,1527,tomcat,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,A,last,,CORRECTNESS,org.apache.tomcat.util,org.apache.tomcat.util.IntrospectionUtils,,guessInstall,,File,"File,home",85,85,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/tomcat/util/IntrospectionUtils.java#L85,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/tomcat/util/IntrospectionUtils.java,,unknown,"public static String guessInstall(String installSysProp,
            String homeSysProp, String jarName) {
        return guessInstall(installSysProp, homeSysProp, jarName, null);
    }"
98,1673,tomcat,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.catalina.tribes.group.interceptors,org.apache.catalina.tribes.group.interceptors.TcpPingInterceptor,,sendPing,,sendPingMessage,"sendPingMessage,staticMembers,get,getMembers",131,131,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java#L131,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/tribes/group/interceptors/TcpPingInterceptor.java,,close,"protected void sendPing() {
        if (failureDetector.get()!=null) {
            //we have a reference to the failure detector
            //piggy back on that dude
            failureDetector.get().checkMembers(true);
        }else {
            if (staticOnly && staticMembers.get()!=null) {
                sendPingMessage(staticMembers.get().getMembers());
            } else {
                sendPingMessage(getMembers());
            }
        }
    }"
99,1696,tomcat,NP_NULL_PARAM_DEREF,A,last,,CORRECTNESS,org.apache.jasper.compiler,org.apache.jasper.compiler.JspUtil,,toJavaSourceType,,StringBuilder,"StringBuilder,t",1003,1003,close,https://github.com/apache/tomcat/tree/3787242a83ee5555c79fd2e4c6b6952e9195ed8b//java/org/apache/jasper/compiler/JspUtil.java#L1003,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/JspUtil.java,,open,"public static String toJavaSourceType(String type) {

        if (type.charAt(0) != '[') {
            return type;
        }

        int dims = 1;
        String t = null;
        for (int i = 1; i < type.length(); i++) {
            if (type.charAt(i) == '[') {
                dims++;
            } else {
                switch (type.charAt(i)) {
                case 'Z': t = ""boolean""; break;
                case 'B': t = ""byte""; break;
                case 'C': t = ""char""; break;
                case 'D': t = ""double""; break;
                case 'F': t = ""float""; break;
                case 'I': t = ""int""; break;
                case 'J': t = ""long""; break;
                case 'S': t = ""short""; break;
                case 'L': t = type.substring(i+1, type.indexOf(';')); break;
                }
                break;
            }
        }
        StringBuilder resultType = new StringBuilder(t);
        for (; dims > 0; dims--) {
            resultType.append(""[]"");
        }
        return resultType.toString();
    }"
100,1018,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.catalina.loader,org.apache.catalina.loader.WebappClassLoader,loaderDir,setWorkDir,,if (loaderDir == null) {,,618,618,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/catalina/loader/WebappClassLoader.java#L618,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/loader/WebappClassLoader.java,,unknown,"public void setWorkDir(File workDir) {
        this.loaderDir = new File(workDir, ""loader"");
        if (loaderDir == null) {
            canonicalLoaderDir = null;
        } else {
            try {
                canonicalLoaderDir = loaderDir.getCanonicalPath();
                if (!canonicalLoaderDir.endsWith(File.separator)) {
                    canonicalLoaderDir += File.separator;
                }
            } catch (IOException ioe) {
                canonicalLoaderDir = null;
            }
        }
    }"
101,1160,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.catalina.realm,org.apache.catalina.realm.RealmBase,,authenticate,,if (md5a1 == null),,380,380,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/catalina/realm/RealmBase.java#L380,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/catalina/realm/RealmBase.java,,open,"@Override
    public Principal authenticate(String username, String credentials) {

        String serverCredentials = getPassword(username);

        boolean validated ;
        if ( serverCredentials == null ) {
            validated = false;
        } else if(hasMessageDigest()) {
            validated = serverCredentials.equalsIgnoreCase(digest(credentials));
        } else {
            validated = serverCredentials.equals(credentials);
        }
        if(! validated ) {
            if (containerLog.isTraceEnabled()) {
                containerLog.trace(sm.getString(""realmBase.authenticateFailure"",
                                                username));
            }
            return null;
        }
        if (containerLog.isTraceEnabled()) {
            containerLog.trace(sm.getString(""realmBase.authenticateSuccess"",
                                            username));
        }

        return getPrincipal(username);
    }"
102,1310,tomcat,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.jasper.compiler,org.apache.jasper.compiler.TagPluginManager,,init,,,"null,tagPlugin",115,115,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/jasper/compiler/TagPluginManager.java#L115,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/TagPluginManager.java,,unknown,"private void init(ErrorDispatcher err) throws JasperException {
        if (initialized)
            return;

        InputStream is = ctxt.getResourceAsStream(TAG_PLUGINS_XML);
        if (is == null)
            return;

        TreeNode root = (new ParserUtils()).parseXMLDocument(TAG_PLUGINS_XML,
                                                             is);
        if (root == null) {
            return;
        }

        if (!TAG_PLUGINS_ROOT_ELEM.equals(root.getName())) {
            err.jspError(""jsp.error.plugin.wrongRootElement"", TAG_PLUGINS_XML,
                         TAG_PLUGINS_ROOT_ELEM);
        }

        tagPlugins = new HashMap<>();
        Iterator<TreeNode> pluginList = root.findChildren(""tag-plugin"");
        while (pluginList.hasNext()) {
            TreeNode pluginNode = pluginList.next();
            TreeNode tagClassNode = pluginNode.findChild(""tag-class"");
            if (tagClassNode == null) {
                // Error
                return;
            }
            String tagClass = tagClassNode.getBody().trim();
            TreeNode pluginClassNode = pluginNode.findChild(""plugin-class"");
            if (pluginClassNode == null) {
                // Error
                return;
            }

            String pluginClassStr = pluginClassNode.getBody();
            TagPlugin tagPlugin = null;
            try {
                Class<?> pluginClass = Class.forName(pluginClassStr);
                tagPlugin = (TagPlugin) pluginClass.newInstance();
            } catch (Exception e) {
                throw new JasperException(e);
            }
            if (tagPlugin == null) {
                return;
            }
            tagPlugins.put(tagClass, tagPlugin);
        }
        initialized = true;
    }"
103,1491,tomcat,NP_LOAD_OF_KNOWN_NULL_VALUE,B,last,,STYLE,org.apache.jasper.runtime,org.apache.jasper.runtime.JspWriterImpl,,write,,s,"s,write",351,351,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/jasper/runtime/JspWriterImpl.java#L351,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/runtime/JspWriterImpl.java,,unknown,"@Override
    public void write(int c) throws IOException {
        ensureOpen();
        if (bufferSize == 0) {
            initOut();
            out.write(c);
        }
        else {
            if (nextChar >= bufferSize)
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
            cb[nextChar++] = (char) c;
        }
    }"
104,1533,tomcat,UWF_NULL_FIELD,B,last,,CORRECTNESS,org.apache.jasper.compiler,org.apache.jasper.compiler.TagFileProcessor$TagFileDirectiveVisitor,tei,,,,,-2,-2,close,https://github.com/apache/tomcat/tree/ad9a49cb08bf004af97cad465bba45d21d112325//java/org/apache/jasper/compiler/TagFileProcessor.java#L-2,https://github.com/apache/tomcat/tree/2b5ab0627098a0b6654afebb914d7c25fd98638d//java/org/apache/jasper/compiler/TagFileProcessor.java,,close,
105,9492,jmeter,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.jorphan.reflect,org.apache.jorphan.reflect.ClassFinder,,addJarsInPath,,jars,"jars,x,x,length",178,178,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/jorphan/org/apache/jorphan/reflect/ClassFinder.java#L178,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/jorphan/org/apache/jorphan/reflect/ClassFinder.java,,close,"private static String[] addJarsInPath(String[] paths) {
        Set<String> fullList = new HashSet<String>();
        for (int i = 0; i < paths.length; i++) {
            final String path = paths[i];
            fullList.add(path); // Keep the unexpanded path
            // TODO - allow directories to end with .jar by removing this check?
            if (!path.endsWith(DOT_JAR)) {
                File dir = new File(path);
                if (dir.exists() && dir.isDirectory()) {
                    String[] jars = dir.list(new FilenameFilter() {
                        @Override
                        public boolean accept(File f, String name) {
                            return name.endsWith(DOT_JAR);
                        }
                    });
                    for (int x = 0; x < jars.length; x++) {
                        fullList.add(jars[x]);
                    }
                }
            }
        }
        return fullList.toArray(new String[fullList.size()]);
    }"
106,9527,jmeter,NP_LOAD_OF_KNOWN_NULL_VALUE,C,last,,STYLE,org.apache.jmeter.protocol.http.control,org.apache.jmeter.protocol.http.control.CacheManager,,setCache,,log,"log,warn",216,216,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/protocol/http/org/apache/jmeter/protocol/http/control/CacheManager.java#L216,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/protocol/http/org/apache/jmeter/protocol/http/control/CacheManager.java,,open,"private void setCache(String lastModified, String cacheControl, String expires, String etag, String url, String date) {
        if (log.isDebugEnabled()){
            log.debug(""setCache(""
                  + lastModified + "","" 
                  + cacheControl + "",""
                  + expires + "","" 
                  + etag + "",""
                  + url + "",""
                  + date
                  + "")"");
        }
        Date expiresDate = null; // i.e. not using Expires
        if (useExpires) {// Check that we are processing Expires/CacheControl
            final String MAX_AGE = ""max-age="";
            
            if(cacheControl != null && cacheControl.contains(""no-store"")) {
                // We must not store an CacheEntry, otherwise a 
                // conditional request may be made
                return;
            }
            if (expires != null) {
                try {
                    expiresDate = DateUtil.parseDate(expires);
                } catch (DateParseException e) {
                    if (log.isDebugEnabled()){
                        log.debug(""Unable to parse Expires: '""+expires+""' ""+e);
                    }
                    expiresDate = CacheManager.EXPIRED_DATE; // invalid dates must be treated as expired
                }
            }
            // if no-cache is present, ensure that expiresDate remains null, which forces revalidation
            if(cacheControl != null && !cacheControl.contains(""no-cache"")) {    
                // the max-age directive overrides the Expires header,
                if(cacheControl.contains(MAX_AGE)) {
                    long maxAgeInSecs = Long.parseLong(
                            cacheControl.substring(cacheControl.indexOf(MAX_AGE)+MAX_AGE.length())
                                .split(""[, ]"")[0] // Bug 51932 - allow for optional trailing attributes
                            );
                    expiresDate=new Date(System.currentTimeMillis()+maxAgeInSecs*1000);

                } else if(expires==null) { // No max-age && No expires
                    if(!StringUtils.isEmpty(lastModified) && !StringUtils.isEmpty(date)) {
                        try {
                            Date responseDate = DateUtil.parseDate( date );
                            Date lastModifiedAsDate = DateUtil.parseDate( lastModified );
                            // see https://developer.mozilla.org/en/HTTP_Caching_FAQ
                            // see http://www.ietf.org/rfc/rfc2616.txt#13.2.4 
                            expiresDate=new Date(System.currentTimeMillis()
                                    +Math.round((responseDate.getTime()-lastModifiedAsDate.getTime())*0.1));
                        } catch(DateParseException e) {
                            // date or lastModified may be null or in bad format
                            if(log.isWarnEnabled()) {
                                log.warn(""Failed computing expiration date with following info:""
                                    +lastModified + "","" 
                                    + cacheControl + "",""
                                    + expires + "","" 
                                    + etag + "",""
                                    + url + "",""
                                    + date);
                            }
                            // TODO Can't see anything in SPEC
                            expiresDate = new Date(System.currentTimeMillis()+ONE_YEAR_MS);                      
                        }
                    } else {
                        // TODO Can't see anything in SPEC
                        expiresDate = new Date(System.currentTimeMillis()+ONE_YEAR_MS);                      
                    }
                }  
                // else expiresDate computed in (expires!=null) condition is used
            }
        }
        getCache().put(url, new CacheEntry(lastModified, expiresDate, etag));
    }"
107,9580,jmeter,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.jorphan.reflect,org.apache.jorphan.reflect.ClassFinder,,findClassesInPathsDir,,i,"i,i,list,length",554,554,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/jorphan/org/apache/jorphan/reflect/ClassFinder.java#L554,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/jorphan/org/apache/jorphan/reflect/ClassFinder.java,,close,"private static void findClassesInPathsDir(String strPathElement, File dir, Set<String> listClasses) throws IOException {
        String[] list = dir.list();
        for (int i = 0; i < list.length; i++) {
            File file = new File(dir, list[i]);
            if (file.isDirectory()) {
                // Recursive call
                findClassesInPathsDir(strPathElement, file, listClasses);
            } else if (list[i].endsWith(DOT_CLASS) && file.exists() && (file.length() != 0)) {
                final String path = file.getPath();
                listClasses.add(path.substring(strPathElement.length() + 1,
                        path.lastIndexOf('.')) // $NON-NLS-1$
                        .replace(File.separator.charAt(0), '.')); // $NON-NLS-1$
            }
        }
    }"
108,9587,jmeter,NP_NULL_ON_SOME_PATH_EXCEPTION,C,last,,CORRECTNESS,org.apache.jmeter.config,org.apache.jmeter.config.CSVDataSet,vars,iterationStart,,a,"a,a,a,lineValues,vars,length,length",201,201,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/components/org/apache/jmeter/config/CSVDataSet.java#L201,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/components/org/apache/jmeter/config/CSVDataSet.java,,open,"@Override
    public void iterationStart(LoopIterationEvent iterEvent) {
        FileServer server = FileServer.getFileServer();
        final JMeterContext context = getThreadContext();
        String delim = getDelimiter();
        if (delim.equals(""\\t"")) { // $NON-NLS-1$
            delim = ""\t"";// Make it easier to enter a Tab // $NON-NLS-1$
        } else if (delim.length()==0){
            log.warn(""Empty delimiter converted to ','"");
            delim="","";
        }
        if (vars == null) {
            String _fileName = getFilename();
            String mode = getShareMode();
            int modeInt = CSVDataSetBeanInfo.getShareModeAsInt(mode);
            switch(modeInt){
                case CSVDataSetBeanInfo.SHARE_ALL:
                    alias = _fileName;
                    break;
                case CSVDataSetBeanInfo.SHARE_GROUP:
                    alias = _fileName+""@""+System.identityHashCode(context.getThreadGroup());
                    break;
                case CSVDataSetBeanInfo.SHARE_THREAD:
                    alias = _fileName+""@""+System.identityHashCode(context.getThread());
                    break;
                default:
                    alias = _fileName+""@""+mode; // user-specified key
                    break;
            }
            final String names = getVariableNames();
            if (names == null || names.length()==0) {
                String header = server.reserveFile(_fileName, getFileEncoding(), alias, true);
                try {
                    vars = CSVSaveService.csvSplitString(header, delim.charAt(0));
                    firstLineIsNames = true;
                } catch (IOException e) {
                    log.warn(""Could not split CSV header line"",e);
                }
            } else {
                server.reserveFile(_fileName, getFileEncoding(), alias);
                vars = JOrphanUtils.split(names, "",""); // $NON-NLS-1$
            }
        }
           
        // TODO: fetch this once as per vars above?
        JMeterVariables threadVars = context.getVariables();
        String[] lineValues = {};
        try {
            if (getQuotedData()) {
                lineValues = server.getParsedLine(alias, recycle, firstLineIsNames, delim.charAt(0));
            } else {
                String line = server.readLine(alias, recycle, firstLineIsNames);
                lineValues = JOrphanUtils.split(line, delim, false);
            }
            for (int a = 0; a < vars.length && a < lineValues.length; a++) {
                threadVars.put(vars[a], lineValues[a]);
            }
        } catch (IOException e) { // treat the same as EOF
            log.error(e.toString());
        }
        if (lineValues.length == 0) {// i.e. EOF
            if (getStopThread()) {
                throw new JMeterStopThreadException(""End of file detected"");
            }
            for (String var :vars) {
                threadVars.put(var, EOFVALUE);
            }
        }
    }"
109,9603,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.jorphan.exec,org.apache.jorphan.exec.KeyToolUtils,,<clinit>,,if (javaHome != null) {,,91,91,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/jorphan/org/apache/jorphan/exec/KeyToolUtils.java#L91,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/jorphan/org/apache/jorphan/exec/KeyToolUtils.java,,open,
110,9622,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.jmeter.save,org.apache.jmeter.save.SaveService$XStreamWrapper$1,,serializedClass,,alias,"alias,alias,null,super,type,serializedClass",101,101,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/core/org/apache/jmeter/save/SaveService.java#L101,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/core/org/apache/jmeter/save/SaveService.java,,open,"@Override
            public String serializedClass(@SuppressWarnings(""rawtypes"") // superclass does not use types 
                    Class type) {
                if (type == null) {
                    return super.serializedClass(null); // was type, but that caused FindBugs warning
                }
                String alias = classToAlias(type.getName());
                return alias == null ? super.serializedClass(type) : alias ;
                }"
111,9634,jmeter,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.jmeter.services,org.apache.jmeter.services.FileServer,,getRandomFile,,lfiles,"lfiles,length",486,486,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/core/org/apache/jmeter/services/FileServer.java#L486,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/core/org/apache/jmeter/services/FileServer.java,,open,"public File getRandomFile(String basedir, String[] extensions) {
        File input = null;
        if (basedir != null) {
            File src = new File(basedir);
            if (src.isDirectory() && src.list() != null) {
                File[] lfiles = src.listFiles(new JMeterFileFilter(extensions));
                int count = lfiles.length;
                input = lfiles[random.nextInt(count)];
            }
        }
        return input;
    }"
112,9647,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.jmeter.modifiers,org.apache.jmeter.modifiers.BSFPreProcessor,,process,,mgr,"mgr,null",40,40,close,https://github.com/apache/jmeter/tree/032cc396b962c0b5ac6a31f0b756d624be34efd0//src/components/org/apache/jmeter/modifiers/BSFPreProcessor.java#L40,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/components/org/apache/jmeter/modifiers/BSFPreProcessor.java,,open,"@Override
    public void process(){
        BSFManager mgr =null;
        try {
            mgr = getManager();
            if (mgr == null) { return; }
            processFileOrScript(mgr);
        } catch (BSFException e) {
            log.warn(""Problem in BSF script ""+e);
        } finally {
            if (mgr != null) {
                mgr.terminate();
            }
        }
    }"
113,9503,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jmeter.assertions,org.apache.jmeter.assertions.BSFAssertion,,getResult,,mgr,"mgr,null",39,39,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/components/org/apache/jmeter/assertions/BSFAssertion.java#L39,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/components/org/apache/jmeter/assertions/BSFAssertion.java,,close,"public AssertionResult getResult(SampleResult response) {
        AssertionResult result = new AssertionResult(getName());
        try {
            BSFManager mgr = getManager();
            if (mgr == null) {
                result.setFailure(true);
                result.setError(true);
                result.setFailureMessage(""BSF Manager not found"");
                return result;
            }
            mgr.declareBean(""SampleResult"", response, SampleResult.class);
            mgr.declareBean(""AssertionResult"", result, AssertionResult.class);
            processFileOrScript(mgr);
            mgr.terminate();
            result.setError(false);
        } catch (BSFException e) {
            log.warn(""Problem in BSF script ""+e);
            result.setError(true);
            result.setFailureMessage(e.toString());
        }
        return result;
    }"
114,9526,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jmeter.control.gui,org.apache.jmeter.control.gui.ModuleControllerGui,selected,reinitialize,,current,"current,null,null,selected,getTreeNode",189,189,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/components/org/apache/jmeter/control/gui/ModuleControllerGui.java#L189,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/components/org/apache/jmeter/control/gui/ModuleControllerGui.java,,unknown,"private void reinitialize() {
        TreeNodeWrapper current;
        nodesModel.removeAllElements();
        GuiPackage gp = GuiPackage.getInstance();
        JMeterTreeNode root;
        if (gp != null) {
            root = (JMeterTreeNode) GuiPackage.getInstance().getTreeModel().getRoot();
            buildNodesModel(root, """", 0); // $NON-NLS-1$
        }
        if (selected != null) {
            for (int i = 0; i < nodesModel.getSize(); i++) {
                current = (TreeNodeWrapper) nodesModel.getElementAt(i);
                if ((current.getTreeNode() == null && selected == null)
                        || (current.getTreeNode() != null && current.getTreeNode().equals(selected))) {
                    nodesModel.setSelectedItem(current);
                    break;
                }
            }
        }
    }"
115,9623,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jorphan.gui,org.apache.jorphan.gui.JLabeledChoice,,getSelectedItems,,list,"list,null",207,207,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/jorphan/org/apache/jorphan/gui/JLabeledChoice.java#L207,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/jorphan/org/apache/jorphan/gui/JLabeledChoice.java,,close,"public Object[] getSelectedItems() {
        Object list[]=choiceList.getSelectedObjects();
        if (list==null) {
            return EMPTY_OBJECT_ARRAY;
        }
        return list;
    }"
116,9645,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jmeter.timers,org.apache.jmeter.timers.BSFTimer,,delay,,mgr,"mgr,null",38,38,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/components/org/apache/jmeter/timers/BSFTimer.java#L38,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/components/org/apache/jmeter/timers/BSFTimer.java,,close,"public long delay() {
        long delay = 0;
        try {
            BSFManager mgr = getManager();
            if (mgr == null) {
                return 0; 
            }
            Object o = evalFileOrScript(mgr);
            if (o == null) {
                log.warn(""Script did not return a value"");
                return 0;
            }
            delay = Long.valueOf(o.toString()).longValue();
        } catch (NumberFormatException e) {
            log.warn(""Problem in BSF script ""+e);
        } catch (BSFException e) {
            log.warn(""Problem in BSF script ""+e);
        }
        return delay;
    }"
117,9656,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jmeter.protocol.jms.sampler,org.apache.jmeter.protocol.jms.sampler.JMSSampler,,threadStarted,,"""QueueConnectionFactory expected, but got """,,321,321,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/JMSSampler.java#L321,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/JMSSampler.java,,open,"public void threadStarted() {
        logThreadStart();

        Context context = null;
        thrown = null;
        try {
            context = getInitialContext();
            Object obj = context.lookup(getQueueConnectionFactory());
            if (!(obj instanceof QueueConnectionFactory)) {
                String msg = ""QueueConnectionFactory expected, but got ""
                    + obj == null ? ""null"" :  obj.getClass().getName();
                LOGGER.fatalError(msg);
                throw new IllegalStateException(msg);
            }
            QueueConnectionFactory factory = (QueueConnectionFactory) obj;
            Queue sendQueue = (Queue) context.lookup(getSendQueue());

            if (!useTemporyQueue()) {
                receiveQueue = (Queue) context.lookup(getReceiveQueue());
                receiverThread = Receiver.createReceiver(factory, receiveQueue, getPrincipal(context), getCredentials(context)
                        , isUseResMsgIdAsCorrelId(), getJMSSelector());
            }

            String principal = null;
            String credentials = null;
            if (USE_SECURITY_PROPERTIES){
                principal = getPrincipal(context);
                credentials = getCredentials(context);
            }
            if (principal != null && credentials != null) {
                connection = factory.createQueueConnection(principal, credentials);
            } else {
                connection = factory.createQueueConnection();
            }

            session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Session created"");
            }

            if (getPropertyAsBoolean(IS_ONE_WAY)) {
                producer = session.createSender(sendQueue);
                if (isNonPersistent()) {
                    producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
                }
            } else {

                if (useTemporyQueue()) {
                    executor = new TemporaryQueueExecutor(session, sendQueue);
                } else {
                    producer = session.createSender(sendQueue);
                    if (isNonPersistent()) {
                        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
                    }
                    executor = new FixedQueueExecutor(producer, getTimeoutAsInt(), isUseReqMsgIdAsCorrelId());
                }
            }
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Starting connection"");
            }

            connection.start();

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(""Connection started"");
            }
        } catch (Exception e) {
            thrown = e;
            LOGGER.error(e.getLocalizedMessage(), e);
        } catch (NoClassDefFoundError e) {
            thrown = e;
            LOGGER.error(e.getLocalizedMessage(), e);
        } finally {
            if (context != null) {
                try {
                    context.close();
                } catch (NamingException ignored) {
                    // ignore
                }
            }
        }
    }"
118,9658,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jmeter.save,org.apache.jmeter.save.SaveService$XStreamWrapper$1,,realClass,,alias,"alias,fullName,fullName,null,super,realClass",82,82,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/core/org/apache/jmeter/save/SaveService.java#L82,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/core/org/apache/jmeter/save/SaveService.java,,open,"@Override
            public Class<?> realClass(String alias) {
                String fullName = aliasToClass(alias);
                return super.realClass(fullName == null ? alias : fullName);
            }"
119,9669,jmeter,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,A,last,,STYLE,org.apache.jmeter.protocol.http.parser,org.apache.jmeter.protocol.http.parser.HtmlParsingUtils,,isAnchorMatched,,arguments,"arguments,null,query,getArgumentCount",85,85,close,https://github.com/apache/jmeter/tree/e21247b3b461bf0af80f0e80cb876dfb1f83ca9f//src/protocol/http/org/apache/jmeter/protocol/http/parser/HtmlParsingUtils.java#L85,https://github.com/apache/jmeter/tree/b3f452902a78827bd885e6dbf30b14d11fb4df93//src/protocol/http/org/apache/jmeter/protocol/http/parser/HtmlParsingUtils.java,,close,"public static boolean isAnchorMatched(HTTPSamplerBase newLink, HTTPSamplerBase config)
    {
        String query = null;
        try {
            query = URLDecoder.decode(newLink.getQueryString(), ""UTF-8""); // $NON-NLS-1$
        } catch (UnsupportedEncodingException e) {
            // UTF-8 unsupported? You must be joking!
            log.error(""UTF-8 encoding not supported!"");
            throw new Error(""Should not happen: "" + e.toString());
        }

        final Arguments arguments = config.getArguments();
        if (query == null && arguments.getArgumentCount() > 0) {
            return false;// failed to convert query, so assume no match
        }

        final Perl5Matcher matcher = JMeterUtils.getMatcher();
        final PatternCacheLRU patternCache = JMeterUtils.getPatternCache();

        if (!isEqualOrMatches(newLink.getProtocol(), config.getProtocol(), matcher, patternCache)){
            return false;
        }

        final String domain = config.getDomain();
        if (domain != null && domain.length() > 0) {
            if (!isEqualOrMatches(newLink.getDomain(), domain, matcher, patternCache)){
                return false;
            }
        }

        final String path = config.getPath();
        if (!newLink.getPath().equals(path)
                && !matcher.matches(newLink.getPath(), patternCache.getPattern(""[/]*"" + path, // $NON-NLS-1$
                        Perl5Compiler.READ_ONLY_MASK))) {
            return false;
        }

        PropertyIterator iter = arguments.iterator();
        while (iter.hasNext()) {
            Argument item = (Argument) iter.next().getObjectValue();
            final String name = item.getName();
            if (query.indexOf(name + ""="") == -1) { // $NON-NLS-1$
                if (!(matcher.contains(query, patternCache.getPattern(name, Perl5Compiler.READ_ONLY_MASK)))) {
                    return false;
                }
            }
        }

        return true;
    }"
120,3112,cassandra,NP_NULL_PARAM_DEREF,C,last,,CORRECTNESS,org.apache.cassandra.gms,org.apache.cassandra.gms.Gossiper,,unsafeAssassinateEndpoint,,ApplicationState,"ApplicationState,StorageService,computeExpireTime,epState,tokens,STATUS,addApplicationState,instance,left,valueFactory",496,496,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/java/org/apache/cassandra/gms/Gossiper.java#L496,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/gms/Gossiper.java,,unknown,"public void unsafeAssassinateEndpoint(String address) throws UnknownHostException
    {
        InetAddress endpoint = InetAddress.getByName(address);
        EndpointState epState = endpointStateMap.get(endpoint);
        Collection<Token> tokens = null;
        logger.warn(""Assassinating {} via gossip"", endpoint);

        if (epState == null)
        {
            epState = new EndpointState(new HeartBeatState((int) ((System.currentTimeMillis() + 60000) / 1000), 9999));
        }
        else
        {
            try
            {
                tokens = StorageService.instance.getTokenMetadata().getTokens(endpoint);
            }
            catch (Throwable th)
            {
                // TODO this is broken
                logger.warn(""Unable to calculate tokens for {}.  Will use a random one"", address);
                tokens = Collections.singletonList(StorageService.getPartitioner().getRandomToken());
            }
            int generation = epState.getHeartBeatState().getGeneration();
            logger.info(""Sleeping for "" + StorageService.RING_DELAY + ""ms to ensure "" + endpoint + "" does not change"");
            Uninterruptibles.sleepUninterruptibly(StorageService.RING_DELAY, TimeUnit.MILLISECONDS);
            // make sure it did not change
            epState = endpointStateMap.get(endpoint);
            if (epState.getHeartBeatState().getGeneration() != generation)
                throw new RuntimeException(""Endpoint "" + endpoint + "" generation changed while trying to remove it"");
            epState.updateTimestamp(); // make sure we don't evict it too soon
            epState.getHeartBeatState().forceNewerGenerationUnsafe();
        }

        // do not pass go, do not collect 200 dollars, just gtfo
        epState.addApplicationState(ApplicationState.STATUS, StorageService.instance.valueFactory.left(tokens, computeExpireTime()));
        handleMajorStateChange(endpoint, epState);
        Uninterruptibles.sleepUninterruptibly(intervalInMillis * 4, TimeUnit.MILLISECONDS);
        logger.warn(""Finished assassinating {}"", endpoint);
    }"
121,3620,cassandra,NP_NULL_PARAM_DEREF,C,last,,CORRECTNESS,org.apache.cassandra.cql,org.apache.cassandra.cql.CqlParser,,relation,,"return new Relation(name, (type!=null?type.getText():null), t);",,3495,3495,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/gen-java/org/apache/cassandra/cql/CqlParser.java#L3495,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql/CqlParser.java,,unknown,
122,4064,cassandra,NP_NULL_PARAM_DEREF,C,last,,CORRECTNESS,org.apache.cassandra.cql3,org.apache.cassandra.cql3.CqlParser,,userOption,,"opts.put((k!=null?k.getText():null), (v!=null?v.getText():null));",,4812,4812,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/gen-java/org/apache/cassandra/cql3/CqlParser.java#L4812,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql3/CqlParser.java,,unknown,
123,4118,cassandra,NP_NULL_ON_SOME_PATH,C,last,,CORRECTNESS,org.apache.cassandra.cql,org.apache.cassandra.cql.CqlParser,,selectStatement,,cLevel = ConsistencyLevel.valueOf((K_LEVEL15!=null?K_LEVEL15.getText():null).toUpperCase());,,588,588,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/gen-java/org/apache/cassandra/cql/CqlParser.java#L588,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql/CqlParser.java,,unknown,
124,6665,cassandra,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.cassandra.service,org.apache.cassandra.service.StorageService,,getValidColumnFamilies,,cfStore,"cfStore,null",2270,2270,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/java/org/apache/cassandra/service/StorageService.java#L2270,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/service/StorageService.java,,unknown,"public Iterable<ColumnFamilyStore> getValidColumnFamilies(boolean allowIndexes, boolean autoAddIndexes, String keyspaceName, String... cfNames) throws IOException
    {
        Keyspace keyspace = getValidKeyspace(keyspaceName);

        if (cfNames.length == 0)
            // all stores are interesting
            return keyspace.getColumnFamilyStores();

        // filter out interesting stores
        Set<ColumnFamilyStore> valid = new HashSet<ColumnFamilyStore>();
        for (String cfName : cfNames)
        {
            //if the CF name is an index, just flush the CF that owns the index
            String baseCfName = cfName;
            String idxName = null;
            if (cfName.contains(""."")) // secondary index
            {
                if(!allowIndexes)
                {
                   logger.warn(""Operation not allowed on secondary Index column family ({})"", cfName);
                    continue;
                }

                String[] parts = cfName.split(""\\."", 2);
                baseCfName = parts[0];
                idxName = parts[1];
            }

            ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore(baseCfName);
            if (cfStore == null)
            {
                // this means there was a cf passed in that is not recognized in the keyspace. report it and continue.
                logger.warn(String.format(""Invalid column family specified: %s. Proceeding with others."", baseCfName));
                continue;
            }
            if (idxName != null)
            {
                Collection< SecondaryIndex > indexes = cfStore.indexManager.getIndexesByNames(new HashSet<String>(Arrays.asList(cfName)));
                if (indexes.isEmpty())
                    logger.warn(String.format(""Invalid column family index specified: %s/%s. Proceeding with others."", baseCfName, idxName));
                else
                    valid.add(Iterables.get(indexes, 0).getIndexCfs());
            }
            else
            {
                valid.add(cfStore);
                if(autoAddIndexes)
                {
                    for(SecondaryIndex si : cfStore.indexManager.getIndexes())
                    {
                        logger.info(""adding secondary index {} to operation"", si.getIndexName());
                        valid.add(si.getIndexCfs());
                    }
                }
            }
        }
        return valid;
    }"
125,7482,cassandra,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,C,last,,STYLE,org.apache.cassandra.io.sstable,org.apache.cassandra.io.sstable.LegacySSTableTest,,testStreaming,,LEGACY_SSTABLE_ROOT,"LEGACY_SSTABLE_ROOT,listFiles",99,99,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java#L99,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java,,unknown,"@Test
    public void testStreaming() throws Throwable
    {
        StorageService.instance.initServer();

        for (File version : LEGACY_SSTABLE_ROOT.listFiles())
            if (Descriptor.Version.validate(version.getName()))
                testStreaming(version.getName());
    }"
126,7845,cassandra,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,C,last,,STYLE,org.apache.cassandra.cql,org.apache.cassandra.cql.CqlParser,,alterTableStatement,,"validator = (addValidator!=null?input.toString(addValidator.start,addValidator.stop):null);",,2842,2842,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/gen-java/org/apache/cassandra/cql/CqlParser.java#L2842,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql/CqlParser.java,,unknown,
127,9174,cassandra,NP_NULL_ON_SOME_PATH,C,last,,CORRECTNESS,org.apache.cassandra.cql3,org.apache.cassandra.cql3.CqlParser,,columnOperation,,"addRecognitionError(""Only expressions of the form X = X "" + ((i!=null?i.getText():null).charAt(0) == '-' ? '-' : '+') + "" <value> are supported."");",,6420,6420,close,https://github.com/apache/cassandra/tree/4ed2234078c4d302c256332252a8ddd6ae345484//src/gen-java/org/apache/cassandra/cql3/CqlParser.java#L6420,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql3/CqlParser.java,,unknown,
128,3926,cassandra,NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE,A,last,,STYLE,org.apache.cassandra.utils.IntervalTree,org.apache.cassandra.utils.IntervalTree.Interval$1,,compare,,,,-2,-2,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//src/java/org/apache/cassandra/utils/IntervalTree/Interval.java#L-2,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/utils/IntervalTree/Interval.java,,unknown,"public int compare(Interval interval, Interval interval1)
        {
            return interval.min.compareTo(interval1.min);
        }"
129,4717,cassandra,NP_NULL_PARAM_DEREF,A,last,,CORRECTNESS,org.apache.cassandra.cql,org.apache.cassandra.cql.CqlParser,,dropIndexStatement,,expr = new DropIndexStatement((index!=null?index.getText():null));,,2763,2763,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//src/gen-java/org/apache/cassandra/cql/CqlParser.java#L2763,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql/CqlParser.java,,unknown,
130,6966,cassandra,NP_NULL_PARAM_DEREF,A,last,,CORRECTNESS,org.apache.cassandra.thrift,org.apache.cassandra.thrift.CassandraServer,,execute_cql_query,,QueryProcessor,"QueryProcessor,queryString,state,process",1222,1222,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//src/java/org/apache/cassandra/thrift/CassandraServer.java#L1222,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/thrift/CassandraServer.java,,unknown,"public CqlResult execute_cql_query(ByteBuffer query, Compression compression)
    throws InvalidRequestException, UnavailableException, TimedOutException, SchemaDisagreementException, TException
    {
        String queryString = null;
        
        // Decompress the query string.
        try
        {
            switch (compression)
            {
                case GZIP:
                	FastByteArrayOutputStream byteArray = new FastByteArrayOutputStream();
                    byte[] outBuffer = new byte[1024], inBuffer = new byte[1024];
                    
                    Inflater decompressor = new Inflater();
                    
                    int lenRead = 0;
                    while (true)
                    {
                        if (decompressor.needsInput())
                            lenRead = query.remaining() < 1024 ? query.remaining() : 1024;
                            query.get(inBuffer, 0, lenRead);
                            decompressor.setInput(inBuffer, 0, lenRead);
                        
                        int lenWrite = 0;
                        while ((lenWrite = decompressor.inflate(outBuffer)) !=0)
                            byteArray.write(outBuffer, 0, lenWrite);
                        
                        if (decompressor.finished())
                            break;
                    }
                    
                    decompressor.end();
                    
                    queryString = new String(byteArray.toByteArray(), 0, byteArray.size(), ""UTF-8"");
                    break;
                case NONE:
                    try 
                    {
                        queryString = ByteBufferUtil.string(query);
                    }
                    catch (CharacterCodingException ex) 
                    {
                        throw new InvalidRequestException(ex.getMessage());
                    }
                    break;
            }
        }
        catch (DataFormatException e)
        {
            throw new InvalidRequestException(""Error deflating query string."");
        }
        catch (UnsupportedEncodingException e)
        {
            throw new InvalidRequestException(""Unknown query string encoding."");
        }
        
        try
        {
            return QueryProcessor.process(queryString, state());
        }
        catch (RecognitionException e)
        {
            InvalidRequestException ire = new InvalidRequestException(""Invalid or malformed CQL query string"");
            ire.initCause(e);
            throw ire;
        }
    }"
131,8649,cassandra,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,A,last,,STYLE,org.apache.cassandra.config,org.apache.cassandra.config.DatabaseDescriptor,,loadSchemas,,dataPath,"dataPath,listFiles",478,478,close,https://github.com/apache/cassandra/tree/7efab48e72247734ae38eabfc61a9ff0a5aa87ec//src/java/org/apache/cassandra/config/DatabaseDescriptor.java#L478,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/config/DatabaseDescriptor.java,,unknown,"public static void loadSchemas() throws IOException                         
    {
        // we can load tables from local storage if a version is set in the system table and that acutally maps to
        // real data in the definitions table.  If we do end up loading from xml, store the defintions so that we
        // don't load from xml anymore.
        UUID uuid = Migration.getLastMigrationId();
        if (uuid == null)
        {
            logger.info(""Couldn't detect any schema definitions in local storage."");
            // peek around the data directories to see if anything is there.
            boolean hasExistingTables = false;
            for (String dataDir : getAllDataFileLocations())
            {
                File dataPath = new File(dataDir);
                if (dataPath.exists() && dataPath.isDirectory())
                {
                    // see if there are other directories present.
                    int dirCount = dataPath.listFiles(new FileFilter()
                    {
                        public boolean accept(File pathname)
                        {
                            return pathname.isDirectory();
                        }
                    }).length;
                    if (dirCount > 0)
                        hasExistingTables = true;
                }
                if (hasExistingTables)
                {
                    break;
                }
            }
            
            if (hasExistingTables)
                logger.info(""Found table data in data directories. Consider using the CLI to define your schema."");
            else
                logger.info(""To create keyspaces and column families, see 'help create keyspace' in the CLI, or set up a schema using the thrift system_* calls."");
        }
        else
        {
            logger.info(""Loading schema version "" + uuid.toString());
            Collection<KSMetaData> tableDefs = DefsTable.loadFromStorage(uuid);   

            // happens when someone manually deletes all tables and restarts.
            if (tableDefs.size() == 0)
            {
                logger.warn(""No schema definitions were found in local storage."");
                // set version so that migrations leading up to emptiness aren't replayed.
                Schema.instance.setVersion(uuid);
            }
            else // if non-system tables where found, trying to load them
            {
                Schema.instance.load(tableDefs, uuid);
            }
        }

        Schema.instance.fixCFMaxId();
    }"
132,3713,cassandra,NP_NULL_PARAM_DEREF,B,last,,CORRECTNESS,org.apache.cassandra.cql3,org.apache.cassandra.cql3.CqlParser,,selectStatement,,limit = Integer.parseInt((rows!=null?rows.getText():null));,,860,860,close,https://github.com/apache/cassandra/tree/69337a43670f71ae1fc55e23d6a9031230423900//src/gen-java/org/apache/cassandra/cql3/CqlParser.java#L860,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/gen-java/org/apache/cassandra/cql3/CqlParser.java,,unknown,
133,6067,cassandra,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,B,last,,STYLE,org.apache.cassandra.io.sstable,org.apache.cassandra.io.sstable.SSTableReaderTest,,testPersistentStatisticsFromOlderIndexedSSTable,,rootDir,"rootDir,listFiles",234,234,close,https://github.com/apache/cassandra/tree/69337a43670f71ae1fc55e23d6a9031230423900//test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java#L234,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java,,unknown,"@Test
    public void testPersistentStatisticsFromOlderIndexedSSTable() throws IOException, ExecutionException, InterruptedException
    {
        // copy legacy indexed sstables
        String root = System.getProperty(""legacy-sstable-root"");
        assert root != null;
        File rootDir = new File(root + File.separator + ""hb"" + File.separator + ""Keyspace1"");
        assert rootDir.isDirectory();

        File destDir = Directories.create(""Keyspace1"", ""Indexed1"").getDirectoryForNewSSTables(0);
        assert destDir != null;

        FileUtils.createDirectory(destDir);
        for (File srcFile : rootDir.listFiles())
        {
            if (!srcFile.getName().startsWith(""Indexed1""))
                continue;
            File destFile = new File(destDir, srcFile.getName());
            CLibrary.createHardLink(srcFile, destFile);

            assert destFile.exists() : destFile.getAbsoluteFile();
        }
        ColumnFamilyStore store = Table.open(""Keyspace1"").getColumnFamilyStore(""Indexed1"");

        // check if opening and querying works
        assertIndexQueryWorks(store);
    }"
134,7553,cassandra,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,B,last,,STYLE,org.apache.cassandra.io.sstable,org.apache.cassandra.io.sstable.AbstractSSTableSimpleWriter$1,,accept,,,"null,null,p,p,left",70,70,close,https://github.com/apache/cassandra/tree/69337a43670f71ae1fc55e23d6a9031230423900//src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java#L70,https://github.com/apache/cassandra/tree/f3e38cb638113c2a23855a104d6082da5bc10ddb//src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java,,unknown,"public boolean accept(File dir, String name)
            {
                Pair<Descriptor, Component> p = SSTable.tryComponentFromFilename(dir, name);
                Descriptor desc = p == null ? null : p.left;
                if (desc == null)
                    return false;

                if (desc.cfname.equals(columnFamily))
                    existing.add(desc);

                return false;
            }"
